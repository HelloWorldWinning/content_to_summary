Timestamp: 2025-08-22T20:54:01.229487
Title: Where Rust Really Shines - In Pursuit of Laziness
URL: https://manishearth.github.io/blog/2015/05/03/where-rust-really-shines/
Status: success
Duration: 0:00

Description:
**核心思想提炼与总结**

**1. 概述与核心问题**
作者通过在Rust编译器中添加一个功能（为API暴露的结构体提供对堆分配向量“attributes”的访问）来展示Rust作为编程语言的卓越之处。核心问题在于如何高效且安全地访问这些向量，避免不必要的内存复制。

**2. C++方案的挑战与局限**
*   **克隆是默认安全选项：** 在C++中，为了确保安全（避免向量解分配、重新分配或迭代器失效），唯一的可靠选择通常是克隆（复制）整个向量的内容。
*   **指针的风险与人工负担：** 直接使用指针（引用）则面临巨大的风险，尤其在大型、动态变化的AST（抽象语法树）编译阶段。开发者需要花费大量时间手动确认指针指向的向量不会被解分配、移动或修改，这在C++中几乎是不可能完成且极易出错的任务，导致代码脆弱且维护成本高。

**3. Rust的解决方案：切片与生命周期**
*   **零成本抽象：** Rust提供了“切片”（slice），即对向量内容的引用。编译器能够确保这种引用的安全性，无需进行昂贵的克隆操作。这对于频繁调用的代码或性能敏感的场景至关重要。
*   **编译器驱动的开发：**
    1.  作者首先在结构体中添加了带有生命周期参数（`'a`）的切片字段。
    2.  初期代码可能遗漏或错误指定了生命周期，但Rust编译器会智能地检测并报错，提供明确的修改建议（例如，在结构体或函数签名中添加或调整生命周期参数）。
    3.  开发者只需遵循编译器的指导，逐步修正代码，编译器会自动推断并强制执行内存安全所需的生命周期约束，如将返回切片的生命周期与输入参数（如`variant`或`self`的生命周期参数）绑定。
*   **低认知开销：** 整个过程是迭代式的，编译器承担了绝大部分关于内存安全推理的认知负担，使得开发者能够以极低的精力投入，快速且自信地完成复杂的内存安全操作。

**4. Rust的显著优势**
*   **编译时内存安全保证：** 编译器在编译阶段就彻底排除了悬垂指针、迭代器失效等内存安全问题，杜绝了运行时可能出现的段错误，而无需人工干预。
*   **卓越的性能：** 通过零成本抽象（切片），避免了不必要的内存分配和数据复制，实现了显著的性能提升。在Rust中，使用切片被视为默认且优化的做法。
*   **代码健壮性与可维护性：** 编译器强制执行的内存安全规则使得代码对未来的修改更具弹性，降低了维护成本。
*   **优于共享指针：** 相比于C++的共享指针（如`std::shared_ptr`），Rust切片不仅避免了运行时开销，更关键的是它能有效防止迭代器失效，并确保API消费者即使获取内部引用也不会面临安全风险。

**2. 核心观点（一句话总结）**
Rust的生命周期系统和编译时安全检查使得开发者能够以极低的认知开销，安全、高效地实现原本在C++中难以想象的零成本抽象，从而构建出既可靠又高性能的软件。

**3. 总体框架**
Rust的零成本抽象与编译时安全性优势

**4. Mermaid概念图**
<Mermaid_Diagram>
graph LR
    A["Rust的显著优势"] -- "体现在" --> B("核心问题: API结构体访问堆分配向量");

    subgraph "C++方案: 复杂与限制"
        C1("C++: 克隆Vector") -- "结果" --> C2("性能开销: 大量分配/拷贝");
        C1 -- "替代方案但高风险" --> C3("直接使用指针");
        C3 -- "风险1" --> C4("Vector解分配/重新分配");
        C3 -- "风险2" --> C5("迭代器失效");
        C3 -- "需" --> C6("人工确保安全: 几乎不可能");
        C6 -- "导致" --> C7("代码脆弱性");
    end

    subgraph "Rust方案: 零成本抽象与安全"
        R1("Rust: 使用切片 (Slices)") -- "实现" --> R2("性能优势: 零额外开销");
        R1 -- "通过" --> R3("内存安全: 编译器保证");
        R3 -- "核心机制" --> R4("生命周期系统");
        R4 -- "编译时检查" --> R5("杜绝悬垂指针");
        R4 -- "编译时检查" --> R6("杜绝迭代器失效");
    end

    B -- "在C++中面临" --> C1;
    B -- "在Rust中采用" --> R1;

    subgraph "Rust的开发体验: 编译器指导"
        D1("初始代码: 遗漏生命周期");
        D1 -- "触发" --> D2("Rust编译器错误与建议");
        D2 -- "开发者遵循" --> D3("添加/调整生命周期参数");
        D3 -- "达成" --> D4("快速安全实现");
    end

    R1 -- "具体实践涉及" --> D1;

    A -- "核心总结" --> E("结论: 安全、高效、低认知开销");

    subgraph "与C++替代方案对比"
        F1("C++共享指针");
        F1 -- "缺点1" --> F2("运行时开销");
        F1 -- "缺点2" --> F3("不防迭代器失效");
        R1 -- "优于" --> F1;
    end

    style A fill:#4CAF50,stroke:#333,stroke-width:2px,color:#FFF;
    style B fill:#FFD700,stroke:#333,stroke-width:1px,color:#333;

    style C1 fill:#FF8C00,stroke:#333,stroke-width:1px,color:#333;
    style C2 fill:#FF6347,stroke:#333,stroke-width:1px,color:#333;
    style C3 fill:#FF0000,stroke:#333,stroke-width:1px,color:#FFF;
    style C4 fill:#B22222,stroke:#333,stroke-width:1px,color:#FFF;
    style C5 fill:#B22222,stroke:#333,stroke-width:1px,color:#FFF;
    style C6 fill:#DC143C,stroke:#333,stroke-width:1px,color:#FFF;
    style C7 fill:#DC143C,stroke:#333,stroke-width:1px,color:#FFF;

    style R1 fill:#8BC34A,stroke:#333,stroke-width:1px,color:#333;
    style R2 fill:#66BB6A,stroke:#333,stroke-width:1px,color:#333;
    style R3 fill:#4CAF50,stroke:#333,stroke-width:1px,color:#FFF;
    style R4 fill:#9CCC65,stroke:#333,stroke-width:1px,color:#333;
    style R5 fill:#388E3C,stroke:#333,stroke-width:1px,color:#FFF;
    style R6 fill:#388E3C,stroke:#333,stroke-width:1px,color:#FFF;

    style D1 fill:#ADD8E6,stroke:#333,stroke-width:1px,color:#333;
    style D2 fill:#87CEEB,stroke:#333,stroke-width:1px,color:#333;
    style D3 fill:#6495ED,stroke:#333,stroke-width:1px,color:#FFF;
    style D4 fill:#4169E1,stroke:#333,stroke-width:1px,color:#FFF;

    style E fill:#2E8B57,stroke:#333,stroke-width:2px,color:#FFF;

    style F1 fill:#FFB6C1,stroke:#333,stroke-width:1px,color:#333;
    style F2 fill:#F08080,stroke:#333,stroke-width:1px,color:#333;
    style F3 fill:#F08080,stroke:#333,stroke-width:1px,color:#333;

    linkStyle 0 stroke:#00008B,stroke-width:2px;
    linkStyle 1 stroke:#DAA520,stroke-width:1px;
    linkStyle 2 stroke:#008000,stroke-width:1px;
    linkStyle 3 stroke:#FF0000,stroke-width:1px;
    linkStyle 4 stroke:#B22222,stroke-width:1px;
    linkStyle 5 stroke:#B22222,stroke-width:1px;
    linkStyle 6 stroke:#DC143C,stroke-width:1px;
    linkStyle 7 stroke:#DC143C,stroke-width:1px;
    linkStyle 8 stroke:#66BB6A,stroke-width:1px;
    linkStyle 9 stroke:#4CAF50,stroke-width:1px;
    linkStyle 10 stroke:#9CCC65,stroke-width:1px;
    linkStyle 11 stroke:#388E3C,stroke-width:1px;
    linkStyle 12 stroke:#388E3C,stroke-width:1px;
    linkStyle 13 stroke:#ADD8E6,stroke-width:1px;
    linkStyle 14 stroke:#87CEEB,stroke-width:1px;
    linkStyle 15 stroke:#6495ED,stroke-width:1px;
    linkStyle 16 stroke:#4169E1,stroke-width:1px;
    linkStyle 17 stroke:#2E8B57,stroke-width:2px;
    linkStyle 18 stroke:#FFB6C1,stroke-width:1px;
    linkStyle 19 stroke:#F08080,stroke-width:1px;
    linkStyle 20 stroke:#F08080,stroke-width:1px;
</Mermaid_Diagram>

Content:
Where Rust Really Shines Posted by Manish Goregaokar on May 03, 2015 in programming , rust Yesterday I was working on a small feature for the Rust compiler, and came across a situation which really showcased Rust’s
awesomeness as a language. There was a struct which was exposed to an API,
and I wished to give it access to a list of things known as “attributes”, where the list was a heap-allocated vector . Now, I have two ways of actually giving the struct access to a vector. I can either clone it (i.e. make a copy of its contents), 
or use a reference (pointer) to it or its contents. In a language like C++ there’s only once choice in this situation; that is
to clone the vector 1 . In a large C++ codebase if I wished to use a pointer I would need to be sure that the vector
isn’t deallocated by the time I’m done with it, and more importantly, to be sure that no other code pushes to the vector (when a vector overflows its
capacity it will be reallocated, invalidating any other pointers to its contents). For a smaller codebase this might be possible, but in this specific case it could have taken me a while to become sure of this.
The code was related to the “expansion” portion of compilation, where the AST is expanded to a bigger AST. A lot of things change and get
moved around, so it is reasonable to assume that it might not be possible to safely use it.
I would have had to find out where the vector is originally stored; all the entry points for the code I was
modifying, and make sure it isn’t being mutated (not as hard in Rust, but I would
still need to muck around a large codebase). And then I would have to somehow make sure that nobody tries to mutate it
in the future. This is a task which I would not even consider trying in C++. However, I had another option here, because this was Rust. In Rust I can store a reference to the contents of the vector
without fear of invalidation, since the compiler will prevent me from using the vector in a way that could cause unsafety. 
Such a reference is known as a slice . Whilst in C++ I would have to manually go through a lot of code to be sure of safety
(and even after all that be left with code that would be brittle to changes elsewhere
the codebase), in Rust the compiler can do this for me! Being able to do this was important
— this code is called quite often for a regular compile, and all those
extra allocations could be heavy, especially given that this was a feature that would be used
by very few. So first I started off by adding a field to the FieldInfo struct which was a slice of attributes . Notice that I added a lifetime specifier, the 'a to the struct definition. /// Summary of the relevant parts of a struct/enum field. pub struct FieldInfo < 'a > { /// ... /// The attributes on the field pub attrs : & 'a [ ast :: Attribute ], } For those of you new to Rust, a lifetime is part of the type of a reference. It’s related to the scope of the reference, and generally can be treated as
a generic parameter. So, for example, here, I have a FieldInfo with a lifetime parameter of 'a where 'a is the lifetime of the inner slice of attributes.
If I construct this struct with slices from different scopes, its type will be different each time. Lifetimes can get automatically cast depending on their context however,
and quite often they get elided away, so one doesn’t need to specify them that much (aside from struct/enum definitions). You can find more information in the Rust book I then updated code everywhere to pass the attributes from their source to their destination through the chained methods. An important thing to note here is that none of the lifetime specifiers you see now in the commit were added when I did this. For example, the return value
of create_struct_pattern was (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>, &[ast::Attribute])>) at this point, not (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])>) .
You can ignore the complicated types being passed around, for now just pretend that a slice of attributes was returned. Now comes the magic. After these small changes necessary for the feature, I basically let the compiler do the rest of the work. See, at this point the code was wrong.
I had forgotten lifetime specifiers in places where they were important, and still wasn’t sure if storing a reference would in fact be possible in the first place.
However, the compiler was smart enough to figure things out for me. It would tell me to add lifetime specifiers, and I would add them. First, the compiler asked me to add a lifetime to the FieldInfo parts of SubstructureFields . So, the following: pub enum SubstructureFields < 'a > { Struct ( Vec < FieldInfo > ), EnumMatching ( usize , & 'a ast :: Variant , Vec < FieldInfo > ), // ... } became pub enum SubstructureFields < 'a > { Struct ( Vec < FieldInfo < 'a >> ), EnumMatching ( usize , & 'a ast :: Variant , Vec < FieldInfo < 'a >> ), // ... } This needed to happen because elision doesn’t work for structs and enums,
and besides, the compiler would need to know if the &ast::Variant was supposed to be the same lifetime as the parameter of the FieldInfo s. I decided
to just use the existing 'a parameter, which meant that yes, the &ast::Variant was supposed to live just as long. I could also have opted to give the FieldInfo s
a different lifetime by adding a 'b parameter, but I guessed that it would work this way too (knowing the origin of the fieldinfo and variant, and that implicit lifetime casting would
fix most issues that cropped up). I didn’t need to think this out much, though — the compiler gave me a suggestion and I could simply copy it. The next error was in create_enum_variant_pattern() and create_struct_pattern() as well as some other places. Here, the method had a signature of fn create_enum_variant_pattern ( & self , cx : & mut ExtCtxt , enum_ident : ast :: Ident , variant : & ast :: Variant , prefix : & str , mutbl : ast :: Mutability ) -> ( P < ast :: Pat > , Vec < ( Span , Option < Ident > , P < Expr > , & [ ast :: Attribute ]) > ) and I changed it to fn create_enum_variant_pattern < 'a > ( & self , cx : & mut ExtCtxt , enum_ident : ast :: Ident , variant : & 'a ast :: Variant , prefix : & str , mutbl : ast :: Mutability ) -> ( P < ast :: Pat > , Vec < ( Span , Option < Ident > , P < Expr > , & 'a [ ast :: Attribute ]) > ) In this case, the code was uncomfortable with taking a slice of attributes out of an arbitrary StructDef reference and returning it. What if the StructDef doesn’t live long enough?
Generally the compiler internally figures out the lifetimes necessary and uses them here, but if you have too many references there’s no single way to make the fix.
In this case, the compiler suggested I add a 'a to &StructDef and the returned &[Attribute] , and I did so. The 'a lifetime was declared at the top of the impl , so it was the lifetime parameter of self 2 . This meant that the returned attribute of the function will
have a lifetime tied to self and the input StructDef , and due to this it cannot outlive the inputs, which is what we wanted in the first place. In essence, I took a bit of code that was doing: fn minicreate ( & self , variant : & ast :: Variant ) -> & [ ast :: Attribute ] { // do stuff // return variant.attributes } and changed it to // we are sure that the returned slice cannot outlive the variant argument fn minicreate < 'a > ( & self , variant : & 'a ast :: Variant ) -> & 'a [ ast :: Attribute ] { // do stuff // return variant.attributes } Again, I didn’t need to think this out much (I’m only thinking it through now for this blog post). I followed the suggestion given to me by the compiler: error: cannot infer an appropriate lifetime for automatic coercion due to conflicting requirements
help: consider using an explicit lifetime parameter as shown: fn create_enum_variant_pattern<'a>(&self, cx: &mut ExtCtxt, enum_ident: ast::Ident, variant: &'a ast::Variant, prefix: &str, mutbl: ast::Mutability) -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])>) There were a couple of similar errors elsewhere that were caused by tying these two lifetimes together. Since these methods were chained, updating the lifetimes of a child method
would mean that I would have to now update the parent method which passes its arguments down to the children and returns a modification of its return value (and thus must now impose the
same restrictions on its own signature). All of this was done by just listening to the suggestions of the compiler (which all contain a function signature to try out). In some cases I introduced a 'b lifetime, because tying it to 'a (the self lifetime parameter) was possibly too restrictive. All of this at the suggestion of the compiler. While this all seems long and complicated, in reality it wasn’t. I simply added the field to the initial struct, tried compiling a couple of times to figure out which code needed updating
to pass around the attributes, and then went through 3-4 more compilation attempts to fix the lifetimes. It didn’t take long, and I didn’t need to put much mental effort into it. I just
listened to the compiler, and it worked. And now I trust completely that that code will not cause any segfaults due to attempted access of a destroyed or moved vector. And this is despite the fact that I still don’t know
where that particular vector is modified or destroyed — I didn’t explore that far because I didn’t need to! (or want to :P) And this is one place Rust really shines. It lets you do optimizations which you wouldn’t dream of doing in C++. In fact, while the C++ way of looking at this problem
would probably be to just clone and move on, most Rust programmers would think of using slices as the default, and not even consider it an “optimization”. And again, this wasn’t
with much cognitive overhead; I could just follow the compiler and it fixed everything for me. Some people have pointed out that a shared pointer to the vector itself would work here too. This is correct, but a shared pointer also has a runtime overhead, and more importantly doesn’t prevent iterator invalidation. I had no idea how the vector was being used elsewhere, so this was a risk I didn’t want to take. Additionally, whilst a shared pointer to the vector itself is immune to the issue of the vector being moved, since this was an API, someone consuming the API might take a reference of an attribute and hold on to it long enough for it to become invalidated. This is something we can’t have either – an API consumer should not have to worry about where the pointers will invalidate. ↩ Note: This is not the lifetime of the reference &self , which is the lifetime of the pointer ( &'b self ), but the lifetime parameter of self , a TraitDef<'a> , which has a lifetime parameter for its child fields. ↩ Posted by Manish Goregaokar programming , rust Tweet « New blog! The problem with single-threaded shared mutability » Where Rust Really Shines Posted by Manish Goregaokar on May 03, 2015 in programming , rust Yesterday I was working on a small feature for the Rust compiler, and came across a situation which really showcased Rust’s
awesomeness as a language. There was a struct which was exposed to an API,
and I wished to give it access to a list of things known as “attributes”, where the list was a heap-allocated vector . Now, I have two ways of actually giving the struct access to a vector. I can either clone it (i.e. make a copy of its contents), 
or use a reference (pointer) to it or its contents. In a language like C++ there’s only once choice in this situation; that is
to clone the vector 1 . In a large C++ codebase if I wished to use a pointer I would need to be sure that the vector
isn’t deallocated by the time I’m done with it, and more importantly, to be sure that no other code pushes to the vector (when a vector overflows its
capacity it will be reallocated, invalidating any other pointers to its contents). For a smaller codebase this might be possible, but in this specific case it could have taken me a while to become sure of this.
The code was related to the “expansion” portion of compilation, where the AST is expanded to a bigger AST. A lot of things change and get
moved around, so it is reasonable to assume that it might not be possible to safely use it.
I would have had to find out where the vector is originally stored; all the entry points for the code I was
modifying, and make sure it isn’t being mutated (not as hard in Rust, but I would
still need to muck around a large codebase). And then I would have to somehow make sure that nobody tries to mutate it
in the future. This is a task which I would not even consider trying in C++. However, I had another option here, because this was Rust. In Rust I can store a reference to the contents of the vector
without fear of invalidation, since the compiler will prevent me from using the vector in a way that could cause unsafety. 
Such a reference is known as a slice . Whilst in C++ I would have to manually go through a lot of code to be sure of safety
(and even after all that be left with code that would be brittle to changes elsewhere
the codebase), in Rust the compiler can do this for me! Being able to do this was important
— this code is called quite often for a regular compile, and all those
extra allocations could be heavy, especially given that this was a feature that would be used
by very few. So first I started off by adding a field to the FieldInfo struct which was a slice of attributes . Notice that I added a lifetime specifier, the 'a to the struct definition. /// Summary of the relevant parts of a struct/enum field. pub struct FieldInfo < 'a > { /// ... /// The attributes on the field pub attrs : & 'a [ ast :: Attribute ], } For those of you new to Rust, a lifetime is part of the type of a reference. It’s related to the scope of the reference, and generally can be treated as
a generic parameter. So, for example, here, I have a FieldInfo with a lifetime parameter of 'a where 'a is the lifetime of the inner slice of attributes.
If I construct this struct with slices from different scopes, its type will be different each time. Lifetimes can get automatically cast depending on their context however,
and quite often they get elided away, so one doesn’t need to specify them that much (aside from struct/enum definitions). You can find more information in the Rust book I then updated code everywhere to pass the attributes from their source to their destination through the chained methods. An important thing to note here is that none of the lifetime specifiers you see now in the commit were added when I did this. For example, the return value
of create_struct_pattern was (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>, &[ast::Attribute])>) at this point, not (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])>) .
You can ignore the complicated types being passed around, for now just pretend that a slice of attributes was returned. Now comes the magic. After these small changes necessary for the feature, I basically let the compiler do the rest of the work. See, at this point the code was wrong.
I had forgotten lifetime specifiers in places where they were important, and still wasn’t sure if storing a reference would in fact be possible in the first place.
However, the compiler was smart enough to figure things out for me. It would tell me to add lifetime specifiers, and I would add them. First, the compiler asked me to add a lifetime to the FieldInfo parts of SubstructureFields . So, the following: pub enum SubstructureFields < 'a > { Struct ( Vec < FieldInfo > ), EnumMatching ( usize , & 'a ast :: Variant , Vec < FieldInfo > ), // ... } became pub enum SubstructureFields < 'a > { Struct ( Vec < FieldInfo < 'a >> ), EnumMatching ( usize , & 'a ast :: Variant , Vec < FieldInfo < 'a >> ), // ... } This needed to happen because elision doesn’t work for structs and enums,
and besides, the compiler would need to know if the &ast::Variant was supposed to be the same lifetime as the parameter of the FieldInfo s. I decided
to just use the existing 'a parameter, which meant that yes, the &ast::Variant was supposed to live just as long. I could also have opted to give the FieldInfo s
a different lifetime by adding a 'b parameter, but I guessed that it would work this way too (knowing the origin of the fieldinfo and variant, and that implicit lifetime casting would
fix most issues that cropped up). I didn’t need to think this out much, though — the compiler gave me a suggestion and I could simply copy it. The next error was in create_enum_variant_pattern() and create_struct_pattern() as well as some other places. Here, the method had a signature of fn create_enum_variant_pattern ( & self , cx : & mut ExtCtxt , enum_ident : ast :: Ident , variant : & ast :: Variant , prefix : & str , mutbl : ast :: Mutability ) -> ( P < ast :: Pat > , Vec < ( Span , Option < Ident > , P < Expr > , & [ ast :: Attribute ]) > ) and I changed it to fn create_enum_variant_pattern < 'a > ( & self , cx : & mut ExtCtxt , enum_ident : ast :: Ident , variant : & 'a ast :: Variant , prefix : & str , mutbl : ast :: Mutability ) -> ( P < ast :: Pat > , Vec < ( Span , Option < Ident > , P < Expr > , & 'a [ ast :: Attribute ]) > ) In this case, the code was uncomfortable with taking a slice of attributes out of an arbitrary StructDef reference and returning it. What if the StructDef doesn’t live long enough?
Generally the compiler internally figures out the lifetimes necessary and uses them here, but if you have too many references there’s no single way to make the fix.
In this case, the compiler suggested I add a 'a to &StructDef and the returned &[Attribute] , and I did so. The 'a lifetime was declared at the top of the impl , so it was the lifetime parameter of self 2 . This meant that the returned attribute of the function will
have a lifetime tied to self and the input StructDef , and due to this it cannot outlive the inputs, which is what we wanted in the first place. In essence, I took a bit of code that was doing: fn minicreate ( & self , variant : & ast :: Variant ) -> & [ ast :: Attribute ] { // do stuff // return variant.attributes } and changed it to // we are sure that the returned slice cannot outlive the variant argument fn minicreate < 'a > ( & self , variant : & 'a ast :: Variant ) -> & 'a [ ast :: Attribute ] { // do stuff // return variant.attributes } Again, I didn’t need to think this out much (I’m only thinking it through now for this blog post). I followed the suggestion given to me by the compiler: error: cannot infer an appropriate lifetime for automatic coercion due to conflicting requirements
help: consider using an explicit lifetime parameter as shown: fn create_enum_variant_pattern<'a>(&self, cx: &mut ExtCtxt, enum_ident: ast::Ident, variant: &'a ast::Variant, prefix: &str, mutbl: ast::Mutability) -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])>) There were a couple of similar errors elsewhere that were caused by tying these two lifetimes together. Since these methods were chained, updating the lifetimes of a child method
would mean that I would have to now update the parent method which passes its arguments down to the children and returns a modification of its return value (and thus must now impose the
same restrictions on its own signature). All of this was done by just listening to the suggestions of the compiler (which all contain a function signature to try out). In some cases I introduced a 'b lifetime, because tying it to 'a (the self lifetime parameter) was possibly too restrictive. All of this at the suggestion of the compiler. While this all seems long and complicated, in reality it wasn’t. I simply added the field to the initial struct, tried compiling a couple of times to figure out which code needed updating
to pass around the attributes, and then went through 3-4 more compilation attempts to fix the lifetimes. It didn’t take long, and I didn’t need to put much mental effort into it. I just
listened to the compiler, and it worked. And now I trust completely that that code will not cause any segfaults due to attempted access of a destroyed or moved vector. And this is despite the fact that I still don’t know
where that particular vector is modified or destroyed — I didn’t explore that far because I didn’t need to! (or want to :P) And this is one place Rust really shines. It lets you do optimizations which you wouldn’t dream of doing in C++. In fact, while the C++ way of looking at this problem
would probably be to just clone and move on, most Rust programmers would think of using slices as the default, and not even consider it an “optimization”. And again, this wasn’t
with much cognitive overhead; I could just follow the compiler and it fixed everything for me. Some people have pointed out that a shared pointer to the vector itself would work here too. This is correct, but a shared pointer also has a runtime overhead, and more importantly doesn’t prevent iterator invalidation. I had no idea how the vector was being used elsewhere, so this was a risk I didn’t want to take. Additionally, whilst a shared pointer to the vector itself is immune to the issue of the vector being moved, since this was an API, someone consuming the API might take a reference of an attribute and hold on to it long enough for it to become invalidated. This is something we can’t have either – an API consumer should not have to worry about where the pointers will invalidate. ↩ Note: This is not the lifetime of the reference &self , which is the lifetime of the pointer ( &'b self ), but the lifetime parameter of self , a TraitDef<'a> , which has a lifetime parameter for its child fields. ↩ Posted by Manish Goregaokar programming , rust Tweet « New blog! The problem with single-threaded shared mutability » About Me I'm a self-taught programmer with interests in programming languages, human languages, Rust, physics, and online communities to name a few. I'm heavily involved in the Rust programming language , leading the Devtools and Clippy teams. I also work at Google on ICU4X . Recent Posts So Zero It's ... Negative? (Zero-Copy #3) Zero-Copy All the Things! (Zero-Copy #2) Not a Yoking Matter (Zero-Copy #1) Colophon: Waiter, There Are Pions in My Blog Post! A Tour of Safe Tracing GC Designs in Rust Categories c++ (2) cryptography (5) css (1) elections (1) html (1) js (1) meta (2) physics (2) poetry (2) politics (1) programming (46) rust (30) systems (1) tidbits (5) unicode (3) web (2) writing (2)
