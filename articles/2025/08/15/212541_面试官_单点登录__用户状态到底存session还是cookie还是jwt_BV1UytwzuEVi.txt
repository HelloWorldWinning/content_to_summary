Timestamp: 2025-08-15T21:25:41.375493
Title: 面试官：单点登录， 用户状态到底存session还是cookie还是jwt BV1UytwzuEVi
URL: https://www.bilibili.com/video/BV1UytwzuEVi?spm_id_from=333.1007.tianma.10-3-31.click
Status: success
Duration: 3:19

Description:
**核心观点：**
通过JWT实现无状态化认证，辅以Cookie或LocalStorage进行令牌传输，是分布式系统单点登录（SSO）高效且可扩展的优选方案。

**Overarching Framework (整体框架):**
单点登录（SSO）中登录状态管理方案的演进与权衡。

**Summary (总结):**

1.  **引言：单点登录（SSO）及其核心问题**
    *   SSO旨在实现分布式系统中用户登录一次即可访问多个子系统。
    *   核心挑战在于如何在跨系统访问中维护用户的登录状态。通常通过网关统一处理请求、认证和转发。

2.  **方案一：Cookie + Session**
    *   **实现机制：** 用户请求 -> 网关检查Cookie中的Session ID -> 请求认证中心验证Session ID有效性 -> 认证成功则转发，失败则重定向至登录页 -> 用户登录成功后，认证中心存储Session并设置Session ID到客户端Cookie。
    *   **优点：** 实现简单。
    *   **缺点：**
        *   认证中心成为性能瓶颈或单点故障。
        *   认证中心集群部署时，各节点Session信息不同步，导致状态一致性问题。
        *   认证中心重启可能导致Session信息丢失。
        *   手动同步Session方案复杂。

3.  **方案二：引入 Redis 存储 Session**
    *   **改进点：** 将Session数据从认证中心内存中剥离，统一存储到高可用的Redis集群中。
    *   **优点：**
        *   解决了认证中心集群Session不同步的问题。
        *   减少了认证中心重启导致Session丢失的问题。
    *   **缺点：**
        *   仍然需要一个外部存储系统（Redis），增加了系统依赖和复杂性。
        *   Redis本身需要考虑高可用和性能，仍存在存储压力。

4.  **方案三：JWT（JSON Web Token）**
    *   **核心理念：** 完全不存储用户登录状态，实现无服务器端状态认证，将用户状态信息封装在Token中由客户端持有。
    *   **JWT 结构：** 由三部分组成，通过点分隔：
        *   **Header (头部)：** 包含Token类型（JWT）和加密算法（如HMAC SHA256）。
        *   **Payload (载荷)：** 存储用户的相关信息（如用户ID、角色、过期时间等）。
        *   **Signature (签名)：** 使用Header中指定的算法，结合Header、Payload和一个密钥进行加密生成，用于验证Token的完整性和真实性。
    *   **实现机制：** 用户登录成功后，认证中心生成JWT并返回给客户端 -> 客户端将JWT（通常是Bearer Token）存储在Cookie或LocalStorage中 -> 客户端每次请求时携带此JWT -> 网关或后端服务接收到请求后，使用预设的密钥对JWT进行验证和解析，直接获取用户信息，无需再查询后端存储。
    *   **优点：**
        *   彻底消除服务器端Session存储，极大地减轻了认证中心的存储和访问压力。
        *   天生支持分布式系统和集群部署，无状态认证中心可以任意扩展。
        *   避免了认证中心重启导致的用户状态丢失问题。
    *   **与 Cookie/Session/Redis 的关系：** JWT可以替代后端Session和Redis作为状态存储机制，但客户端的Cookie或LocalStorage仍然是存储和传输JWT的必要手段。Cookie的跨域问题可通过LocalStorage或统一网关转发解决。
    *   **安全性讨论：** 提及JWT存在一定的安全风险（如令牌泄露），但未详细展开，暗示需要额外考虑。

5.  **当前主流实践方案**
    *   目前生产环境中，最常用且推荐的SSO实现方案是 **Cookie/LocalStorage + JWT** 的组合。

---
<Mermaid_Diagram>
graph TD
    A["单点登录 (SSO)"] --> B("登录状态管理");

    subgraph "方案演进"
        B --> C("方案一: Cookie + Session");
        C -- "依赖" --> D("客户端 Cookie");
        C -- "流程" --> E("网关检查 Cookie (Session ID)");
        E -- "验证" --> F("认证中心 (AC)");
        F -- "存储" --> G("AC 内存 Session");
        F -- "登录成功" --> D;
        C --> H("缺点: '1. AC集群Session不同步'");
        C --> I("缺点: '2. AC重启Session丢失'");

        B --> J("方案二: Redis 存储 Session");
        J -- "改进" --> F;
        F -- "Session 存储" --> K("Redis");
        J --> L("优点: '解决集群同步与重启丢失'");
        J --> M("缺点: '增加外部存储依赖及压力'");

        B --> N("方案三: JWT (JSON Web Token)");
        N --> O("核心理念: '无服务器端状态'");
        O --> P("JWT 结构:");
        P --> P1("Header: '加密算法'");
        P --> P2("Payload: '用户信息'");
        P --> P3("Signature: '数据完整性校验'");
        N -- "颁发" --> Q("客户端存储 (Cookie/LocalStorage) ");
        Q -- "每次请求携带" --> E;
        E -- "验证" --> F;
        F -- "无需存储" --> N;
        N --> R("优点: '高扩展性, 减轻AC压力'");
        N --> S("优点: '无需后端存储用户状态'");
        N --> T("缺点: 'JWT安全性考虑'");
    end

    N --> U("当前主流方案: 'Cookie/LocalStorage + JWT'");
    U --> V("总结: '通过JWT实现无状态化认证，辅以Cookie或LocalStorage进行令牌传输，是分布式系统SSO的优选方案'");

    style A fill:#ADD8E6,stroke:#333,stroke-width:2px,color:#333;
    style B fill:#F0F8FF,stroke:#333,stroke-width:1px,color:#333;

    style C fill:#FFFFCC,stroke:#333,stroke-width:1px,color:#333;
    style D fill:#ADD8E6,stroke:#333,stroke-width:1px,color:#333;
    style E fill:#90EE90,stroke:#333,stroke-width:1px,color:#333;
    style F fill:#90EE90,stroke:#333,stroke-width:1px,color:#333;
    style G fill:#FFDAB9,stroke:#333,stroke-width:1px,color:#333;
    style H fill:#FFB6C1,stroke:#333,stroke-width:1px,color:#333;
    style I fill:#FFB6C1,stroke:#333,stroke-width:1px,color:#333;

    style J fill:#FFFFCC,stroke:#333,stroke-width:1px,color:#333;
    style K fill:#FFDAB9,stroke:#333,stroke-width:1px,color:#333;
    style L fill:#90EE90,stroke:#333,stroke-width:1px,color:#333;
    style M fill:#FFB6C1,stroke:#333,stroke-width:1px,color:#333;

    style N fill:#FFFFCC,stroke:#333,stroke-width:1px,color:#333;
    style O fill:#FFFACD,stroke:#333,stroke-width:1px,color:#333;
    style P fill:#DDA0DD,stroke:#333,stroke-width:1px,color:#333;
    style P1 fill:#FFDAB9,stroke:#333,stroke-width:1px,color:#333;
    style P2 fill:#FFDAB9,stroke:#333,stroke-width:1px,color:#333;
    style P3 fill:#FFDAB9,stroke:#333,stroke-width:1px,color:#333;
    style Q fill:#ADD8E6,stroke:#333,stroke-width:1px,color:#333;
    style R fill:#90EE90,stroke:#333,stroke-width:1px,color:#333;
    style S fill:#90EE90,stroke:#333,stroke-width:1px,color:#333;
    style T fill:#FFB6C1,stroke:#333,stroke-width:1px,color:#333;

    style U fill:#DDA0DD,stroke:#333,stroke-width:2px,color:#333;
    style V fill:#90EE90,stroke:#333,stroke-width:2px,color:#333;

    linkStyle 0 stroke:#666,stroke-width:1px;
    linkStyle 1 stroke:#666,stroke-width:1px;
    linkStyle 2 stroke:#666,stroke-width:1px;
    linkStyle 3 stroke:#666,stroke-width:1px;
    linkStyle 4 stroke:#666,stroke-width:1px;
    linkStyle 5 stroke:#666,stroke-width:1px;
    linkStyle 6 stroke:#666,stroke-width:1px;
    linkStyle 7 stroke:#666,stroke-width:1px;
    linkStyle 8 stroke:#666,stroke-width:1px;
    linkStyle 9 stroke:#666,stroke-width:1px;
    linkStyle 10 stroke:#666,stroke-width:1px;
    linkStyle 11 stroke:#666,stroke-width:1px;
    linkStyle 12 stroke:#666,stroke-width:1px;
    linkStyle 13 stroke:#666,stroke-width:1px;
    linkStyle 14 stroke:#666,stroke-width:1px;
    linkStyle 15 stroke:#666,stroke-width:1px;
    linkStyle 16 stroke:#666,stroke-width:1px;
    linkStyle 17 stroke:#666,stroke-width:1px;
    linkStyle 18 stroke:#666,stroke-width:1px;
    linkStyle 19 stroke:#666,stroke-width:1px;
    linkStyle 20 stroke:#666,stroke-width:1px;
    linkStyle 21 stroke:#666,stroke-width:1px;
    linkStyle 22 stroke:#666,stroke-width:1px;
    linkStyle 23 stroke:#666,stroke-width:1px;
    linkStyle 24 stroke:#666,stroke-width:1px;
    linkStyle 25 stroke:#666,stroke-width:1px;
</Mermaid_Diagram>

Content:
Hello 大家好 我是虚述给他介绍一下单点登录常见的实现方案中登录状态到底是保存在C 程单中或者Race 还是GWT他们的区别是什么那首先单点登录是为了实现分布系统单中我们登录了其中的一个词系统就可以正常去访问另外一个词系统了那实现单点登录最简单的就是扣起加C 程的方案整理流程是这样的当然用户去请求A或者B系统在分布系统单中通常会有一个网关进行统一的任任送权或者统一的划预处理那它会拿到请求单中C 程的C 程的ID然后携带C 程的ID去请求认真中心由认真中心去验证C 程的ID是否有效已经C 程是否已经过期如果网关没有拿到C 程的ID或者认真中心验真失败会重定向到登录那么单用户进行登录的请求会将用户秘密码发送给认真中心进行用户秘密码的验证如果验证成功认真中心会存入C 程然后将C 程的ID存入到客户端的C 程的Done此时就完成了用户状态的存储那下次用户再去请求A或B 系统同样的网关会去验证C 程去请求认真中心同样的会去验证C 程ID的有效性那么一旦验证功会返回用户星系给网关然后再去转发到A或B 系统所以说C 程来实现单点的Done也是一种非常简单的实现方案但是假如我们的认真中心它的访问压力变大我们给它进行极群这个时候每一个认真中心的结底他们的C 性息是不同路的这个时候就出现了问题当然有人会说可以通过手动同步C 性的方案是用的来保证认真中心极群的C 性移制性但是这种方案几位麻烦所以我们同样就会将登陆状态存入到Radis 单路这样一来有Radis 单路的存储用户的登陆状态并且也能减少认真中心3.5 点固定重启之后老致的C 性丢失问题但是它还有一种更好的方案可以完全不存储用户星息这样进一步减少存储和反问的压力我们只需要把C 性给它改成GWT 即可这样一来认真中心它不需要依赖任何的存储完全由GWT来保持用户的状态性息因为GWT它是由三段的加密自负组成第一段叫做Header 用来保存加密的算法那么第二段叫做Header 用来存储用户的性息第三段用来存储通过Head 单终指定的算法进行加密之后的Header 以及Header还有一个C 要最主要就是通过这个C 要来保证GWT的一个安全性那GWT它绝对的安全吗也不是关于GWT的一些安全问题呢我不在这里去说大家如果有兴趣可以点点赞视频到1000段呢给大家介绍GWT的一些风情问题那很多人说用GWT就可以带提到Pookie C 省以及Ridis那我告诉你C 省和Ridis 确实可以替代掉因为在后端我们完全可以不用沉煮用户的性息了因为用户的性息呢就在GWT当中当然是前端的Pookie我们是不能审约的因为假如你在前端不存储GWT 偷肯的话在每次请求的时候呢去携带GWT的偷肯所以Pookie它是必不可少的当然有人会说呢Pookie会出现化育的问题只能同意顶级预明那其实这个我觉得不是什么问题啊比如说你可以改成Locostos来精神过了前端呢同意的去请求广关有广关呢去绑划内部系统所以我们目前3.0的路实现方案用的最多的也就是Pookie加GWT的方式那我就给大家讲这里如果视频的内容关注可以给主持人1.3连我们下集见
