Timestamp: 2025-08-30T02:08:21.050728
Title: Misc - ğŸš€Rust vs Goæ€§èƒ½ç»ˆæå¯¹å†³ï¼ä»…ç”¨æ ‡å‡†åº“ï¼Œè°çš„é€Ÿåº¦æ›´å¿«ï¼Ÿâš¡ BV1QioCY4EPV
URL: https://b23.tv/Ravl5j4
Status: success
Duration: 3:56

Description:
**æ ¸å¿ƒè§‚ç‚¹:**
å°½ç®¡Rustä½¿ç”¨æ ‡å‡†åº“è¿›è¡ŒåŒæ­¥æ¨¡å‹ä¸‹çš„ç½‘ç»œæ“ä½œæ—¶è¡¨ç°ä¸åŠGoï¼Œä½†å…¶çœŸæ­£çš„é«˜æ€§èƒ½æ½œåŠ›å°†åœ¨æœªæ¥è§†é¢‘ä¸­é€šè¿‡å¼‚æ­¥è¿è¡Œæ—¶ï¼ˆå¦‚Tokioï¼‰å¾—åˆ°å……åˆ†å±•ç°ã€‚

**æ€»ä½“æ¡†æ¶:**
ç¼–ç¨‹è¯­è¨€æ€§èƒ½åŸºå‡†æµ‹è¯•ï¼ˆä¸“æ³¨äºWebåº”ç”¨çš„æ ‡å‡†åº“èƒ½åŠ›ä»¥åŠåŒæ­¥ä¸å¼‚æ­¥æ¨¡å‹çš„å½±å“ï¼‰ã€‚

**æ‘˜è¦:**

*   **1. å¼•è¨€ä¸ç›®æ ‡**
    *   è§†é¢‘æ—¨åœ¨æ¯”è¾ƒGoå’ŒRustç¼–ç¨‹è¯­è¨€åœ¨ä½¿ç”¨æ ‡å‡†åº“æ„å»ºRESTåº”ç”¨æ—¶çš„æ€§èƒ½ã€‚
    *   å¼ºè°ƒGoçš„æ ‡å‡†åº“æ˜“äºåˆ›å»ºèƒ½å¤„ç†æ¯ç§’æ•°åƒæ¬¡è¯·æ±‚çš„ç”Ÿäº§çº§RESTåº”ç”¨ã€‚
    *   é¢„å‘Šä¸‹ä¸€è§†é¢‘å°†æ·±å…¥æ¢è®¨Rustçš„Tokioå¼‚æ­¥è¿è¡Œæ—¶ï¼Œå®ƒè¢«è§†ä¸ºå¤§å¤šæ•°é«˜æ€§èƒ½æ¡†æ¶çš„åŸºç¡€ã€‚

*   **2. æµ‹è¯•è®¾ç½®**
    *   **2.1. åŸºå‡†æµ‹è¯•å·¥å…·:** é‡‡ç”¨AdBSè¿›è¡Œæ‰€æœ‰æ€§èƒ½æµ‹è¯•ã€‚
    *   **2.2. éƒ¨ç½²ç¯å¢ƒ:** æ¯ä¸ªè¢«æµ‹åº”ç”¨ç¨‹åºéƒ¨ç½²åœ¨ç‹¬ç«‹çš„M7A Large EC2å®ä¾‹çš„è™šæ‹Ÿæœºä¸Šï¼Œå¹¶é€šè¿‡SystemDæœåŠ¡æ–‡ä»¶ç›´æ¥è¿è¡Œã€‚
    *   **2.3. è¢«æµ‹åº”ç”¨ç‰ˆæœ¬:**
        *   ä¸€ä¸ªGoåº”ç”¨ç¨‹åºã€‚
        *   ä¸¤ä¸ªRustç‰ˆæœ¬ï¼šä¸€ä¸ªå•çº¿ç¨‹ç‰ˆæœ¬å’Œä¸€ä¸ªä½¿ç”¨10çº¿ç¨‹æ± çš„å¤šçº¿ç¨‹ç‰ˆæœ¬ã€‚
    *   **2.4. è¡¡é‡æŒ‡æ ‡ (ä»å®¢æˆ·ç«¯ä¾§æµ‹é‡):**
        *   å»¶è¿Ÿ (P90ç™¾åˆ†ä½)
        *   ååé‡ (æ¯ç§’è¯·æ±‚æ•° - RPS)
        *   åº”ç”¨ç¨‹åºçš„CPUä½¿ç”¨ç‡
        *   æ•´ä¸ªè™šæ‹Ÿæœºçš„å†…å­˜ä½¿ç”¨ç‡

*   **3. æµ‹è¯•ç»“æœ**
    *   **3.1. Rust (æ ‡å‡†åº“ï¼ŒåŒæ­¥æ¨¡å‹):**
        *   å•çº¿ç¨‹Ruståº”ç”¨ç¨‹åºä»…èƒ½å¤„ç†çº¦1500 RPSã€‚
        *   å¤šçº¿ç¨‹Rustç‰ˆæœ¬ï¼ˆ10çº¿ç¨‹ï¼‰ç•¥æœ‰æå‡ï¼Œè¾¾åˆ°çº¦4000 RPSã€‚
    *   **3.2. Go (æ ‡å‡†åº“):**
        *   è§†é¢‘æš—ç¤ºGoçš„æ€§èƒ½è¿œè¶…Rustçš„åŒæ­¥ç‰ˆæœ¬ï¼Œå¹¶è¡¨ç¤ºå°†é€šè¿‡è¿›ä¸€æ­¥æµ‹è¯•ç¡®è®¤å…¶æœ€å¤§ååé‡ã€‚

*   **4. æ€§èƒ½åˆ†æä¸è§£é‡Š**
    *   **4.1. æ ¹æœ¬åŸå› :** è§£é‡ŠRuståŒæ­¥æ¨¡å‹åœ¨éœ€è¦ç­‰å¾…ç½‘ç»œæ“ä½œæ—¶è¡¨ç°ä¸ä½³ã€‚å³ä½¿å¼•å…¥å¤šçº¿ç¨‹ï¼Œç”±äºçº¿ç¨‹ä»éœ€åŒæ­¥ç­‰å¾…ç½‘ç»œI/Oå®Œæˆï¼Œæ€§èƒ½æå‡ä¹Ÿæœ‰é™ã€‚
    *   **4.2. CPUä½¿ç”¨ç‡:** ç›‘æµ‹åˆ°Ruståº”ç”¨ç¨‹åºçš„CPUä½¿ç”¨ç‡è¾ƒä½ï¼Œè¿™è¿›ä¸€æ­¥è¯å®äº†å…¶å¤§éƒ¨åˆ†æ—¶é—´èŠ±åœ¨ç­‰å¾…ç½‘ç»œæ“ä½œä¸Šã€‚
    *   **4.3. å†…å­˜ä½¿ç”¨ç‡:** åœ¨æœåŠ¡å™¨å¤„ç†è¿‡è½½è¯·æ±‚æ—¶ï¼Œè§‚æµ‹åˆ°å†…å­˜ä½¿ç”¨ç‡å‡ºç°é«˜å³°ã€‚
    *   **4.4. å±•æœ›:** ä½œè€…å¼ºè°ƒæ­¤æ¬¡Rustçš„æ€§èƒ½ç»“æœå¹¶éå…¶æé™ï¼Œå¹¶é¢„å‘Šåœ¨ä¸‹ä¸€è§†é¢‘ä¸­ï¼Œé€šè¿‡é›†æˆTokioå¼‚æ­¥è¿è¡Œæ—¶ï¼ŒRustçš„æ€§èƒ½å°†å±•ç°å‡ºå·¨å¤§é£è·ƒã€‚

*   **5. ç»“è®ºä¸æœªæ¥å±•æœ›**
    *   æœ¬è§†é¢‘çš„åŸºå‡†æµ‹è¯•ç»“æœè¡¨æ˜ï¼ŒGoçš„æ ‡å‡†åº“åœ¨å¤„ç†ç½‘ç»œå¯†é›†å‹RESTåº”ç”¨æ–¹é¢ï¼Œç›¸å¯¹äºRustçš„åŒæ­¥æ ‡å‡†åº“å®ç°ï¼Œå±•ç°å‡ºæ›´å¥½çš„æ€§èƒ½ã€‚
    *   é¼“åŠ±è§‚ä¼—ä¸è¦å› Ruståœ¨æ­¤æ¬¡åŒæ­¥æµ‹è¯•ä¸­çš„è¡¨ç°è€Œå¯¹å…¶å¤±æœ›ï¼Œå¹¶æœŸå¾…å…¶åœ¨å¼‚æ­¥è¿è¡Œæ—¶ï¼ˆå¦‚Tokioï¼‰ä¸‹çš„çœŸæ­£å®åŠ›ã€‚
    *   æ­¤å¤–ï¼Œè§†é¢‘ä½œè€…è¿˜æåŠäº†å…¶ä»–æœ‰è¶£çš„åŸºå‡†æµ‹è¯•ï¼Œå¦‚Postgreså¯¹æ¯”MySQLï¼ŒRediså¯¹æ¯”Memcacheç­‰ã€‚

<Mermaid_Diagram>
graph LR
    subgraph "è§†é¢‘ä¸»é¢˜ä¸ç›®æ ‡"
        A["è§†é¢‘ä¸»é¢˜: Go vs Rust æ ‡å‡†åº“æ€§èƒ½"]:::mainTopic
        B("æµ‹è¯•ç›®çš„: RESTåº”ç”¨æ€§èƒ½æ¯”è¾ƒ"):::purpose
        A --> B
    end

    subgraph "æµ‹è¯•è®¾ç½®ä¸ç¯å¢ƒ"
        C("æµ‹è¯•å·¥å…·: AdBS"):::setting
        D("éƒ¨ç½²ç¯å¢ƒ: M7A Large EC2 VM / SystemD"):::setting
        E("è¢«æµ‹åº”ç”¨"):::setting
        E1("Go (æ ‡å‡†åº“)"):::languageGo
        E2("Rust (æ ‡å‡†åº“)"):::languageRust
        E2a("Rust å•çº¿ç¨‹"):::rustVariant
        E2b("Rust 10çº¿ç¨‹"):::rustVariant
        E --> E1
        E --> E2
        E2 --> E2a
        E2 --> E2b
        B --> C
        C --> D
        B --> E
    end

    subgraph "å…³é”®æ€§èƒ½æŒ‡æ ‡"
        F("æ€§èƒ½æŒ‡æ ‡"):::metrics
        F1("æ¯ç§’è¯·æ±‚æ•° (RPS)"):::metrics
        F2("P90å»¶è¿Ÿ"):::metrics
        F3("CPUä½¿ç”¨ç‡"):::metrics
        F4("å†…å­˜ä½¿ç”¨ç‡"):::metrics
        F --> F1
        F --> F2
        F --> F3
        F --> F4
        E --> F
    end

    subgraph "æµ‹è¯•ç»“æœä¸åˆ†æ"
        G("æµ‹è¯•ç»“æœ"):::resultBox
        G1("Rust å•çº¿ç¨‹: ~1500 RPS"):::perfLow
        G2("Rust 10çº¿ç¨‹: ~4000 RPS"):::perfLow
        G3("Go: æ€§èƒ½é¢„æœŸæ›´ä¼˜"):::perfHigh
        H("æ€§èƒ½ç“¶é¢ˆ: RuståŒæ­¥æ¨¡å‹"):::bottleneck
        I("åŸå› : å¤§é‡ç­‰å¾…ç½‘ç»œæ“ä½œ"):::reason
        J("CPUä½¿ç”¨ç‡ä½: ç­‰å¾…æ—¶é—´é•¿"):::reason
        E1 --> G3
        E2a --> G1
        E2b --> G2
        G1 --> H
        G2 --> H
        H --> I
        I --> J
        H --> K("ç»“è®º: åŒæ­¥æ¨¡å‹ä¸é€‚åˆç½‘ç»œIOå¯†é›†å‹åº”ç”¨"):::conclusion
    end

    subgraph "æœªæ¥å±•æœ›ä¸é¢å¤–å†…å®¹"
        L("æœªæ¥è§†é¢‘: Rust + Tokioå¼‚æ­¥è¿è¡Œæ—¶"):::future
        M("é¢„æœŸ: å¼‚æ­¥æ¨¡å‹å°†æ˜¾è‘—æå‡Rustæ€§èƒ½"):::futureBenefit
        N("æ ¸å¿ƒè§‚ç‚¹: å¼‚æ­¥æ¨¡å‹å¯¹é«˜æ€§èƒ½è‡³å…³é‡è¦"):::corePoint
        O("å…¶ä»–åŸºå‡†æµ‹è¯• (Postgres vs MySQL, Redis vs Memcacheç­‰)"):::other
        K --> L
        L --> M
        M --> N
        A --> N
        A --> O
    end

    style A fill:#FFD700,stroke:#333,stroke-width:2px,color:#333;
    style B fill:#F0E68C,stroke:#333,stroke-width:1px,color:#333;
    style C fill:#D3D3D3,stroke:#333,stroke-width:1px,color:#333;
    style D fill:#D3D3D3,stroke:#333,stroke-width:1px,color:#333;
    style E fill:#D3D3D3,stroke:#333,stroke-width:1px,color:#333;
    style E1 fill:#90EE90,stroke:#333,stroke-width:1px,color:#333;
    style E2 fill:#ADD8E6,stroke:#333,stroke-width:1px,color:#333;
    style E2a fill:#ADD8E6,stroke:#333,stroke-width:1px,color:#333;
    style E2b fill:#ADD8E6,stroke:#333,stroke-width:1px,color:#333;
    style F fill:#FFFFCC,stroke:#333,stroke-width:1px,color:#333;
    style F1 fill:#FFFFCC,stroke:#333,stroke-width:1px,color:#333;
    style F2 fill:#FFFFCC,stroke:#333,stroke-width:1px,color:#333;
    style F3 fill:#FFFFCC,stroke:#333,stroke-width:1px,color:#333;
    style F4 fill:#FFFFCC,stroke:#333,stroke-width:1px,color:#333;
    style G fill:#E6E6FA,stroke:#333,stroke-width:1px,color:#333;
    style G1 fill:#FFB6C1,stroke:#333,stroke-width:1px,color:#333;
    style G2 fill:#FFB6C1,stroke:#333,stroke-width:1px,color:#333;
    style G3 fill:#A2D9CE,stroke:#333,stroke-width:1px,color:#333;
    style H fill:#FF6347,stroke:#333,stroke-width:2px,color:#333;
    style I fill:#FF8C00,stroke:#333,stroke-width:1px,color:#333;
    style J fill:#FF8C00,stroke:#333,stroke-width:1px,color:#333;
    style K fill:#FFD700,stroke:#333,stroke-width:2px,color:#333;
    style L fill:#87CEEB,stroke:#333,stroke-width:1px,color:#333;
    style M fill:#87CEEB,stroke:#333,stroke-width:1px,color:#333;
    style N fill:#00BFFF,stroke:#333,stroke-width:2px,color:#333;
    style O fill:#D3D3D3,stroke:#333,stroke-width:1px,color:#333;
</Mermaid_Diagram>

Content:
 In this video, we'll compare Go with Rust programming language only using standard library. In the next video, I'll cover Tokyo runtime, which is a synchronous runtime that Rust does not officially support it, and it's actually the foundation for most high-performance frameworks. It's actually very easy to create a production-ready Go REST application using only standard library that would handle thousands of requests per second. I don't know about you, but I learned Rust by reading the Rust book, and in the last chapter, they guide you how to build a single threaded and then multi-threaded web server. So I took it from there for this benchmark. I use AdBS to run all my benchmarks, and for this video, I used M7A Large ECTO Instance for each application and deployed them on VMs directly using SystemD Service files. Alright, let's go ahead and run the test. It took around two hours, and I compressed it while editing to just a few minutes. You would see a single Go application and two versions of Rust, with a single thread and a thread pull of 10 threads. Here we measure latency using P90 percentile from the client side. Then we have throughput, which are requests per second. We also measure CPU usage of each application as well as the overall memory usage of the entire VM. As you can see, a single threaded Rust application could only handle 1500 requests per second. The multi-threaded version was a little bit better and reached 4,000 requests per second. To find the maximum for Go, we need to run this test for one more minute, and after, I'll open each graph for the entire test duration, one by one. First, we have requests per second. And it's not to say that Rust is slow, it's just that synchronous model does not work well in applications if you need to wait for network operations. Even if you have multiple threads, you'll see a huge difference in the next video with the Tokyo runtime. Next, we have latency. CPU usage. And once again, you can see low CPU usage because Rust must wait for network operations to complete and waits a lot of time. And finally, memory usage. We have some kind of spike here in memory usage when the server was overloaded with requests. So don't be upset about Rust for performance and wait for the next video. I have other benchmarks with Postgres versus MySQL, radius versus memcache, and other benchmarks that you might find interesting.
