Timestamp: 2025-08-30T02:25:49.569479
Title: Rust 投入生产环境一年的经历 BV1mysDeGEph
URL: https://b23.tv/sygsRRM
Status: success
Duration: 14:07

Description:
**核心观点：**
尽管Rust的编译时间是一个显著的痛点且其生态系统在某些特定领域尚待完善，但其强大的类型安全、编译时错误检查和出色的运行时稳定性使其成为构建高质量、可靠大型生产级软件的卓越选择。

**Overarching Framework (贯穿内容的主线框架):**
Rust在生产环境中的实践经验：优点、挑战与权衡。

---

**详细内容总结：**

**一、 引言：Rust在生产环境一年的回顾**
*   **项目背景：** 作者的副业项目，涉及支付系统切换、作业处理队列和小型会计系统，全部用Rust实现。
*   **里程碑：** 产生了他提交的最大合并请求（260个文件），并迎来了Rust在生产环境运行的一周年。

**二、 Rust的显著优势**
1.  **高可靠性与稳定性：**
    *   **“编译通过即运行”：** Rust的类型安全和编译特性能够提前捕获大量错误，确保代码在生产环境中极少出现运行时问题（如类型不匹配、访问不存在字段、空指针等）。
    *   **SQLx的类型安全：** `SQLx`这一Rust的SQL封装库能在编译时检查SQL查询的正确性，有效杜绝生产环境的SQL错误，显著降低对复杂ORM或大量SQL单元测试的依赖。
    *   **类型安全的模板引擎：** 避免了因模板变量引用错误导致的运行时故障。
    *   **极少进程崩溃：** 与Node.js等语言相比，Rust进程异常稳定。其强制性的错误处理机制（如`Result`、`Match`和`?`操作符）确保了健壮性，仅在初始化阶段（如配置加载失败）会谨慎使用`Unwrap`导致进程崩溃。

2.  **优秀的工具链与生态：**
    *   **Cargo：** 稳定的项目管理工具，尤其在Workspace模式下表现出色。
    *   **Clippy：** 提供代码风格检查和潜在错误提示，减少样板代码，降低心智负担。

**三、 Rust面临的挑战与痛点**
1.  **编译时间长：**
    *   **问题描述：** 随着项目规模扩大和第三方依赖（特别是宏密集型库如`SQLx`、`Axum`、`Tower`）的增加，编译时间显著增长（从6分钟增至20分钟）。
    *   **影响：** 严重影响了快速迭代的开发模式，打破了动态语言或热重载环境下的即时反馈循环。
    *   **优化：** 虽有缓存依赖、多线程编译等优化策略，但需要额外的时间投入和专业配置。

2.  **生态系统成熟度差异（特定领域）：**
    *   **第三方API集成：** 缺乏类型安全的第三方API接口封装（即使有OpenAPI/Swagger规范，也难以保证严格遵守或自动生成高质量客户端）。
    *   **Web前端开发体验：** Rust在前端开发方面体验不佳，每次修改都需要重新编译，不适合快速迭代。作者仍倾向使用TypeScript/JavaScript进行前端开发。
    *   **文档与示例：** 核心库和流行库文档质量高，但在处理非主流或边缘案例时，常需直接阅读源码才能解决问题。

3.  **开发模式与心智负担：**
    *   **“重型编译-测试”循环：** Rust更倾向于编写大量代码后进行编译和测试，而非动态语言那种小步快跑、即时反馈的开发模式。

**四、 总结与展望**
*   **总体评价：** 作者对一年前选择Rust感到非常高兴。
*   **价值体现：** Rust不仅帮助他获得了满意的工作，还使其能够构建出更优质、更可靠的软件。
*   **未来计划：** 期待在未来一年继续使用Rust进行开发。

---

<Mermaid_Diagram>
graph LR
    subgraph "Rust生产环境实践"
        A["Rust生产环境一周年经验分享"]
    end

    subgraph "Rust的显著优势"
        B["编译通过即运行: 高可靠性与稳定性"]
        C["极致类型安全"]
        D["SQLx: 类型安全SQL封装"]
        E["明确的错误处理机制"]
        F["强大的工具链: Cargo & Clippy"]
    end

    subgraph "Rust面临的挑战"
        G["编译时间长: 开发反馈慢"]
        H["生态系统成熟度差异"]
        I["第三方API集成难度"]
        J["Web前端开发体验待提升"]
        K["文档/示例在边缘场景不足"]
        L["重型编译-测试开发模式"]
    end

    subgraph "总结与价值"
        M["对选择Rust感到满意"]
        N["提升软件质量"]
        O["助力职业发展"]
    end

    A --> B
    A --> G

    B --> C
    B --> E
    B --> F

    C --> D
    C --> "类型安全的模板引擎"

    G --> L
    H --> I
    H --> J
    H --> K

    A -- "最终带来" --> M
    M --> N
    M --> O

    style A fill:#F9F7D8,stroke:#333,stroke-width:2px,color:#333;
    style B fill:#D4EDDA,stroke:#28A745,stroke-width:1.5px,color:#333;
    style C fill:#E6F3EB,stroke:#28A745,stroke-width:1px,color:#333;
    style D fill:#E6F3EB,stroke:#28A745,stroke-width:1px,color:#333;
    style E fill:#E6F3EB,stroke:#28A745,stroke-width:1px,color:#333;
    style F fill:#E6F3EB,stroke:#28A745,stroke-width:1px,color:#333;
    style "类型安全的模板引擎" fill:#E6F3EB,stroke:#28A745,stroke-width:1px,color:#333;

    style G fill:#F8D7DA,stroke:#DC3545,stroke-width:1.5px,color:#333;
    style H fill:#FAE5E7,stroke:#DC3545,stroke-width:1px,color:#333;
    style I fill:#FAE5E7,stroke:#DC3545,stroke-width:1px,color:#333;
    style J fill:#FAE5E7,stroke:#DC3545,stroke-width:1px,color:#333;
    style K fill:#FAE5E7,stroke:#DC3545,stroke-width:1px,color:#333;
    style L fill:#FAE5E7,stroke:#DC3545,stroke-width:1px,color:#333;

    style M fill:#ADD8E6,stroke:#007BFF,stroke-width:1.5px,color:#333;
    style N fill:#E0F0FA,stroke:#007BFF,stroke-width:1px,color:#333;
    style O fill:#E0F0FA,stroke:#007BFF,stroke-width:1px,color:#333;

    linkStyle 0 stroke:#000,stroke-width:1.5px;
    linkStyle 1 stroke:#000,stroke-width:1.5px;
    linkStyle 2 stroke:#28A745,stroke-width:1px;
    linkStyle 3 stroke:#28A745,stroke-width:1px;
    linkStyle 4 stroke:#28A745,stroke-width:1px;
    linkStyle 5 stroke:#28A745,stroke-width:1px;
    linkStyle 6 stroke:#28A745,stroke-width:1px;
    linkStyle 7 stroke:#DC3545,stroke-width:1px;
    linkStyle 8 stroke:#DC3545,stroke-width:1px;
    linkStyle 9 stroke:#DC3545,stroke-width:1px;
    linkStyle 10 stroke:#DC3545,stroke-width:1px;
    linkStyle 11 stroke:#DC3545,stroke-width:1px;
    linkStyle 12 stroke:#007BFF,stroke-width:1.5px;
    linkStyle 13 stroke:#007BFF,stroke-width:1px;
    linkStyle 14 stroke:#007BFF,stroke-width:1px;
</Mermaid_Diagram>

Content:
我们来看一篇比较有意思的文章就是有一个作者是叫Dimetry Cool Drive有点像是看这个名字有点像是俄罗斯或者周边的一个国家的人它的名字叫Rustle投入生产环境一年的经历推文文章是在9月22号写的时间非常的近这是它的原文念节有请你可以看到原文我们来看它的详细内容过去一个月我几乎把所有的困惦时间都花在了我的副眼加速的facts上面一切从把支付系统从Namens Squeeze 前一段stripe上面开始为什么呢?他说订阅他的伯克可以看到他之前详细解释为什么的原因啊但中路每次重够或者重写一样项目远比我预期的要复杂的多一个简单的支付付提供上切换结果要求我家10个月上面实现一个作业处理对列还得做一个小型的快几系统但这一切都是用Rustle的实现的这就导致了我说提交优势以来最大的一次合并请求它的合并请求很大260个圈就算了然后就是合并请求比较大这个合并请求正好赶上我启动加速的facts大于一周年于是通常我在主业中也是用Rustle的开发商品因此我决定告诉一下在生产行程中是用Rustle的感受第一小把讲的是编译成功运行无邮这一边你能编译通过就能跑我之前在撰写Rustle外部医院出体验室医院的出体验室提到过这一点现在我想再次强调这一点就说你编译通过肯定会能跑肯定会能跑了通常我不会在每次修改后都运行但除非是进行发出的cs较整这个有的意思点就是它说讲的是Rustle在外部医院上面的一个体验就是生产行程它跟游戏之间还是有不同的点我们来看大多数情况下我会完成一个交达的充够然后交达的充够或者困难实现的话然后再一起运行测试而且在Rustle的当中如果带码不能够编译通过的话你就没办法运行它这跟gs不一样如果带码有错你就必须修复它两个这两个跑于是我就陷入了一个长时间的充够当中这期间带码重位处于可以编一条状态直到所有事情都完成的最后一颗但所有系统组织都配置好并发出第一个本地的请求的时候我本来很担心但我今天是一切正产运行虽然我知道自己是一个不错的开发者但我不会天真的认为自己能写出完全没有错误的代码除了少量的动态代码问题比如错误的训练化、发泄化化格式代码几乎是完美运行的这种成功的第一个原因是是什么呢是Rustle的内型安全和编译特性就让编细不会让你错误的把一个i64负质给UID也不允许你像在界时中那样访问不存在了什么结构理智团不会有这样的尽管有些人生存自己存在没有给了过无法访问威丁一的附属性之类的软太密措当我和同事的经历并不一样我们在主业中使用Rustle的原因之一是什么了原本使用动态、语言、编辑的后段变得难以为后了就是太大的难为后了对于一个小英雄你可能可以在这个脑海中记住一下他的三下稳但是随着系统变大记住受的细节就变得不可能了我和记得以前做PHP的时候有时候我来知道书主在哪里书主里面有哪些剑有哪些剑就不得不把书主内容直接打印出来因为有些剑是Slayer模式的有些剑是Northome模式这种剑的面面方式模式格式不一样格式不一样第二层或者说是第一层的延伸也就是Rustle对内型安全的指责这种指责就出生了像Squeal差点的根据这个很有意思它加少了Squeal差这个根据一个编细的内型安全的Squeal分装库它会在真正的数据库上运行你的差距如果差距发错或者是你尝试将一个I-SAR插入到一个文本列的这种里面而且没有显示转弯的话带满混弊办法通过编议我以前对Squeal存满的位置因为它是每个应用的核心部分出错就很容易在生产房间的如果拼错了差距或者搞错了差数你就麻烦了很多人会为了Squeal的差距编写这个单元测试一个人试用这个ROM或者是根据数据库模式的生存代码但是有了Squeal差我就再也不用担心这个问题了我可以充分享受Squeal的强大功能不需要依赖高度出现了ROM或者进行数据库模式的代码生存当然这也有一些缺点或者后面的不够能不能提到这一点另一个属于这一类的这个根据是内型安全的模板引擎比如说SKama或者Mod虽然我在项目都没有运动它们但他们确实消除了代码都能另一种不缺的性有时候我说到I-HELLOUZNAME开头的电动预件的时候会怎么不出效这种错误如果来自这种无名的就是很不聪明的复材好如果来自这种引行就比较尴尬了而有了内型安全的编议时候这个模板这种错误就不会存在就是这个能说没有一些引行它这个系统就不是静态写的所以会可能存在这种情况我唯一环境的身体型安全的第三方API接口就是就是若是它没有这个地方它是它那边环境的地方就是算你可以从Open API swag规范生存的可我段当然要数字于第三方API的地方上即便它们提供了规范也不一定以为它会争议成这个规范或者是保证他们的API不会争大对于自己的话我认为还没有缺缺发就是安全的第他API这次比较难的还有一个就是当它允许的时候说非常稳定的非常稳定的我从来没有遇到过RUSH的进程崩溃的情况倒数遇到过Node进程崩溃就是GS上面Node进程可能会崩溃除非你在弹码中到处使用Unwrap就是Unwrap就是基本上因为如果结果是错误就崩溃基本上是这样的否则你有进程可能运运不过崩溃我的弹码中确实有一些Unwrap主要是它出自化的时候所以说如果配置文件确实或者环境编辆没有定义除了让进程崩溃外我也没有什么别的选择这个其实在错误处理上面错误模型上面就叫立即错误对吧 放弃形错必须把它扔掉扔掉后面没法跑但中厅来说的话RUSH要求你显示的处理错误任何反回RUSH三分Around的弹码都会去你通过问号处处处向上传理错误或者是使用Match举进处理在大多数情况下做得非常合理而在某些情况下是有点烦比如说当你知道I-64专会I-S-R没问题的时候你还得运TryFrom它反回一个RUSH即便在这些让人比较烦就往下我通常也不会去用RAP而是记录一个告警编反回一个合理的默认识编程中的触摆位置因此至少我的存用可以继续运行编记录一下我可能犯错的地方根据非常强大就是说RUSH在根据上面加上Factor不仅仍是用RUSH写的它和内部系统使用Type-Squip和其他的伎丝框架而且我每次创建一个新的Type-Squip下面说总会有些东西会改变要么是某个根据的配置文件变了要么是Type-Squip的新的样板文件USP2是后来不再流行的大家用Fastify了接着USP2又变得流行了又跨又变倒过来TESNO的被淘汰改变TES差某个模块只支持USM另一个模块又是CGSType-Squip总是在变化你变些代码啊另一代码再存的季 S和Type-Squip总使用这个 Workspace的方式都在变但是RUSH写不太好只要卡在那里就能够生成一个新项目想要 Workspace没问题完美运行念头根据Clippy已经有完美的Clippy来给你搞定了RUSH写的几乎没有这种样板代码也减少了单精神皮牢对吧并一时间仍然是痛点并一时间仍然是坑RUSH的确点好我用的就是并一时间特别是当你使用一辆红的困局这个我们在之前的视频中看的过对于解红它是非常好时间的红展开是非常好时间的比如说Squip差或者是Mode无论是KFB、SB和编辑都会开始吃力所以说项目的扩大了我记得了越来越多的第三方依赖尽管我试图通过讲多个报道公共依赖发入根部路的卡钩塔蒙文件中但积极选择数据的依赖困难优化这个便宜当我仍然在便宜时间上非常地增长我提到过最初在CLC的一种编议需要大概6分钟而现在已经需要20分钟了根据网上的各种伯克确实可以通过这个缓存依赖和使用多节量的刀和容器优化便宜时间但这需要非常精准的传统我现在没时间做这个事需要更多的专注与业务层面不过以后我会处理的在苹果的M2上面的本地编议还算可以接受特别是侦量便宜一下但代价是占用了大量的重重分件我是不是都愿意开个个订请你调几十级约的缓存而即使有了这个侦量便宜它依然远没有借还是是一种即使热重载快所以回到最初的观点这个后面讲的就很有意思了就那种改一下代码利益测试的开发情况被打破了就不是这种方式了你没有办法像这个戒业的时候或者是Type-Squeep的那样就是或者即使非常即使的反馈这也是加上发酵的一些内部和外部工具一样使用Type-Squeep的冰淇淋Rast更像是在引导你你写大量的代码冰淇淋然后浅差你写很多然后再去冰淇淋对啊而不像是像路的Joucequeep的那样一旦好像改代码切换的对象器测一下看一下我大多数情况下可以接受这个纠称因为我得到了那些安全的好处我相信CI-PAP-NINE可以解决这个问题但是我需要更多的时间来优化它工具生态还没有完全完善就是它认为的生产还能有一个问题有些领域Rast的表现得非常好比如说从后段像Xium这样的宽佳提供了购件APP夫妻所需的大部分逐渐并且大多数流行的外白PAP都有这个Rast的扣段虽然这些扣段通常不是有这个购件APP的工作维护的但至少我们可以使用它们但是完成了大多数的一直拼Buffer-Buffer-Rast因此你需要自己摸索怎么集成各种APP在Rast的开放过程中这些有反复出现的问题至少在外部开发方面我不能够评论其他类型的应用我经常会查看原谈码或者是给他们找一下我遇到的问题类似的讨论大模型就很多的这些大模型很少能够提供合适的觉法因为大模型这些都能够办不上马因为大多数包都是一种很小种类的一个可能它的训练书记里没这个东西所以Rast的事去对包的包的文档和势力非常的重视非常好但最终你会遇到一些边缘的这种不是那种就是大众的就是很小种边缘的那种案例它既没有文档也没有例子你只能通过运动原谈码的解决问题那有些运动的存用并不适合Rast尤其是对于那些人来这些快速运行开发其实像这个游戏开发就是那种模式了对吧我仍然更喜欢TX和STRA或者是SWAMG来写钱段Rast这方面的开发体验并不好每次这个编辆编划后都需要存心编辆就使得钱段开发的快速跌代就编得比较慢最后我很高兴一年前选择了Rast它不仅搬住我活得了我非常喜欢的主业的这种工作主要业务的这种工作还让我能够购捐更好的软件我期待就在接下来的一年继续使用Rast的开发所以这边文章也很有意思基本上讲到的问题跟之前的一些人的感受是比较齐合的大家的感受应该是类似的这就是在Wap开发上面它有很多的优点尤其是在比较大一点的这种项目上面它是很有优点的就是它会对你的用为起到一个非常好的改变之前的试评人们也有讲到过这个问题但这边文章独角也有意思
