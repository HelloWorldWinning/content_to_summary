Timestamp: 2025-08-21T00:17:05.665680
Title: 各類程式語言用什麼語言寫的 X8-dY0SJS18
URL: https://youtube.com/watch?v=X8-dY0SJS18&si=bv172iLk0KxVoyYK
Status: success
Duration: 10:02

Description:
**一、引言：编程语言实现分析的核心视角**
*   **目的：** 通过深入分析各种编程语言的实现源码，而非主观猜测或依赖AI，揭示其真实的构建方式。
*   **核心冲突：** 理论上所有编程语言都能“自举”（用自身实现自身），但工程效率、性能考量及历史遗留问题，使得实际实现往往是多语言混合的结果。

**二、关键概念解析**
*   **自举 (Bootstrapping)：** 一种编程语言用自身来编写其编译器或核心运行时环境的过程。
*   **编译器 (Compiler)：** 将编写的代码（源文件）转换成可执行程序的工具，负责语言的语法解析和代码生成。同一种语言可能有多种编译器。
*   **虚拟机 (Virtual Machine, VM) / 运行时 (Runtime)：** 程序执行时所需依赖的环境，如Java虚拟机，提供运行时库支持和垃圾回收机制。
*   **底层虚拟机 (Low-Level VM, LLVM)：** 一个在机器码之上定义的中间代码层（如A.O.L.VM），不同于Java字节码，不负责垃圾回收，直接对应机器码，主要用于跨平台优化和代码优化。
*   **标准库 (Standard Library)：** 编程语言自身提供的基础函数、类和模块，通常由该语言自身实现。

**三、主流编程语言实现细致分析**
*   **C/C++：**
    *   **编译器实现：** 主流编译器如GCC和LLVM，其核心代码已大量转向C++实现，C语言主要保留在库函数和部分旧代码中。
    *   **驱动因素：** C++的模板、面向对象特性极大地提升了编译器的可维护性和开发效率。
*   **Java：**
    *   **实现构成：** Java标准库和部分语法解析器由Java自身实现。
    *   **虚拟机 (JVM)：** 其核心部分，特别是垃圾回收机制，主要由C++实现。
    *   **结论：** Java是由自身与C++共同实现的。
*   **Python (CPython)：**
    *   **实现构成：** 标准库由Python自身实现，但核心的语法解析部分基于C语言。
    *   **外部依赖：** CPython核心未采用C++，然而，大量普及的Python扩展库，特别是AI/科学

Content:
各种编程语用什么语言写的C用习家家C家也是习家家仓捡的用的习家家加尾虚拟继续习家家然后编异器用的加尾Python用的CRust用了Rust但还需要习家家够用的是够所有编程语言理论上都可以自取就是用自己实现自己但工程和效率的考虑很多选择的C家家上面的回答是有时空背景的一式当前二式主流下面我们上证据直接分析各种语言的实现园码不要评主观想象问AI也不靠我们自己研究语言的实现代码视频脚长主要是要分析各个语言的实现园码记得点赞收藏分析之前我们先确定几个概念字局编异器虚拟继底层虚拟继标准库然后再分析各个语言字局我们前面讲就像仓捡他刚发布了第一个证实板所以不太可能一上来就用自己实现自己后面应该会做到字局这就是卸用机还是卸用淡的问题就像 cj 第一个版本肯定不是 cj 加上Ross 的第一个版本也不是Ross的所以这是一个历史问题编弃就是把你卸的代码转成运行用的程序所以我们讲一个语言用什么实现其实最重要的就是编异器因为语言的语法语言分析都是编异器做的但同一种语言的编异器可能会有多种所以这里就会有争议虚拟继就是编异器深层或者程序它运行使需要依赖的环境又称运行使比如加瓦因为它编异层中阶字节码所以要由虚拟机转成机器码之行虚拟机还有就是要提供运行使的库制时和垃圾回收比如像苍杰当然 cj 和 ross 的这些直接编异层机器码不需要垃圾回收运行使的支撑其实就是超多系统那底层虚拟机又是什么就是在机器码之上又定义了一个中阶码这是一个现代概念它不同于加瓦的字节码不会去做垃圾回收这些工作而是直接对应机器码那为什么要做这一层不同的设备机器码是不同的要针对不同的设备做优化并且机器码的代码本身也要做优化所以就把这部分独立出来处理了这就是 a.o.l.vm使用 cj 实现的这也是因为为什么我们讲 ross 的你不看 cj 这个已经成为标准了我看倡节也是引入了还就是标准库就是没中语言它提供支持的一些寒速类没中语言基本是用自己实现当拍声可能出外像 c 语言它编继虽然是用 cj 但是它库肯定是 c 做的下面我们开始来看代码我们再来看 c 和 cj 代码我之前视频讲过 cj 和 c 已经是不同的语言了但这里面还是要放在一起角因为他们编异气是一致的我们以编异气 gcc 和可能量为例来看我们先打开 gcc 的语言我们可以看到 cj 和 c 个赞 30% c 这里面主要是库寒速的时间还有部分救的代码因为很多新的代码慢慢的全部替换到 cj 代码我们要说明 c 使用 cj 编的那我们先找到 c 语言的解释代码然后我们再看一下它为什么要用 cj 编异我们以 c 语言当中的一副语法为例看一下 c 语言的实现在这里面我们在 gcc 当中 c 目楼下面因为它针对 c 和 cj 有不同的实现我们看 c 的实现在这里面是后债是点 cc 的文件其实这里面就是 cj 了看一下它的一副语法一副语法是这个寒速它为什么会换到 cj 呢我看早期版本的 gcc 还是 c 语言的实现然后我们看一下它哪里用了 cj 啊我们在这个一副语法的寒速当中可以看到它其中一个参数而这里面用了模板类进入代码我们可以看到基于模板的原编程代码它是用这部分来替代了原来的红不仅保留的效率而且可维护性是大大增强了 c 语言都用 cj 实现了那 cj 就更不用说了完全是 cj 实现的我们在分析这个原码的时候可以看到它里面的 gcc 的 cp 目楼可以看到它有 cj 各个版本的支持包括里面的语法的解析都在这里面 gcc 实现是一直用的表夺的但现在还有一个因为表夺的是 knai我们也看一下它的原码它是可以用于边异 cc 加加 objc 所有的类似语言目前红们开发用到的 cj 也是基于 knai我们直接打开 knai 的开源项目可以看到它的 cj 的占比更高了完全是 cj 编写70%的 cj 代码这里面 c 主要是就是 c 语言的库部分因为它没有这个历史的代码所以整个 c 和 cj 让目前的编写器的实现主流都已经是转到 cj 家家的虽然 c 语言可以做到所以从工程和效率的考虑它还是转到了 cj 家再看加娃我们分析开源版本的 open 接地盖标准库部分都是加娃实现的编写 cj 加娃 c 也就是与发解析部分可以看到它也是用加娃实现的那我们再看它训理机部分代码就是垃圾回收的处理加娃根据不同的平台可以看到这里面 cpu 的不同平台做了不同的处理比较说我们也差8,6为例我们打开这个 gc可以看到它里面的实现整个垃圾回收处理的实现都是基于 cj 家家来做的所以最终结论就是加娃他是由自己和 cj 共同实现再看变成语言拍明第一的拍审他有多种实现我们主流实现是 c 拍审所以说我们主要看他我们打开 c 拍审项目可以看到实现部分呢拍审最多主要就是标准库部分c 源沾了35.9这就是语发解析部分我们可以直接去看一下这部分语发解析的代码这里面是一个对拍审关键制的解析可以看到它这里面是基本基于 c 源实现的拍审没有用 cj 做实现但它的很多扩展库是用 cj 开发的比如说我们现在 a  app 普及使用的tans 扶楼和py 套取都使用 cj 开发的我们打开看一下tans 扶楼 cj 沾了 55%其他是拍审的代码py 套取同样的 cj 沾了 32% 代码其他也是py 沾的代码我们在项目当中做拍审扩展的话基本上还是要基于 cj 架架现在 a r 的底层够见的语言就是py 审和 cj 架架因为底层是 cj 然后上层用我们可能用py 审去做我们再来看一下一直说要替代 cj 的 rust它的实现整个原码几乎全部是由 rust 的写的但为什么说它离不开 cj 架架呢因为 rust 的编一架它并没有直接编一层机器码而是编一层的 a.lvm 编码这就是我们前面讲的底层续理计代码我们看一下 a.lvm 的实现可以看到除了它自己的编码之外就是以 c 架架为主来实现的所以这也就是为什么编以 rust 的还得装 cj 这套工具那 rust 的为什么不自己做的我觉得应该是维护成本的考虑针对各种平台的编异优化cjar rust 的针丽语言其实是一致的没必要再单独做一遍所以我们说 rust 的使用 rust 的实现了但离不开 cj 架架再看 go 语言完全是基于 go 语言编写最终也是编一层机器码那 go 语言为什么没有像 rust 的 cj 架架这一样用 a.lvm 呢主要原因还是 go 和 cjar rust 的不同它没有极致的性能追求因为它有拉去回收所以密集计算的性能肯定受限够原它有一个目标就是提升编异的效率只要经过了 a.lvm那它的编异速度又是肯定就没有了够语言它自己做了机器码的声音我们可以看下它的这个缘码在编异阶段它其实针对了不同的芯片都做了它的这样的一个代码编异的优化可以看到够语言的大家可以回收都是基于够语言实现的所以够语言啊算是比较纯粹的自取实现的语言当然它最早的版本是用 c 语言做的倡结的语言码呢目前分为编异器和虚拟机我们先看编异器打开这个项目可以看到它目前是以 c 加加为主编写的构建的用的是 c  make 啊红盟安卓这里面都是用 c  make 构建但是我们看这个图知道倡结它也引入了 a.lvm因为它是可以编异成机器码的所以说它同样的是可以通过 a.lvm进行画平台的优化我们可以看到它的这个语法解释完全是用 c 加做的到了这部分在倡结后面的版本当中肯定是可以替换掉我们再看倡结的虚拟机也就是倡结的运行时可以看到它的构成倡结加了一半因为这里面是包含了这个标准库的实现 c 加加的31.4%这就是我们倡结运行时的内存管你异常处理模块使用 c 加去实现的然后在这里我们看到其实它还用到了 c当然这里面它也包含了会编会编的话我们可以看你们的语言码在我们运行时当中它其实是会针对各个平台做这样的一种优化像这里面我们有点点 smacOSWindows它针对各种平台然后使用的会编带嘛进行了这样一个优化那我们再看一下它 c 用在哪边标准库当中唱节的一些寒树的其实是用 c 开发的目前要一直 c 加了库给倡结比如说你把cue 利益就过去我看了一下还是要转成 c 的寒树然后再转给倡结这部分还是希望倡结能够减化一下这样能更好的利用 c 加的寸态最后倡结我们总结一下编弃和运行时包括一场存在拉机回头这里面是 c 加做的标准库是倡结做的但是用了一部分 c所以是以 c 加为主倡结做标准库后面的话我觉得除了在运行时那部分c 加不太可替代之外整个编弃我觉得是完全可以用倡结来实现的因为倡结是7月31号才发布的第一个版本它的很多伸态还不管上它主要是用来替代部分加分的倡结所以现在如果想参与的话是比较容易介入它的深态的目前我们也是在参与这个倡结的一些深态的开发在红门开发少目前倡结还没有完全替代原来的 r 贴词肯定还是需要一些时间最近分析了很多看员项目自己也有收获后面准备再来挖掘一些值得分享的内容记得点赞关注小老师
