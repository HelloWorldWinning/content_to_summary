Timestamp: 2025-12-04T00:01:36.349780
Title: Rust 投入生产环境一年的经历 BV1mysDeGEph
URL: https://b23.tv/Q2axkuZ
Status: success
Duration: 14:07

Description:
好的，这是根据提供的文本内容提炼和总结的核心思想。

### **Rust在生产环境一年实践的核心总结**

#### **一、 核心优势：构建稳健、可维护的软件**

1.  **编译即正确，运行极稳定 (Compile Success, Runtime Success)**
    *   **编译时保障**：Rust 强大的类型安全和编译器特性（如所有权、借用检查）能在编译阶段消除大量潜在错误，例如类型不匹配（`i64` 赋值给 `UUID`）、访问不存在的字段等。
    *   **运行时可靠**：只要代码能通过编译，它几乎就能完美运行。作者强调，除非主动使用 `unwrap`，否则 Rust 进程从未遇到过像 Node.js 那样的崩溃情况。
    *   **强制错误处理**：`Result` 和 `?` 语法强制开发者显式地处理可能失败的操作，将错误作为一等公民，从而避免了隐式的运行时异常，使系统在出错时行为可预测。

2.  **赋能强大的工具生态 (Empowered Tooling)**
    *   **编译时数据库校验**：以 `sqlx` 库为例，它能在编译时连接真实数据库来验证 SQL 查询的语法和类型，从根本上杜绝了拼写错误或参数类型不匹配的 SQL 问题，无需依赖复杂的 ORM 或编写大量单元测试。
    *   **类型安全的模板引擎**：像 Askama 或 Maud 这样的库可以确保传递给模板的数据类型正确，消除了因模板变量错误导致的渲染问题。

3.  **卓越的长期可维护性 (High Maintainability)**
    *   **降低心智负担**：对于大型项目，开发者无需像在动态语言（如PHP、JavaScript）中那样，费力地记住复杂的数据结构和状态。类型系统成为了活文档，让重构变得安全且充满信心。
    *   **稳定的项目工具链**：与 JavaScript 生态系统频繁的工具更迭（如构建工具、测试框架的变化）相比，Rust 的 `cargo` 和 `clippy` 等核心工具非常稳定成熟，减少了“配置疲劳”。

#### **二、 主要痛点：开发效率与生态成熟度**

1.  **编译时间是最大瓶颈 (Compilation Time)**
    *   随着项目规模和依赖（特别是使用过程宏的库，如 `sqlx`）的增长，编译时间会显著增加，从最初的6分钟增长到20分钟。
    *   虽然本地的增量编译体验尚可，但在 CI/CD 环境中，漫长的编译时间是一个显著的痛点。

2.  **开发反馈循环变慢 (Slow Feedback Loop)**
    *   Rust 的编译-运行模式打破了 Web 开发中常见的“修改代码、立即热重载、查看结果”的快速迭代循环。
    *   它更倾向于引导开发者编写一大段代码，然后一次性编译和测试，这与 JavaScript/TypeScript 的即时反馈体验形成鲜明对比。

3.  **部分生态领域尚不完善 (Incomplete Ecosystem)**
    *   尽管核心后端生态（如Web框架 Axum）很强大，但在某些领域，如可靠的、类型安全的第三方 API 客户端生成方面，仍有欠缺。
    *   对于一些小众或边缘场景，可能会遇到文档和示例不足的情况，需要开发者自行阅读源码来解决问题。

---

### **核心观点 (Core Point)**

尽管Rust因编译时间长而牺牲了即时开发的敏捷性，但其带来的无与伦比的运行时稳定性、类型安全保证和长期可维护性，使其成为构建复杂、可靠的生产环境后端服务的卓越选择。

---

### **内容的总览框架 (Overarching Framework)**

本文通过一个**生产环境实践者的视角**，对使用Rust进行Web后端开发进行了一次全面的**成本收益分析（Cost-Benefit Analysis）**，其核心是权衡**开发体验的摩擦成本**（编译慢、反馈慢）与**生产环境的巨大收益**（高稳定性、高可维护性、少bug）之间的得失。

---

### **概念关系图 (Mermaid Conceptual Map)**

<Mermaid_Diagram>
graph TD
    A["Rust 生产环境一年经验总结"]

    subgraph "核心优势 (Benefits)"
        B["高可靠性与可维护性"]
        B --> C["编译成功 ≈ 运行成功"]
        B --> D["强大的类型安全"]
        B --> E["运行时极其稳定"]
        B --> F["赋能高质量工具"]
        D -- "杜绝" --> G["类型错误 / 空指针"]
        D -- "实现" --> F
        E -- "源于" --> H["强制错误处理 (Result/?)"]
        E -- "避免" -- "与Node.js对比" --> I["进程意外崩溃"]
        F -- "例如" --> J["`sqlx`: 编译时SQL校验"]
        F -- "例如" --> K["`Askama`: 类型安全模板"]
    end

    subgraph "主要痛点 (Pain Points)"
        L["开发效率与生态挑战"]
        L --> M["编译时间长"]
        L --> N["开发反馈循环慢"]
        L --> O["部分生态不完善"]
        M -- "尤其在" --> P["CI/CD环境"]
        M -- "导致" --> N
        N -- "打破" --> Q["“即时修改-测试” 循环"]
        O -- "表现为" --> R["边缘案例文档缺失"]
        O -- "表现为" --> S["第三方API客户端欠缺"]
    end

    A -- "正面评价" --> B
    A -- "负面评价" --> L

    style A fill:#FFD700,stroke:#333,stroke-width:2px
    style B fill:#D5E8D4,stroke:#82B366,stroke-width:2px
    style L fill:#F8CECC,stroke:#B85450,stroke-width:2px

    style C fill:#E1F5FE,stroke:#333
    style D fill:#E1F5FE,stroke:#333
    style E fill:#E1F5FE,stroke:#333
    style F fill:#E1F5FE,stroke:#333
    style G fill:#E1F5FE,stroke:#333
    style H fill:#E1F5FE,stroke:#333
    style I fill:#E1F5FE,stroke:#333
    style J fill:#C5E1A5,stroke:#333
    style K fill:#C5E1A5,stroke:#333

    style M fill:#FFEBEE,stroke:#333
    style N fill:#FFEBEE,stroke:#333
    style O fill:#FFEBEE,stroke:#333
    style P fill:#FFEBEE,stroke:#333
    style Q fill:#FFEBEE,stroke:#333
    style R fill:#FFCDD2,stroke:#333
    style S fill:#FFCDD2,stroke:#333

    linkStyle 0 stroke:#00796B,stroke-width:2px
    linkStyle 1 stroke:#D32F2F,stroke-width:2px
</Mermaid_Diagram>

Content:
我们来看一篇比较有意思的文章就是有一个作者是叫Dimetry Cool Drive有点像是看这个名字有点像是俄罗斯或者周边的一个国家的人它的名字叫Rustle投入生产环境一年的经历推文文章是在9月22号写的时间非常的近这是它的原文念节有请你可以看到原文我们来看它的详细内容过去一个月我几乎把所有的困惦时间都花在了我的副眼加速的facts上面一切从把支付系统从Namens Squeeze 前一段stripe上面开始为什么呢?他说订阅他的伯克可以看到他之前详细解释为什么的原因啊但中路每次重够或者重写一样项目远比我预期的要复杂的多一个简单的支付付提供上切换结果要求我家10个月上面实现一个作业处理对列还得做一个小型的快几系统但这一切都是用Rustle的实现的这就导致了我说提交优势以来最大的一次合并请求它的合并请求很大260个圈就算了然后就是合并请求比较大这个合并请求正好赶上我启动加速的facts大于一周年于是通常我在主业中也是用Rustle的开发商品因此我决定告诉一下在生产行程中是用Rustle的感受第一小把讲的是编译成功运行无邮这一边你能编译通过就能跑我之前在撰写Rustle外部医院出体验室医院的出体验室提到过这一点现在我想再次强调这一点就说你编译通过肯定会能跑肯定会能跑了通常我不会在每次修改后都运行但除非是进行发出的cs较整这个有的意思点就是它说讲的是Rustle在外部医院上面的一个体验就是生产行程它跟游戏之间还是有不同的点我们来看大多数情况下我会完成一个交达的充够然后交达的充够或者困难实现的话然后再一起运行测试而且在Rustle的当中如果带码不能够编译通过的话你就没办法运行它这跟gs不一样如果带码有错你就必须修复它两个这两个跑于是我就陷入了一个长时间的充够当中这期间带码重位处于可以编一条状态直到所有事情都完成的最后一颗但所有系统组织都配置好并发出第一个本地的请求的时候我本来很担心但我今天是一切正产运行虽然我知道自己是一个不错的开发者但我不会天真的认为自己能写出完全没有错误的代码除了少量的动态代码问题比如错误的训练化、发泄化化格式代码几乎是完美运行的这种成功的第一个原因是是什么呢是Rustle的内型安全和编译特性就让编细不会让你错误的把一个i64负质给UID也不允许你像在界时中那样访问不存在了什么结构理智团不会有这样的尽管有些人生存自己存在没有给了过无法访问威丁一的附属性之类的软太密措当我和同事的经历并不一样我们在主业中使用Rustle的原因之一是什么了原本使用动态、语言、编辑的后段变得难以为后了就是太大的难为后了对于一个小英雄你可能可以在这个脑海中记住一下他的三下稳但是随着系统变大记住受的细节就变得不可能了我和记得以前做PHP的时候有时候我来知道书主在哪里书主里面有哪些剑有哪些剑就不得不把书主内容直接打印出来因为有些剑是Slayer模式的有些剑是Northome模式这种剑的面面方式模式格式不一样格式不一样第二层或者说是第一层的延伸也就是Rustle对内型安全的指责这种指责就出生了像Squeal差点的根据这个很有意思它加少了Squeal差这个根据一个编细的内型安全的Squeal分装库它会在真正的数据库上运行你的差距如果差距发错或者是你尝试将一个I-SAR插入到一个文本列的这种里面而且没有显示转弯的话带满混弊办法通过编议我以前对Squeal存满的位置因为它是每个应用的核心部分出错就很容易在生产房间的如果拼错了差距或者搞错了差数你就麻烦了很多人会为了Squeal的差距编写这个单元测试一个人试用这个ROM或者是根据数据库模式的生存代码但是有了Squeal差我就再也不用担心这个问题了我可以充分享受Squeal的强大功能不需要依赖高度出现了ROM或者进行数据库模式的代码生存当然这也有一些缺点或者后面的不够能不能提到这一点另一个属于这一类的这个根据是内型安全的模板引擎比如说SKama或者Mod虽然我在项目都没有运动它们但他们确实消除了代码都能另一种不缺的性有时候我说到I-HELLOUZNAME开头的电动预件的时候会怎么不出效这种错误如果来自这种无名的就是很不聪明的复材好如果来自这种引行就比较尴尬了而有了内型安全的编议时候这个模板这种错误就不会存在就是这个能说没有一些引行它这个系统就不是静态写的所以会可能存在这种情况我唯一环境的身体型安全的第三方API接口就是就是若是它没有这个地方它是它那边环境的地方就是算你可以从Open API swag规范生存的可我段当然要数字于第三方API的地方上即便它们提供了规范也不一定以为它会争议成这个规范或者是保证他们的API不会争大对于自己的话我认为还没有缺缺发就是安全的第他API这次比较难的还有一个就是当它允许的时候说非常稳定的非常稳定的我从来没有遇到过RUSH的进程崩溃的情况倒数遇到过Node进程崩溃就是GS上面Node进程可能会崩溃除非你在弹码中到处使用Unwrap就是Unwrap就是基本上因为如果结果是错误就崩溃基本上是这样的否则你有进程可能运运不过崩溃我的弹码中确实有一些Unwrap主要是它出自化的时候所以说如果配置文件确实或者环境编辆没有定义除了让进程崩溃外我也没有什么别的选择这个其实在错误处理上面错误模型上面就叫立即错误对吧 放弃形错必须把它扔掉扔掉后面没法跑但中厅来说的话RUSH要求你显示的处理错误任何反回RUSH三分Around的弹码都会去你通过问号处处处向上传理错误或者是使用Match举进处理在大多数情况下做得非常合理而在某些情况下是有点烦比如说当你知道I-64专会I-S-R没问题的时候你还得运TryFrom它反回一个RUSH即便在这些让人比较烦就往下我通常也不会去用RAP而是记录一个告警编反回一个合理的默认识编程中的触摆位置因此至少我的存用可以继续运行编记录一下我可能犯错的地方根据非常强大就是说RUSH在根据上面加上Factor不仅仍是用RUSH写的它和内部系统使用Type-Squip和其他的伎丝框架而且我每次创建一个新的Type-Squip下面说总会有些东西会改变要么是某个根据的配置文件变了要么是Type-Squip的新的样板文件USP2是后来不再流行的大家用Fastify了接着USP2又变得流行了又跨又变倒过来TESNO的被淘汰改变TES差某个模块只支持USM另一个模块又是CGSType-Squip总是在变化你变些代码啊另一代码再存的季 S和Type-Squip总使用这个 Workspace的方式都在变但是RUSH写不太好只要卡在那里就能够生成一个新项目想要 Workspace没问题完美运行念头根据Clippy已经有完美的Clippy来给你搞定了RUSH写的几乎没有这种样板代码也减少了单精神皮牢对吧并一时间仍然是痛点并一时间仍然是坑RUSH的确点好我用的就是并一时间特别是当你使用一辆红的困局这个我们在之前的视频中看的过对于解红它是非常好时间的红展开是非常好时间的比如说Squip差或者是Mode无论是KFB、SB和编辑都会开始吃力所以说项目的扩大了我记得了越来越多的第三方依赖尽管我试图通过讲多个报道公共依赖发入根部路的卡钩塔蒙文件中但积极选择数据的依赖困难优化这个便宜当我仍然在便宜时间上非常地增长我提到过最初在CLC的一种编议需要大概6分钟而现在已经需要20分钟了根据网上的各种伯克确实可以通过这个缓存依赖和使用多节量的刀和容器优化便宜时间但这需要非常精准的传统我现在没时间做这个事需要更多的专注与业务层面不过以后我会处理的在苹果的M2上面的本地编议还算可以接受特别是侦量便宜一下但代价是占用了大量的重重分件我是不是都愿意开个个订请你调几十级约的缓存而即使有了这个侦量便宜它依然远没有借还是是一种即使热重载快所以回到最初的观点这个后面讲的就很有意思了就那种改一下代码利益测试的开发情况被打破了就不是这种方式了你没有办法像这个戒业的时候或者是Type-Squeep的那样就是或者即使非常即使的反馈这也是加上发酵的一些内部和外部工具一样使用Type-Squeep的冰淇淋Rast更像是在引导你你写大量的代码冰淇淋然后浅差你写很多然后再去冰淇淋对啊而不像是像路的Joucequeep的那样一旦好像改代码切换的对象器测一下看一下我大多数情况下可以接受这个纠称因为我得到了那些安全的好处我相信CI-PAP-NINE可以解决这个问题但是我需要更多的时间来优化它工具生态还没有完全完善就是它认为的生产还能有一个问题有些领域Rast的表现得非常好比如说从后段像Xium这样的宽佳提供了购件APP夫妻所需的大部分逐渐并且大多数流行的外白PAP都有这个Rast的扣段虽然这些扣段通常不是有这个购件APP的工作维护的但至少我们可以使用它们但是完成了大多数的一直拼Buffer-Buffer-Rast因此你需要自己摸索怎么集成各种APP在Rast的开放过程中这些有反复出现的问题至少在外部开发方面我不能够评论其他类型的应用我经常会查看原谈码或者是给他们找一下我遇到的问题类似的讨论大模型就很多的这些大模型很少能够提供合适的觉法因为大模型这些都能够办不上马因为大多数包都是一种很小种类的一个可能它的训练书记里没这个东西所以Rast的事去对包的包的文档和势力非常的重视非常好但最终你会遇到一些边缘的这种不是那种就是大众的就是很小种边缘的那种案例它既没有文档也没有例子你只能通过运动原谈码的解决问题那有些运动的存用并不适合Rast尤其是对于那些人来这些快速运行开发其实像这个游戏开发就是那种模式了对吧我仍然更喜欢TX和STRA或者是SWAMG来写钱段Rast这方面的开发体验并不好每次这个编辆编划后都需要存心编辆就使得钱段开发的快速跌代就编得比较慢最后我很高兴一年前选择了Rast它不仅搬住我活得了我非常喜欢的主业的这种工作主要业务的这种工作还让我能够购捐更好的软件我期待就在接下来的一年继续使用Rast的开发所以这边文章也很有意思基本上讲到的问题跟之前的一些人的感受是比较齐合的大家的感受应该是类似的这就是在Wap开发上面它有很多的优点尤其是在比较大一点的这种项目上面它是很有优点的就是它会对你的用为起到一个非常好的改变之前的试评人们也有讲到过这个问题但这边文章独角也有意思
