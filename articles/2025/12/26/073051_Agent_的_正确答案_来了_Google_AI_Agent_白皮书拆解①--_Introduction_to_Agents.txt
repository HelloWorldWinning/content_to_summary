Timestamp: 2025-12-26T07:30:51.478621
Title: Agent 的“正确答案”来了，Google AI Agent 白皮书拆解①--《Introduction to Agents》
URL: https://youtube.com/watch?v=ZlMoUcScmcg&si=SjQyuWouDKuzfkp4
Status: success
Duration: 42:53

Description:
好的，这是根据您提供的文本内容提炼的核心思想摘要。

### **核心思想纲要**

#### **I. 核心定义：AI Agent是一个可治理的工程系统**

*   **根本转变**：Agent的核心价值并非生成更优美的文本，而是**将大型语言模型（LLM）置于一个可重复的循环中，以逐步完成任务**。它将讨论焦点从“模型能力”转向“系统工程”。
*   **四要素架构**：一个可落地的Agent系统由四个核心部分组成：
    1.  **模型 (Model)**：作为“大脑”，负责理解、推理和规划。
    2.  **工具 (Tools)**：作为“手脚”，通过API、数据库查询、代码执行等方式与现实世界交互。
    3.  **编排层 (Orchestration Layer)**：作为“神经系统”，负责驱动`Think-Act-Observe`循环，管理状态、记忆和上下文。
    4.  **运行时服务 (Runtime Services)**：作为“身体与支撑系统”，确保Agent能作为长期在线服务运行，提供监控、日志、安全和扩缩容能力。

#### **II. 核心运行机制：Think-Act-Observe五步循环**

这是Agent区别于普通聊天机器人的本质，它是一个持续运转的控制回路，确保任务能被“办完”而非仅仅“聊完”。

1.  **获取任务 (Get a mission)**：明确用户或系统的目标。
2.  **扫描现场 (Scan the scene)**：收集所有可用上下文，包括用户输入、历史会话和可用工具。
3.  **思考规划 (Think through)**：模型基于目标和现场信息，生成一个可执行的计划。
4.  **执行动作 (Take action)**：编排层根据计划选择并调用具体工具。
5.  **观察并迭代 (Observe and Iterate)**：处理工具返回的结果，将其作为新的上下文，进入下一轮循环。

#### **III. 架构蓝图：Agent成熟度分级 (L0-L4)**

这个分级模型是架构选型、成本估算和交付预期的“标尺”，核心在于平衡能力与工程治理的复杂性。

*   **L0 - 纯推理系统**：只有模型，没有工具，对现实世界是“盲”的。
*   **L1 - 连接现实的问题解决者**：核心升级是**接入工具**，能获取事实，减少幻觉。工程重点是可靠的工具调用。
*   **L2 - 上下文工程师**：核心是**主动的上下文管理**，能进行战略规划，为复杂任务的每一步构建最小有效上下文，防止目标漂移。这是真正Agent系统的开端。
*   **L3 - 协作式多智能体**：从“超级大脑”演变为“专家团队”，通过任务拆解和分工解决组织级复杂问题。
*   **L4 - 自我演进系统**：系统能发现自身能力缺陷，并动态创建新工具或新Agent来弥补。

#### **IV. 关键工程实践与生产化 (AgentOps)**

*   **模型选型**：是**架构决策**，而非“榜单冲浪”。应遵循“业务KPI -> 评测集 -> 质量/成本/延迟综合评估”的流程，重点考察模型的**多步推理**和**可靠工具使用**能力。
*   **工具设计**：工具不仅是功能封装，更是**风险的笼子**。必须通过**OpenAPI**等协议定义清晰契约，并通过“人机协同（HITO）”作为高风险操作的安全阀。
*   **编排层设计**：核心是**在可观测、可治理的前提下，让Agent的自由度用在刀刃上**。它通过状态机、规则和调度，将模型的不确定性约束在可控范围内。
*   **AgentOps**：为解决Agent（随机性系统）的上线难题，需建立一套新的工程闭环：
    1.  **可观测性**：通过Traces追踪Agent的每一个决策、调用和结果，回答“为什么”。
    2.  **质量评测**：建立Golden Dataset，用LLM-as-a-Judge等方式对行为轨迹进行评估。
    3.  **指标驱动开发**：任何变更（模型、Prompt）都必须通过评测，确保关键指标不下降才能上线。
*   **安全与治理**：通过**确定性护栏 (Guardrails)** 和 **推理型防御 (Guard Models)** 构建纵深防御体系。在规模化阶段，必须建立Agent身份、策略中心和统一控制平面。

---

### **核心观点**

将AI Agent从单纯追求模型能力的“概念验证”阶段，提升到可构建、可观测、可治理、可规模化上线的“生产级软件工程”体系。

---

### **总体框架**

该内容的核心框架是**“一个定义，一个循环，一个分级模型，一套工程体系”**。
1.  **一个定义**：Agent = 模型 + 工具 + 编排层 + 运行时。
2.  **一个循环**：以`Think-Act-Observe`为核心的五步闭环是Agent的行为基础。
3.  **一个分级模型**：L0到L4的成熟度模型为系统架构提供了演进路线图和范围界定。
4.  **一套工程体系 (AgentOps)**：涵盖从模型选型、上下文工程、多智能体协作到评测、安全、部署的全生命周期实践，确保Agent能够作为可靠的生产级服务交付。

---

### **核心概念图 (Mermaid)**

<Mermaid_Diagram>
graph TD
  subgraph "生产级AI Agent系统 (Production-Grade AI Agent System)"
    direction LR
    A["Agent系统四要素"]
    B["核心运行循环 (Think-Act-Observe)"]
    C["Agent成熟度模型 (L0-L4)"]
    D["生产化与治理 (AgentOps)"]
  end

  subgraph "四要素 (Core Components)"
    direction TB
    M["模型 (大脑)
    推理/规划"]
    T["工具 (手脚)
    与世界交互"]
    O["编排层 (神经)
    驱动循环/管理状态"]
    R["运行时 (身体)
    服务化/监控/安全"]
  end

  subgraph "运行循环 (Operational Loop)"
    direction LR
    T1["1. 获取任务"] --> T2["2. 扫描现场"]
    T2 --> T3["3. 思考规划 (Think)"]
    T3 --> T4["4. 执行动作 (Act)"]
    T4 --> T5["5. 观察迭代 (Observe)"]
    T5 -.-> T3
  end

  subgraph "成熟度 (Maturity Levels)"
    direction TB
    L0["L0: 纯推理"] --> L1["L1: 连接现实 (工具)"]
    L1 --> L2["L2: 上下文工程 (记忆)"]
    L2 --> L3["L3: 多智能体协作"]
    L3 --> L4["L4: 自我演进"]
  end

  subgraph "生产化 (Productionization)"
    direction TB
    P1["可观测性 (Traces)"]
    P2["质量评测 & CI/CD"]
    P3["安全与治理"]
    P4["部署与扩展"]
    P5["互操作性 (A2A/H2A)"]
  end

  A --> M
  A --> T
  A --> O
  A --> R
  O -- "驱动" --> B
  M -- "用于" --> T3
  T -- "用于" --> T4
  A -- "架构演进路线" --> C
  T -- "实现" --> L1
  O -- "实现" --> L2
  R -- "支撑" --> D
  D --> P1
  D --> P2
  D --> P3
  D --> P4
  D --> P5

  style A fill:#FFF3C4,stroke:#333,stroke-width:2px
  style B fill:#E6F3FF,stroke:#333,stroke-width:1.5px
  style C fill:#E6F3FF,stroke:#333,stroke-width:1.5px
  style D fill:#D4EDDA,stroke:#333,stroke-width:1.5px
  style M fill:#ADD8E6,stroke:#333,stroke-width:1px
  style T fill:#ADD8E6,stroke:#333,stroke-width:1px
  style O fill:#ADD8E6,stroke:#333,stroke-width:1px
  style R fill:#ADD8E6,stroke:#333,stroke-width:1px
  style T3 fill:#FFE4B5,stroke:#333,stroke-width:1.5px
  style T4 fill:#FFB6C1,stroke:#333,stroke-width:1.5px
  style T5 fill:#90EE90,stroke:#333,stroke-width:1.5px
  style L1 fill:#C8E6C9,stroke:#333,stroke-width:1.5px
  style L2 fill:#C8E6C9,stroke:#333,stroke-width:1.5px

</Mermaid_Diagram>

Content:
这一期我们开个新系列Google联合开沟最近发布了五篇白皮书把AI agents从概念直接推到工程与生产我将带大家主意解读这些白皮书今天先肯第一本Introduction to agents目标就一个把底层框架讲清楚让你后面做架构、做平台、做产品都有同一张地图先讲下背景这五天到底发布了什么为什么它会变成从业者的参考系如果只用一句话概括它的行业意义Google把 agent从promp加几个工具的拼装拉回到软件工程的全生命周期也就是你得能够见、能拼孤、能运为、能部署这个转向很关键因为它把讨论焦点从模型能不能变成系统稳部稳控不控能不能规模画上线最后我们把五篇白皮书当成一张路线图Dae1先定义 agent是什么Dae2讲工具与互操作重点是mcpDae3进入汇化与记忆也就是上下文工程的核心Dae4讲质量可观测、评测Lm价值这一套怎么落地Dae5把原型推到生产包括多智能体协作协议和部署治理这套顺序很工程化先定义对象再不能力再不记忆再不质量最后上生产从这一单元开始我们正式进Dae1第一本白皮书英硕DuckishonAgent先把一个最容易被聊天的问题定死Agent不是更会聊天的Lm在Google的定义里Agent是一套可够件可运行可治理的工程系统后面所有内容都是围绕这个系统怎么设计怎么跑怎么上线给一个可落地的最简定义Agent等于四件套Model ToolsOchestration Layer以及Round Time或Deployment Services它的关键不是能生成而是用Lm在循环里做事你可以把它理解成一个持续运转的控制回路每一轮把任务目标和上下文装进去模型做决策必要时调用工具拿结果再把结果回血上下文进入下一轮所以如果你的系统只是一问一答哪怕加了几个方式Coling本质上还是应用层的对话接口只有当它具备稳定的循环机制并且有运行时服务支撑可观测可控可扩展它才开始向一个真正的Agentic System接下来把4要素的分工讲清楚第一Model也就是大脑负责理解目标做推理出计划但记住模型本身不等于Agent第二TOS也就是手让系统能接触现实查数据搜信息调业务API执行代码没有工具很多任务只能停留在口头建议第三Occostration Layer神经系统它是最容易被忽略但最决定承败的一层它负责把ThinkActObserve这个循环跑起来负责状态管理负责把Session history短期状态长期记忆这些东西在每一步正确的塞进Context window第四Deployment或Round Time Services身体和腿这部分决定你的Agent能不能变成长期在线的服务能不能监控能不能打日治能不能做全线能不能扩缩容很多团队做不出生产及Agent不是因为模型不够强而是因为缺了编排层和运行时服务系统不可控不可观测不可治理这一单元我们把Agent从定义拉回运行一句话Agent的核心不是输出更漂亮的文本而是用一个可重复的循环把任务一步步办完你把这套循环跑稳了才有资格谈多工具多智能体上生产先把这五步丁死第一步Get a mission拿到目标来自用户也可能来自系统出发第二步Scan the scene扫现场能用的上下文都在这一步收集用户说了什么历史会话有什么我能调哪些工具第三步Cincate through想清楚模型基于目标和现场产出一个可执行的计划第四步Take action开始干活编排层选择工具发起一次具体的突扣第五步Observe and Etherate观察结果然后迭代把工具返回写回上下文进入下一轮注意五步里最值钱的不是Think而是Think之后真的能act并且act的结果能被系统消费这才叫办事接下来把这套循环翻译成工程语言Think是model的是负责规划决定下一步要什么信息要调用什么能力act是Tools的事真正去查去改 去执行Observe是系统的事把工具返回变成可用上下文未回下一次模型调用这一步很多团队做坏了工具返回一大托接圈直接c回去Context window立刻爆炸所以你会看到Google在day1就强调Agent本质是Context window的侧展系统你要把Observe做成结构化可筛选可追踪的工件否则Think再强也只是在一堆造生里瞎想从可观测角度看Think Act of Observe也是你打Trace的天然编剑美伦发生了什么决策调用了什么工具回来了什么结果一言可查我们用一个经典的客服场景把五步跑一遍用户说我的定单12345现在到哪了Mission很清楚给出定单状态Sign怎么扫先确认我有哪些工具内部定单库查寻物流沉寓商查寻然后Think别急着回答先做一个三段实际话第一段Identify查内部库确认定单存在拿到运单号第二段Track用运单号去查成运商的实实物流状态第三段Report把事实会总成用户能堵懂的一句话接着Exit先调用FindOther12345Observe拿到定单记录和运单号比如Z1X987再Sink下一步该查物流Exit调用Gad7PingStatusZX987Observe反回Other4Delivery最后Think信息起了生成最终回复你看这就是Agent跟聊天机器人的分水领聊天机器人会直接边一个看起来很像的答案Agent会先把世界查一遍再开口这一单元我们不了Agent能做什么我们聊更致命的问题你到底在造哪一类AgentGoogle把AgenticSystem分成LiveO0到LiveO4这不是名词解释这是你做架构范围算治理成本定交付预期的第1把尺子先把结论放在前面做Agent最容易翻车的不是模型选错是你一开始就把系统范围开太大最后治理跟不上为什么Google要分析因为每上一个LiveO你增加的不是能力点而是一整套工程负担工具越多全线面越大记忆越长隐私和合规越难多智能体移上来观测鞋座责任边界会指数及复杂所以分析的意义是第一帮你把目标说清楚你到底要会想还是会办事第二帮你把依赖讲明白这个LiveO需要哪些基础设施第三帮你把上线门槛算出来评测监控策略审计要到什么程度一句话LiveO不是选季LiveO是你的系统承诺大家看这张分类图我们先抓LiveO和LiveO他俩的分水领就一句话有没有手LiveO是纯推理系统模型在自己的训练知识里做解释做规划给建议但他对现实是忙的你问昨晚比赛比分今天库存多少他只能猜LiveO是Connected Problem Solver核心升级是接上工具比如搜索RIG数据库查询他不靠记忆力硬备事实他靠工具把事实取回来然后再组织答案工程上LiveO一的关键不是你会不会方声calling而是你有没有把工具变成稳定器约能调用能处理失败能把结果回血进下一轮上下文所以如果你的系统目标是贴尽事实减少换绝能查能改LiveO一往往就是最划算的起点LiveO是我认为最容易被低估的一层很多人以为LiveO就是ProM的更长不对LiveO二的核心叫Context Engineering什么意思就是每一步都在做上下文的主动管理选哪些信息进来把信息怎么打包控制哪些造身别进来因为Agent真正的平静往往不是模型不会响是上下文塞的太满模型的注意力被垃圾信息吸适了结果就是计划飘移工具乱调用同一个任务越做越跑偏LiveO二的能力是战略规划它会把一个复杂目标拆成多部而且每一步都会基于上一步的观察结果自动深层下一步需要的最小上下文从工程角度LiveO二你要开始认真设计上下文结构状态对象怎么存工具结果怎么摘药以及哪些内容是音乐署必须进System Instruction做到了LiveO二你才真的在做Agent系统而不是工具型聊天在往上就是LiveO三和LiveO四这里反是会变不是一个超级大脑变更强而是变成一个专家团队LiveO三是协作多智能体一个协调者拿到种目标然后把任务拆给不同的专家Agent在系统里其他Agent变成一种高阶工具它解决的是组织问题分工并行复用LiveO四更激进系统不只用现成工具它能发现自己圈能力然后去创建比如动态造一个新工具或者新Agent补上缺口但我也把话说重一点LiveO三复似不是合一上来就做因为你要付出的代价是治理体系包括身份全线策略审计以及跨Agent的可观测否则你得到的不是智能体团队是不可控的Agent Spraw所以建议很明确先把LiveO一的事实异环跑文再把LiveO二的上下文工程做扎实最后再谈LiveO三的团队话和LiveO四的自我扩展进入优内的舞我们聊一个最容易被代结奏的话题选模型在Agent的系统里模型不是越大越强就完事Google的核心观点很直接模型选择是价购决策不是绑单冲浪这一单元我们用工程语言把选行标准核心能力和落地策略讲透先给结论选模型这件事正确顺序是业务目标在前模型在后不是看哪个绑单分高就把它塞进系统原因很现实Agent的失败往往不是打不出来而是在你的业务里不稳定比如你要它抽取你们自己的保单子段它老漏子段你要它按你们的工单规范写接寻它时不时就跑隔世这种问题通用Benchmark基本撤不出来所以真正的选行动作应该是三步第一步先写清楚你要交付的业务结果也就是KPI第二步把KPI硬设成可评测的离线任务籍也就是你自己的GoldenSat第三步用同一套评测脚本去跑不同模型拿到质量延迟成本三张帐这会逼着团队从我觉得这个模型很强变成这个模型在我的任务上更稳更划算这才是ProductionGrade的选行方式第二个要点在Agent的场景里你别指问模型会不会写你要问的是它能不能多步做完并且工具用的靠谱Google把这叫EgenticFoundermantos我把它翻译成两句大白话第一句复杂多步推理能力也就是它能不能在长练路任务里保持目标不飘移步骤不乱套第二句可靠工具使用能力也就是它能不能稳定的产生正确的寒属掉用参数别乱编拿到返回之后能正确消费结果为什么这两是一门砍因为Agent本质是LM in a loop你不是掉用一次模型你使用它连续做五轮十轮角侧任何一轮工具都会把后面的轨迹带崩所以评测时也别指测最后答案对不对要拆开测推理练路是否稳工具掉用是否准失败时是否能恢复这才是对Agent负责的模型评估最后这页讲怎么在工程里把选择落下去核心是三件事全横路由持续升级第一全横质量速度价格Agent的上限之后最常见的现实是你不能每个请求都用最贵最慢的模型你的约束来自SLA吞吐预算所以选心不是选一个最强而是选一个最合适的组合点第二多模型路由也就是Team of Specialists思路很工程化重推理用强模型轻任务用快模型比如复杂规划难推理交给旗舰模型意图识别摘药结构化抽取这种高频任务交给更便宜更快的模型路由可以是规则也可以是自动策略但目标只有一个把钱花在刀认上第三用Agent of Specialists做持续评测支撑快速升级因为模型迭代太快了你今天选的半年就被替代如果你没有持续评测和CICD你每次换模型都像在赌博反过来如果你有稳定的评测级质量分数线上AB指标升级就是常规操作这三件事和起来才是生产级Agent的架构的模型策略可控可算可持续到这一单元我们把视角从模型多聪明切到系统能不能真的动起来Tools是Agent的手没有手推理再强也只是建议有了手你才开始进入Production与近事实怎么对齐动作怎么执行风险怎么杀车先讲Grounding很多Agent的失败不是不会推理是没对齐事实你让他回答公司政策产品库存最新价格他如果不查就只能猜所以Google把减锁放在工具体系的最底层能力典型三类Rag脸下量库适合企业文档Nolage Graph适合强结构事实Google Search适合公开的实实信息这里的工程结论很直接第一先查再说能把换绝压下去一个数量级第二Grounding不只是减锁本身是把减锁结果变成下一轮上下文的可用事实也就是反回太长要摘药来源要可追溯必要时要带引用片段你把光顶做稳了Agent才有资格处理生产中的真实事件第二块更关键从独视界升级到改世界先说结构画数据当你的数据在数据库里最常见的动作不是Rag而是Nol2C口用自然语言深层C口去查分析数据比如级度销量特别产品异常定单这里的重点是C口这类工具调用必须可控可省级不能让模型随便抵离的再说执行类工具把你现有的业务能力封装成工具就行发邮件排会议更新工单协入CIMAgent不需要懂业务系统它只需要拿到清晰的工具器约然后按计划调用还有一类很强的工具代码执行在安全杀箱里跑拍色或深层C口脚本Agent就能把复杂计算清晰 转换 自动做完但这里能力要谨慎杀箱 资源限制超时 网络全线这些都是工程底线一句话总结工具不是越多越好工具是把能力做成可复用的接口并且把风险关在笼子里最后讲HITO很多团队以为HITO是体验不好但在生产里HITO其实是你的安全法也是责任编剑什么时候 必须把人拉进来两类场景第一类 信息不够比如缺日期 缺收剑人缺审批人Agent不能硬拆第二类 高风险动作比如对外发信改科乎数据触发付款批量操作工程上HITO就是一个工具比如ASK4 confirmationASK4 date input把它插在边排层的关键节点让系统停一下等人给最终授权或补权信息你会发现这不是退步这是把Agent的从可能乱来变成可控自动化想规模画上限HITO不是可选项是必备件上一单元我们说TOS是Agent的手但手再多如果只会不动调不准连部闻系统照样上不了线这一单元我们就专门解决一件事把工具调用从能跑的Demo升级成可契约可护操作的工程能力我们先把可靠工具调用讲成一个工程Chachlist就三件事清晰指令安全连接边排保证第一清晰指令你要让模型在什么条件下用工具用哪个工具输出什么参数格式失败怎么处理否则方式COLLE就会变成看心情深层参数你线上一定翻车第二安全连接工具调用不是玩具它是全线你要解决健权最小全线参数教验审计流痕一句话模型负责提议系统负责批准第三边排保证这是很多团队最缺的一块你得把Think Act Observe变成稳定状态机什么时候该调用工具什么时候该重视什么时候该降级什么时候必须嗨头并且要把每一次工具调用的输入输出错误都变成可观测的轨迹把这三件事做扎实你的工具调用才是可上线的而不是可演示的接下来讲协议我用一个很工程的画分契约和互操作先说OPAPI它解决的是契约问题也就是把工具描述成一个Skima这个工具干什么入餐有哪些自断类型是什么哪些闭填返回结构长什么样好处是模型更容易生成正确调用系统也更容易做教验MOK测试版本管理再说MCPMCP更像是互操作成它的价值不在描述一个工具有多规范而在让工具更容易被发现更容易被接入更容易跨系统复用当你的工具生态开始变大MCP会显著降低连接成本最后不一类模型原生工具比如加密奶原生Google Search这种模式的优势是集成顺滑调用路径短体验好但工程上你要想清楚可控性可观测性以及你能不能把它纳入同一套治理体系结论很简单Open API把工具变成可契约的组件MCP把组件变成可互操作的生态你要的是两条都打通而不是二选一到这一单元我们要把Agent从会推理会调工具升级成能长期稳定跑的系统核心角色就是Occustration Layer它不是一段焦水代码也不是简单的流程管道它更像系统的行为中书负责调度负责状态负责把不确定性关进可治理的框里边排层到底干什么我建议你把它当成智能体系统的状态机加调度器大家看这张舞步循环图模型负责响但不是模型自己决定什么时候停什么时候跑边排层负责把循环跑起来拿到Mixing扫Sync然后让模型Sync一旦需要落地就触发Agent去调用工具工具返回之后边排层再做Observe把返回加工程可用的上下文进入下一轮第二个职责是State和Memory状态不是聊天记录这么简单它包括当前任务进行到哪一步了已经调用过哪些工具拿到了哪些关键子段还有哪些缺口没补短期的Action和Observation训练通常就挂在State里长期记役则更像一个可查询的工具需要的时候被边排层拉进来第三个职责决定核实思考核实用工具这其实是控制成本和稳定性的关键能用确定性规则解决的就别把方向盘交给模型需要判断需要规划需要在不完整信息下做决策的再让模型上所以你会发现真正把Agent做稳的不是让模型更聪明而是让边排层更会管管节奏管状态管上下文管调用边界这一页讲边排层怎么设计我直接给你两把尺子自制度普戏和生产级印标准先说自制度一端是确定性工作流点罪LM你把流程写死LM只是某几个节点的能力差践比如分类摘药信息抽取优点是可预期好治理好审计另一端是LM驱动的动态规划目标给到它它自己拆解不准自己决定下一步调用哪个工具优点是覆盖复杂任务确点是鬼迹不稳定容易飘移工程上最常见的成功解法是混合式关键不准用硬规则掐口开放区域让模型发挥比如高风险动作必须嗨头或者必须通过Policy教验再说生产级框架的硬标准必须内建Opzevability而且要支持用硬规则治理不确定性没有可观测你就不知道它为什么这么做上线之后一旦KPI掉了你只能靠拆所以框架要能产出Traces和Logs美伦Problem的是什么模型选了哪个工具参数是什么工具反回是什么同时必须把模型的提议和系统的批准分开模型可以建议调用工具但是否执行必须由边排层用硬规则决定全线策略参数教验预算重视降级这也是为什么Google会强调像ADK这种CodeFest方式不是因为代码更酷而是因为在生产里你需要可控的行为编辑依旧化总结边排层的设计不是让Agent更自由而是让它在可观测可治理的前提下把自由用在真正有价值的地方上一单元我们说边排层是行为中书这一单元我们把它说的更值白一点Agent的本质其实就是Context window的测展系统谁把什么信息塞进去什么时候塞塞多少决定了它这轮能不能做对试后面我们就用两页把上下文长什么样和记忆怎么做工程化讲清楚我们先把上下文到底有什么构成说成一张工程清单一轮Agent调用LM你未进去的Context通常至少有6块第一块系统指令它是宪法定义人格编借输出格式以及什么时候必须用工具第二块用户输入这是任务的触发点但只靠它通常不够第三块Session History它让多轮对话有连续性尤其是需求成亲和约束变化第四块长期记忆注意它不是把所有历史都塞进来它是可招回的偏好事实决策记录暗虚取用第五块Grounding知识来自RIG搜索知识图谱等全未来源核心目的就一个先对其事实在开口第六块可用工具清单和工具结果工具清单告诉模型手里有什么工具结果告诉模型我刚刚做了什么拿回了什么你把这六块想清楚就能看懂为什么很多Agent的不稳定不是模型不行是上下文被卫成了一锅州模型的注意力被造成析试了Context Engineering做的就是把这一锅州做成一道道可复用的配菜接下来把记忆讲成工程上最关键的二分法短期和长期短期记忆本质是任务进行时的工作台它维护的是一条可追踪的训练Action ObservationAction Observation也就是我调用了哪个工具用了什么参数返回了什么关键结果这条训练让Agent不会在同一个任务里反复查同一件事也让你后面做trace和第8个有句可查长期记忆是跨会化的持久层它的工程实现通常不是把历史对话全文塞进promet更常见的做法是把长期记忆做成一个工具需要的时候通过iG连下量库或搜索把最相关的几条记忆招毁进来这带来两个直接收益第一个性化可以持续比如用户偏好历史决定以前确认过的规则第二上下文不会爆炸只在需要的时候取取最相关的那一点点你可以把短期记忆理解成rem把长期记忆理解成带减所能力的硬盘Agent要稳定就必须同时关好这两层短期保证任务不丢线长期保证体验能积累到第十个单元我们把话说得更架构一点很多团队做Agent的第一反应是堆能力更多工具更常上下文更复杂提示词最后做出来的往往是一个super agent看起来什么都能干但线上很难测很难改很难排账这一单元我们换个思路别造超人造团队把复杂任务拆成专家分工让系统可维护可扩展也更像生产级软件Multi agent的价值别被多这个字带跑偏它不是为了宣计而是为了把系统复杂度拆开单体super agent的最大的问题是所有不确定性堆在一起任务拆解信息减所内容生成质量检查和规审查全塞进同一条轨迹里你一改ProMpt可能把工具调用也改崩了你一换模型整个行为分布都表团队化的核心收益是3点第一聚焦每个 agent只做一种执能上下文更短工具面更小绝测空间更可控第二可测试你可以给每个专家 agent配自己的评测级和KPI比如resert agent指测招回质量Retr agent指测结构化输出Critic agent指测规则覆盖第三可维护线上出问题你能定位是哪一个角色除了问题而不是在一条长练路里忙拆所以从工程结果看Multi agent不是把问题变复杂它是把复杂度拆成模块把不确定性关进可知里的编借里接下来给大家一张选行地图四种最常用的鞋头模式你不用全做选对一个就能立刻提升系统上限第一类CodyNator它向项目经理先独动总目标再把紫任务路由给不同专家适合非线性任务信息不完整需要动态分解的时候第二类CQ它向流水线上流产出结构化中间键下游直接消费适合流程明确步骤固定一省机的业务练乳第三类Eterity Refinement这是质量优先的打法Generator先产出Critic and Rubric的挑问题再回到Generator Show大家看这张图就是典型的深层批判迪代回路它特别适合你更在意质量一致性而不是一次就完美第四类鞋头停顿点记住高风险动作不要迷信全自动该停就停比如对外发信改革护数据触发支付让系统在关键节点用确认工具把人拉进来这是生产系统的责任边界你把这四种模式理解成机幕CodeNator负责拆Sicuan Show负责跑Eterative Refinement负责变好Hitle负责杀车组合起来就是一套真正可交付的Multi agent工程形态到这里我们终于进入低一里最值钱的部分Agentops前面你可以把Agent做出来但Agentops决定你能不能把它上线长期跑还能越跑越稳这一单元我们就用Google的工程视角把不确定性变成可观测可评测可迪代的东西Agent的上线最大的问题不是功能不全而是你会突然发现你不知道它为什么这样做也不知道它什么时候会翻车大家看传统软件的单册逻辑很清楚输入固定输出应该等于预期但Agent的输出是概率分布同一个输入措辞会变步骤会变甚至工具调用顺序都会变你用Puzz or Fail去断言天然就不成立更麻烦的是Agent不是一次模型调用它是LM in a loop你改了一句话提示词可能影响的是第七轮的工具选择所以你要测的也不是最后一句话对不对而是整个轨迹质量是不是下降了这就是为什么Google把它单独叫Agentops它不是Devops的重秘名它是在Stochastic System上重新发明一套工程庇环Google给的落地方法很像一套生产流水线我把它总结成三段第一段KPI先行你先别摊模型多强你要定义什么叫更好像做AB实验一样比如目标达成绿用户满意度端道端实验单次交互成本最关键的是能应设到业务转化流纯营收工单关闭时长第二段用LMSGARG做质量评测你不能只靠线上KPI因为KPI不告诉你行为对不对所以你要做GoDenDataSat从真实交互里抽样覆盖主路径和边界案例然后用一个强模型按Rubric去打分是否遵循指令是否Grounded工具用的是否合理格式是否合规第三段MatchrixDriven development每次改ProMt换模型加工具都不是起导它更好而是跑一遍评测级分数上不去或者关键指标掉了这个版本就不允许上线上线也不是一件权量要用灰度或者AB把离线分数和线上指标一起对齐这三段加起来就是一个可复制的上线杂门让Agent迭代从手工是错变成可控工程最后一块是让你真正迅服Agent的两样武器Traces和反馈壁环大家看这张图核心是OpenTelamethrie TracesTrace不是用来看报表的它是用来回答一个问题为什么为什么它选了这个工具为什么参数这样甜为什么在第三步开始偏行有了高保证轨迹你才可能做LootCost第2个武器是人类反馈壁环线上一个ThumbsDone不是造生它是你平侧级缺失的证据正确做法是把这次失败复现出来沉电成新的平侧样力永久加入Golden DataSat下次你修Bug不只是修一次而是给系统打了一针疫苗避免同类问题再发生所以AgentOps的终局不是监控一下而是形成一个循环可观测定位原因平侧级固化经验指标驱动发布节奏这套循环一旦跑起来你的Agent才算进入生产成熟度到这一步我们其实已经默认一件事你不缺能跑的Agent你缺的是能接入生态的Agent这一单元只解决一个问题当你的Agent质量达标之后它怎么跟人鞋座怎么跟别的Agent鞋座以及怎么在交易场景里安全的鞋座我们按Google的三条主线来讲HumansAgentMani先讲Humans护操作的第一层其实不是协议而是交互形态升级最基础的是CatBalt人发请求Agent在后端跑完回一段文本但工程上很快就会卡住存文本不好做流程边排也不好做前端状态连动所以第二阶段是结构化输出让Agent输出这层这类结构化数据前端用它来炫染附UI这一步的意义是Agent不只是回复内容而是在驱动界面和流程在往后就是Compute Use也就是Agent把UI当成一种工具能导航业面点按钮甜表但通常要配合人类监督它解决的是遗留系统没有API的现实问题最后是Live Mode从文本走向实实多摩泰的双向流氏交互关键不是炫酷而是交互延迟和可打断能力让鞋座更接近真实工作流一句话收束人机护操作的眼睛路线是从说给你听走向帮你把界面和流程跑起来第二条线Agent and Agents当你企业里开始出现很多专用Agent的最大的风险不是重复造轮子而是连接方式失控每个团队鞋套私有机成最后变成一张脆弱的支柱网Google在daily把问题拆成两件事Discovery和communication第一怎么发现别的Agent他能干什么第二怎么通信确保双方说的是同一种任务语言ARAAgentRAgent就是为这个来的他允许Agent发布一张数字名片叫AgentCard本质是一个Jason说明能力范围网络端点以及交互需要的安全评据这样别的Agent才能标准发现你调用你通信方式也不是简单的request responseA2A面向的是Task一部任务科乎端Agent发起一个Task服务端Agent可以在常链接里持续回传进度更新这对长号时多步骤鞋座特别关键再强调一句Agent不是Tools连Tools解决的是交易型调用连Agent解决的是追加推理与鞋座一旦你把这两类混在一起致力模型会直接崩这一页的结论很硬没有A2A这类标准你就很难做出可扩长的level三多智能体生态第三条线Money这块很多人会低估但他是Agent走向真实世界的硬门砍原因很简单今天的互联网交易体系是给人涉及的人点击购买人承担责任但如果是Agent去点购买马上会引爆新任问题谁授权的授权编戒是什么出了是谁负责怎么审计怎么追责白皮书给了方向性的两类协议第一类是Agent Payments Protocol也就是AP2它的核心思想是用加密签名的Mandit也可以理解成可验证的授权委托它把用户意图变成不可抵赖的审计证据让Agent能在被授权的范围内安全交易第二类是HTTP402PaymentRequired的这条路线它更像基础设施层用标准HTTP予议支持机器对机器的暗磁付费比如为API或数字内容做微支付这里我给从业者的落地提醒只有一句当你设计能花钱能下单能调用机费资源的Agent时不要先想模型怎么谈判先把授权省计不可抵赖预算上限这些信任机制做出来否则你做出来的不是自动化是事故自动化这一单元我们把Agent从能用推到感用因为一旦它能查数据能改系统能花钱安全和治理就不是加分项它是你能不能上生产的一门砍做Agent的安全先把一句话课在墙上授权越大越有用但风险也同步放大风险主要就三类第一类是RogaActions也就是它自作主张做了不该做的动作比如误发邮件误改工单误出发流程而且很多动作是不可逆的第二类是敏感数据泄露Agent的上下文里会混合用户输入减所结果工具返回历史记忆只要有一段被它不该输出的内容泄露就是系统及事故第三类是Prompting Injection很多人把它当成提示词小技巧但在工程上它本质是指令被解除攻击者把恶意指令藏在网页文党邮件里你的Agent一减所一读取就可能把攻击指令当成更高优先级的任务去执行所以这一类的结论很硬不要把安全寄托在模型的自觉上要把安全写进系统结构里解决这类风险Google给的关键词是Defense In-Dapse也就是防御重生我建议你把它理解成两道门第一道门是确定性Guard Rails它是模型外的硬规则做策略卡口比如进额上线敏感操作必须二次确认某些API永远不允许调用参数必须过白鸣蛋教验它的价值就四个字可预期可审计第二道门是推理型防御也就是Guard Models它不替代硬规则而是补忙区因为很多风险是上下文相关的这次对话是不是在诱导月权这次工具调用意图是不是变形了这类问题硬规则很难写权但小模型或专用模型可以做实实判别和蓝节所以正确姿势不是二选一而是用硬规则定义底线用Guard Models覆盖灰区让Agent的能力变强但行为编辑更清晰当你从一个Agent走向一堆Agent安全就必须平台化不然很快就会出现Agent's Bro到处是Agent到处是工具连接没人说的亲谁能干什么平台化治理我给你三个落点第一Agent Identity把Agent当成新的principal而不是一段脚本它要有自己的可验证身份才能做最小全线哪个Agent能读CRM哪个Agent只能读不能写一刀切全线就是等着出事第二policy策略不是只管Agent本体要把约束覆盖到四类对象Agent Tooth其他Agent以及他能接触的Context你要能回答他能用哪些工具能掉用哪些下游Agent能读哪些记忆能把哪些信息对外输出第三Control Plane加Registry做一个统一入口所有交互都走这里人到AgentAgent到工具Agent到Agent入口负责健权授权审计可观测Registry则负责资产清单和生命周期发布前安全评审版本管理可复用发现结论很明确单体安全靠加兰干规模化安全靠修交通系统最后一个单元我们聊 deployment把话说很一点你只要还在本地跑得很开心但线上没人能稳定用你就还没交付 agent这一节我们用最工程化的方式把怎么上生产讲清楚做部署你先别纠结用什么产品先把交付目标对齐你要交付的是一个长期运行的服务第一安全包括身份全线数据编剑以及你能不能把访问控制审计流行接近来第二可扩展不是能不能跑起来而是流量一上来能不能扩流量一下去能不能降成本第三可访问不管是人来调用还是别的系统别的 agent来调你得有稳定的 end point和版本策略第四接入监控日治与管理这点决定你能不能运为没有 log 死你不知道发生了什么没有 matchricks你不知道好不好没有traces你不知道为什么所以 deployment 的本质不是上限是把 agent 变成可运营的产品能力Google 在白皮书里给了很清晰的两条路你可以理解成平台画和自建站大家看这张见面图这是平台画路径的点形形态用 VertexAI agent andion这类运行时你拿到的是一整套脱管能力运行服务化以及更容易接入监控治理它的优势是上手快少采坑适合你要快速把第一个 production agent 跑起来另一条路是容器化把 agent 和必要的服务打进刀可部署到 cloud 的软或 gk 翼优势是控制力强能跟你现有 DevOps 体系网络安全边界 深度融合代价也很明确你要自己负责更多的运为细节选哪条路不是信仰问题就看你是优先速度还是优先控制最后一夜我只强调一个现实 agent 上线之后变化才刚开始模型会升级工具会变更策略会收紧业务也会加需求没有 cicd 和自动化测试你每次改动都是一次线上堵脖所以生产机投入至少要两件事第一 cicd让构件部署灰度回滚变成流水线能力而不是靠人手点按钮第二自动化测试这里的测试不只是传统单策还要覆盖离线评测级关键 kpi以及对工具调用和安全策略的回归你把这套体系剑起来 agent才能做到持续迭代但风险可控好到这里我们把这第一本白皮书intro doxionto agents的从定义到生产完整走了一遍下一集我们讲第二本白皮书 agent to usinteroperabilitywith mcp我们下期见
