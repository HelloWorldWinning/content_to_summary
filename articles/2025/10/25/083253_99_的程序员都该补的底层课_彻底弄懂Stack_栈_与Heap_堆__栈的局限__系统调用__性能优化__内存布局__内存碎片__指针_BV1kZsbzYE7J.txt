Timestamp: 2025-10-25T08:32:53.497526
Title: 99%的程序员都该补的底层课：彻底弄懂Stack（栈）与Heap（堆） 栈的局限  系统调用  性能优化  内存布局  内存碎片  指针 BV1kZsbzYE7J
URL: https://b23.tv/kyYJDsx
Status: success
Duration: 18:38

Description:
好的，这是根据您提供的文本内容精心提炼的摘要、核心观点、框架和概念图。

### **核心思想摘要**

1.  **栈 (Stack) 的特性与局限**
    *   **核心特性**: 栈是一块紧凑、有序的内存区域，其内存在程序启动时已预先分配。这使得数据存取非常快速，因为它避免了运行时的系统调用。
    *   **两大局限**:
        1.  **大小固定**: 栈空间有限，存储大规模数据会导致“栈溢出”。
        2.  **数据静态**: 数据紧凑排列，无法在不覆盖其他数据的情况下动态调整大小（如向数组添加元素）。

2.  **堆 (Heap) 作为解决方案及其代价**
    *   **核心机制**: 堆是一块可根据需求动态扩展的内存区域。程序通过**系统调用 (System Call)** 向操作系统申请所需内存。
    *   **性能代价**: 系统调用开销巨大，因为它涉及到**上下文切换**——保存当前进程状态，让操作系统接管CPU，处理完请求后再恢复进程状态。这是堆内存“分配”过程慢的根本原因。
    *   **解决栈的局限**:
        1.  **大规模数据**: 将大数据存储在堆上，而在栈上仅保留一个固定大小的**指针 (Pointer)**（即内存地址）。
        2.  **动态大小数据**: 利用**数据结构**（如链表），在堆上为每个元素（节点）单独分配内存，通过指针将它们连接起来，从而实现动态增删，并有效利用堆中的碎片空间。

3.  **堆的管理挑战：碎片化**
    *   **不可预测性**: 与栈“后进先出”的有序操作不同，堆上任何位置的数据都可能在任何时间被释放。
    *   **外部碎片**: 频繁的分配和释放会导致堆中产生大量不连续的、细小的空闲内存区域（空洞）。这可能导致即使总空闲内存足够，也无法为一个较大的数据块找到连续的空间。
    *   **管理策略**: 为了尽可能利用这些空洞并减少系统调用，产生了不同的分配策略（如首次适应、最佳适应），但没有一种策略能完全避免碎片化。

4.  **对“堆”的正确认知**
    *   **“慢”在分配，而非访问**: 堆的性能瓶颈在于**内存分配**过程，一旦内存分配完成并获得指针，对其上数据的**访问速度**可以和栈一样快。
    *   **复杂性与风险**: 手动管理堆内存（如C++）比栈复杂得多，容易引发内存泄漏等错误。因此，负责任地使用并结合高效的数据结构至关重要。

---

### **核心观点**

堆通过动态内存分配解决了栈在容量和数据结构上的静态局限，但这种灵活性是以昂贵的系统调用开销和复杂的内存碎片管理为代价的。

---

### **内容框架**

本内容采用 **“问题 -> 解决方案 -> 挑战与权衡”** 的框架进行阐述：

1.  **提出问题 (Problem)**：明确指出栈内存的两个核心局限性——大小固定和数据静态。
2.  **引入方案 (Solution)**：介绍堆内存作为解决方案，并深入解释其底层工作原理，即通过高成本的“系统调用”实现动态分配。
3.  **分析挑战与权衡 (Challenges & Trade-offs)**：探讨堆方案带来的新问题——外部碎片化，并介绍相应的管理策略。最后，澄清关于堆性能的常见误解，强调其“分配慢、访问快”的特性，并点出其手动管理的复杂性。

---

### **Mermaid 概念图**

<Mermaid_Diagram>
graph TD
    subgraph "进程内存"
        A["栈 (Stack)"]
        B["堆 (Heap)"]
    end

    subgraph "栈 (Stack) 的世界"
        A -- "特性" --> A1["预分配, 访问快"]
        A -- "局限" --> A2{"大小固定 & 数据静态"}
        A2 -- "导致" --> A2a["栈溢出"]
        A2 -- "导致" --> A2b["无法动态扩容"]
    end

    subgraph "堆 (Heap) 的世界"
        B -- "特性" --> B1["动态分配"]
        B1 -- "依赖" --> C["系统调用"]
        C -- "请求" --> D["操作系统 (OS)"]
        C -- "引发" --> C1["上下文切换"]
        C1 -- "导致" --> C2["显著性能开销"]

        B -- "解决栈局限" --> S
        subgraph "解决方案"
            S[" "]
            A2a -- "存储大规模数据" --> S1["栈上存指针, 数据存堆上"]
            A2b -- "支持动态数据" --> S2["使用数据结构(如链表)"]
        end
        linkStyle 2 stroke-width:0px

        B -- "引入新挑战" --> B2["复杂的内存管理"]
        B2 -- "核心问题" --> B3["外部碎片化"]
        B2 -- "需要" --> B4["分配策略 (首次/最佳适应)"]
        B -- "性能误区澄清" --> B5["“分配”慢, “访问”快"]
        B2 -- "风险" --> B6["易出错(内存泄漏等)"]
    end

    style A fill:#ADD8E6,stroke:#333,stroke-width:2px
    style B fill:#90EE90,stroke:#333,stroke-width:2px
    style A1 fill:#E0FFE0,stroke:#006400,stroke-width:1px
    style A2 fill:#FFB6C1,stroke:#8B0000,stroke-width:2px
    style B1 fill:#E0FFE0,stroke:#006400,stroke-width:1px
    style S1 fill:#E0FFE0,stroke:#006400,stroke-width:1px
    style S2 fill:#E0FFE0,stroke:#006400,stroke-width:1px
    style C fill:#FFFACD,stroke:#333,stroke-width:1px
    style C2 fill:#FFCCCB,stroke:#8B0000,stroke-width:1px
    style D fill:#D3D3D3,stroke:#333,stroke-width:1px
    style B2 fill:#FFB6C1,stroke:#8B0000,stroke-width:2px
    style B3 fill:#FFCCCB,stroke:#8B0000,stroke-width:1px
    style B4 fill:#FFFACD,stroke:#333,stroke-width:1px
    style B5 fill:#F0E68C,stroke:#333,stroke-width:1px
    style B6 fill:#FFCCCB,stroke:#8B0000,stroke-width:1px
</Mermaid_Diagram>

Content:
在之前的视频里,我们学习了战,这是个用来紧凑有序存储数据的内存区域把数据放在战场能提升程序性能,但同时也存在局限性由于战场数据是紧凑存放的,我们无法容纳动态大小的数据比如,当我们要往数组添加元素时,很可能会覆盖战里存储的其他数值此外,战空间是有限制的这意味着,如果我们试图存放大规模数据,就会发生战役出本期视频我们就来探讨这些问题的解决方案Hi朋友们,我是George,这里是Cordumb的频道今天要讲的是,对内存这个,让程序员文风扫胆的内存区域,但他之所以存在,肯定有他的必要性给经验更丰富的老铁们提个醒,本视频内容为了便于理解做了适当检化如果你好奇我为什么要强调这点?我刚收到条评论,有人说我是菜机,因为我举例用八位无服号整数来表示年龄这位人兄觉得我的势力程序是对拉机,说未来某天,人类受命超过255岁的话,我的程序就会崩溃然后Hacker News上就会出现我的错误分析文最后连特工局长的六世孙都会来地死我的失败案例如果赞同这位的观点,那真的很遗憾,作为AI模型我还需要重新训练学习,才能理解你们这些马农神秘教派的古怪需求不开玩笑了,咱们继续视频内容老规矩,先来了解几个概念第一个是系统调用,出于历史原因,特别是安全因素考虑我们的程序不能直接操作电脑硬件这就是操作系统的存在意义当程序,需要硬件资源时,它来充当中间人分配这些资源是操作系统的责任拿Hello World程序举例可能你觉得这是最简单的程序了吧但屏幕上显示这两个单词的背后操作会让你大跌眼镜比如C语言的Printerf其实也是个普通寒暑它根据格式服务来格式化自负串顺便说下,寒暑名最后的F就是ForMat的意思但接着它会把格式化后的自负串,传给其他寒暑不同实现版本从这里开始会有所差异但追踪自负串流动你会发现最终它会进入Rite Hanzo,这是系统调用的一个封装这里系统调用会指示操作系统向标准输出流输入自负通常是中端窗口系统调用就是操作系统提供的应用程序接口我们通过它来请求只有操作系统才能完成的服务重点在于系统调用的性能开销其实相当可观程序开始执行后,它就被称为进程每个进程都有其运行状态底层实现上CPU通过技存器程序技术器等方式来维持进程状态不熟悉技存器的话可以把它看作CPU里的内置辨量它们本质上就是电路层面实现的硬件辨量有些技存器通用性强,用途广泛有些则是专位特定功能设计的因为这些技存器存储的数值会随着进程运行不断变化我们可以说技存器集合成在了我们进程的状态当我们的进程进行系统调用时会向操作系统发出请求而因为操作系统本身也是软件它需要使用CPU来处理这个请求但操作系统不能简单的直接使用CPU因为这会影响我们的进程正在使用的技存器正在改变它的状态由于我们不希望丢失程序在系统调用前一刻的状态因此需要保存这个状态有点像拍了张快照这些信息被称为进程的直行上下文并且需要存储在内存中一变之后可以检索一旦操作系统完成了系统调用的处理保存当前进程的状态然后加载不同进程的状态以便它继续执行这个过程被称为上下文切换上下文切换会带来开销因为保存和恢复执行上下文需要时间和资源请注意除了上下文切换的成本之外操作系统处理系统调用本身也需要时间这意味着还有更多开销好吧但我们为什么要关心这个正如你可能猜到的每当进程需要向操作系统请求内存时就需要一次系统调用在我之前的视频中我提到占很快的原因之一是其所有内存都在程序之心开始时预分配了因此没有必要及时向操作系统请求内存为了减化在那个视频中我没有解释为什么请求内存如此昂贵但现在你知道了因为它需要系统调用极其相关的开销让我们明确区分进程使用的内存区域通过编异我们的代码被翻译成二进制机器码一组需要在程序启动时加载到内存的指令因此指定一片区域专门存储这些指令是有意的通常这片区域被称为文本段此外我们指定一个特定区域来存储以出实化和未出实化的权局和静态数据然后是占一个组织的语言后是占一个我们已经熟悉的概念请注意这些区域都有一个共同点他们的大小是固定的别让占混销了你顺便说一句占的大小永远不会改变改变的是占中存储的数据量最后我们定义一个可以根据需要扩展的特殊内存区域这个区域被称为堆与占不同堆的大小可以通过系统调用动态调整这就是我们所知的静成内存布局一个典型C加加静成的内存布局是这样的但我认为这种布局有点难以解释所以让我们保持简单此外由于屏幕尺寸和为了让动画更容易理解接下来的视频中我将这样展示占和堆非常重要的一点是当我们通过系统调用请求内存时操作系统的响应并不是恰好给我们需要的内存量而是给我们一个内存块这种行为会产生一些影响我们稍后会讨论我们可以根据需要申请任意数量的内存块这让堆上能分配的内存量几乎变得无限而这正让堆内存完美的解决了占的限制问题我们要解决的第一个限制就是占无法存储大量数据的问题我们可以利用这个视识内存的每一个字节都能通过地址来访问既然地址本质上是数值我们就能用整数来表示他们这个整数大小在编异时就能确定我们不再直接往站上压数据而是在堆上存储这些数据而之后在站上我们只存放这些数据在堆上的内存地址在底层与严重表示内存地址的数值通常被叫做指针这个名字非常直观明了同样重要的一点是指针指表示内存地址并不包含指向数据长度或大小的信息因此负责管理并追踪堆内各内存子区域区分哪些政备占用哪些是空闲的是我们自己的责任在当前例子中在堆上存储数据之后我们有一个以使用的子区域和两个可用的子区域值得注意的是堆上存储数据并不总是需要申请额外内存这就体现了操作系统返回内存块的作用如果有足够的空闲内存来自之前的分配我们就能直接把值写在那这种情况下就无需额外的系统调用现在我们有两一使用的子区域和三个可用的子区域如果你看过我之前的视频你现在可能开始担心碎片问题了如果你还不熟悉这个概念我来给你说明一下假设我们现在想在数损里存十个八位无服号整数也就是十字节的长度问题是虽然堆上总共有十五个空闲字节但他们不连续所以这个数损放不下这个问题被称作外部碎片这种场景下唯一能放下数损的方法就是向操作系统申请更多内存块但要这么做我们的程序就得付出一笔系统调用的代价可以通过尽量紧凑的存储数据来避免碎片这个例子中如果我们提前规划好数据存放方式根本用不着内肆系统调用诈看一下似乎在堆上要避免碎片把所有职进可能紧凑的存放就够了不幸的是在堆内存上并不是这么回事注意这个部分我接下来要说的内容理解战和堆根本区别的关键战场只有最后一个被推入的职能被移除这种可预测的规律保证了战场的数据总是紧凑排列所以战场根本不可能出现碎片对的问题就在于它的操作方式完全不可预测即使我们努力让数据紧凑存储但不像战的根本无法确定数据被移除的顺序为了理解这点我们来看一个服务器应用场景这个服务器的主要功能是接收客户端传来的图像处理成黑白效果后再返回给客户端这个服务器要能同时处理多个客户端请求在开发初期开发者都不确定客户端会发送多大的图片这正是他们开始思考的地方为了防止因接收过大图片导致潜在的一出而这些图片可能无法在战场存储决定将这些接收到的图片存储在堆上当服务器部署时六个客户端同时向服务器发送请求服务器生成六个工作现成来处理每个客户端的请求再从客户端接收图像后每个现成以紧凑的方式将图像存储在堆上但由于不同客户端发送的图像尺寸存在差异处理时间也会不同教小的图像处理起来更快一旦这些教小的图像处理完成服务器像相应的客户端做出响应后为这些请求分配的内存就无需要了允许这些内存端再次空闲正如你所见堆中的任何纸都可能在任何时候被移除这使得我们无法向组织战内啊以可预测的方式来组织数据堆上的碎片化的确是不可避免的但现在我们明白了堆中到处都是这些空洞因此尽可能利用他们是合理的每当我们需要在堆上为某纸分配空间时应检查这些空洞中是否有足够大的因为如果存在这样的空洞我们就可以避免调用系统调用所设计的开销现在我们需要确定使用这些空洞建习或可用区域中的哪一个有三种常见的选择策略选择第一个足够大的空洞来容纳我们的纸选择最小但足够容纳我们的纸的空洞或选择我们的纸可以逆合的最大可用空洞请注意这三种策略都无法避免碎片化在他们之间做选择取决于几个因素首次你和通常更快但在减少碎片方面并不是最理想的最佳你和和最差你和可以在某些情况下减少碎片但他们可能不如首次你和快无论我们选择哪种策略都需要在各种因素之间进行全衡为了完成本视频的这一部分我们来整理一下目前所学的内容我们将定义两个寒树Loc和FreeAloc寒树接受一个参数N表示我们想存储在堆上的纸的字节大小我们要存储在堆上的纸的在寒树内部Aloc将使用我们讨论过的一些策略来定位堆中的一个至少N字节大小的子区域如果找不到合适的子区域Aloc将调用一个系统调用向操作系统请求更多内存一旦找到所需的空间Aloc会更新管理堆状态的数据结构并返回一个指向所分配区域的纸征当不再需要以分配的内存时我们使用Free寒树它接收区域的纸征并在表中搜索将其标记为再次可用此外如果释放的紫区域与另一个空闲子区域相铃Free负责合并这两个子区域现在如果你觉得这些信息太多好消息是你通常不需要自己手动实现这些例如在C家家中这些功能已经在标准库中实现了当你需要使用堆史仅需包含该库并开始使用其寒树就这样我们已经解决了站的一个局限性如果值太大无法存储在站上我们将其存储在堆上而在站上我们只维护对该值的引用我们仍需解决一个局限性动态大小的值正如视频开头提到的因为站中的所有内容都是紧致的值不能在未复改其他值的情况下随意扩大或缩小有人在评论区问我为什么不能直接提取所需的数据调整我们感兴趣数值的大小然后再把数据推回去嗯这的确可行但仔细想想的话这样做就需要分配额外的内存来临时存储这些数据然后再把他们推回到站上这个过程很可能需要系统调用来申请额外的内存就算不需要系统调用内存中的数据考备也会耗费额外时间到了那个时候站就不再那么快了最逗的是对本身也无法解决这个问题在对上存储数据可能在添加元素时人会设计覆盖其他值类似于站中的情况这种场景下我们的解决方案是数据结构最简单的选择是练表由于纸征大小固定且在编议时以知他们可以作为站中自定一类型的成员使用我们保留指向第一个节点的纸征对中存储的每个节点都包含一个元素以及指向下一个节点的纸征当我们需添加一个元素时我们在对上为新节点分配内存并确保练表的最后一个元素指向新节点这个新节点变成了新的最后一个节点这就完了练表解决问题我们不需要大量连续内存事实上他们利用了对上出现的空气练表确实有缺点其中一个缺点是节点分散在整个堆上导致缓存命众的概率降低如果我们想保持练表的紧凑性我们需要的是一个数组练表在低级编程与严重通常称为项量数组练表的实现值得单独开个视频讲所以这里我们就不细说了反正视频已经够长了我们直接进入最后部分吧对为什么这么让人害怕对的管理原比战复杂的多战中存储值相对简单因为有战指真的存在相比之下对的运行方式很不同在堆中搜索可用子区域是一个耗识的过程而且最坏的情况下可能没有足够的可用子区域这迫使我们必须通过系统调用来申请内存导致显著的性能损失本质上过多堆上的分配可以显著拖慢我们的程序但这还不是全部由于其特性手动操作堆容易出错在像C加加这样的语言中关于手动内存管理有一堆常见错误这些错误对高阶开发者来说是隐藏的因为有拉机回收机制保护他们在下一集里我们会详细用动画演示这些错误最后我想澄清一下对如果负责任的使用的话可以是你最好的搭档当你听到有人说堆很慢时这是很有无导性的所以对啊我标题党了慢的是堆上分配内存的整个过程但一旦你得到那块内存后如果你足够聪明牢记缓存等概念你就可以选择一个好的数据结构对堆上内存的访问可以像站一样快本次内容就到这里如果你喜欢视频记得点赞如果你还想了解更多记得订阅哦我目前正在制作几个视频顺便说一下如果你想建议或投票选出我接下来应该讲哪些主题记得在Twitter上关注我还有不到两个月的时间我们已经突破了一万一千名订阅者所以非常感谢大家
