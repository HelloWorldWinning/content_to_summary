Timestamp: 2025-10-30T07:42:52.483851
Title: 在Python中用多线程之前，需要先搞懂这些
URL: https://youtube.com/watch?v=mkR15E-iI1A&si=44cY6LqGdi3yVcFf
Status: success
Duration: 11:26

Description:
好的，这是根据您提供的文本内容提炼的核心思想摘要。

### **核心思想摘要**

#### **一、 多线程的核心理念：提升效率**
*   **1.1. 单线程的瓶颈**：在执行如网络下载等I/O密集型任务时，单线程程序会让CPU在等待数据期间处于闲置状态，造成大量时间浪费，效率低下。
*   **1.2. 多线程的优势**：通过创建多个线程，CPU可以在一个线程等待I/O时，立即切换到另一个可执行的线程上工作，从而实现任务的并发处理，使多个等待过程“同时”进行，最终大幅缩短程序的总运行时间。

#### **二、 Python多线程的实现方法**
*   **2.1. 基础方法 (`threading`模块)**
    *   **三步曲**：① 创建`Thread`对象，指定目标函数(`target`)和参数(`args`) → ② 调用`.start()`方法启动线程 → ③ 调用`.join()`方法等待子线程执行完毕。
    *   **关键概念**：必须使用`.join()`来让主线程等待子线程，否则主线程会继续执行，导致程序逻辑和输出顺序混乱。
*   **2.2. 现代化方法：线程池 (`concurrent.futures.ThreadPoolExecutor`)**
    *   **优势**：避免为海量任务频繁创建和销毁线程带来的开销，通过复用固定数量的线程来提升性能和资源管理效率。
    *   **实现**：通常结合`with`上下文管理器和`.map()`方法，以更简洁、高效的方式批量提交和管理任务。

#### **三、 并发编程模型的选择**
*   **3.1. I/O密集型任务 (IO-bound)**：如网络请求、文件读写。这类任务大部分时间在等待，适合使用**多线程**或**协程**来加速。协程因其更小的切换开销而通常被认为是更优选。
*   **3.2. CPU密集型任务 (CPU-bound)**：如科学计算、图像处理。这类任务需要大量CPU算力，应使用**多进程**来充分利用多核CPU的并行计算能力。

#### **四、 Python多线程的特殊性与未来：GIL**
*   **4.1. GIL (全局解释器锁)**：这是CPython解释器的一个特性，它限制了同一进程中任何时候都只有一个线程能执行Python字节码。这使得Python的多线程在CPU密集型任务上无法实现真正的并行计算，性能提升有限。
*   **4.2. 无GIL的未来**：实验性的Python 3.14版本提供了“无GIL”模式。测试表明，在该模式下，多线程执行CPU密集型任务时性能得到数倍提升。
    *   **注意**：移除GIL改变了Python的内存管理等底层机制，目前阶段尚不建议用于生产环境。

---
### **核心结论 (一句话)**
多线程通过让CPU在任务等待期间切换工作，实现了并发执行，是解决I/O密集型任务效率瓶颈的关键技术，而现代化的线程池是其在Python中推荐的实现方式。

---
### **内容整体框架**
本文的论述框架遵循“**问题提出 → 解决方案 → 实现优化 → 场景对比 → 未来展望**”的逻辑脉络：
1.  **问题提出**：以单线程下载图片的低效为例，引出CPU资源浪费的问题。
2.  **解决方案**：介绍多线程作为核心解决方案，解释其并发执行的原理。
3.  **实现优化**：从基础的`threading`模块手动管理，演进到更高效、更现代的`concurrent.futures`线程池模式。
4.  **场景对比**：将多线程置于更广阔的并发编程视野中，与多进程、协程进行比较，明确各自的最佳适用场景（I/O密集型 vs. CPU密集型）。
5.  **未来展望**：深入探讨影响Python多线程性能的GIL瓶颈，并介绍“无GIL”版本带来的性能突破及其当前阶段的局限性。

---
### **概念关系图 (Mermaid)**
<Mermaid_Diagram>
graph TD
    subgraph "核心问题与解决方案"
        A["单线程模式"] -- "处理I/O任务时" --> B["CPU等待/闲置"];
        B --> C["效率低下"];
        D["多线程"] -- "核心思想" --> E["CPU在任务间切换"];
        E -- "实现" --> F["并发执行"];
        F --> G["显著提升效率"];
        C -- "需要解决" --> D;
    end

    subgraph "Python实现方式"
        H["实现方法"]
        subgraph "基础: 'threading'模块"
            I["1. 创建 Thread 对象"]
            J["2. 调用 .start()"]
            K["3. 调用 .join() 等待"]
        end
        subgraph "现代: 'concurrent.futures'"
            L["线程池 ThreadPoolExecutor"] -- "通过 'with' 管理" --> M["使用 .map() 提交任务"];
        end
        H --> I --> J --> K;
        H -- "更推荐" --> L;
    end

    D -- "如何实现" --> H;

    subgraph "并发模型场景选择"
        O["任务类型"]
        P["I/O密集型\n(网络下载, 文件读写)"]
        Q["CPU密集型\n(科学计算, 视频编码)"]
        O --> P;
        O --> Q;
        P -- "推荐使用" --> R["协程 / 多线程"];
        Q -- "推荐使用" --> S["多进程"];
    end

    D -- "适用场景?" --> O;

    subgraph "Python的限制与未来"
        T["GIL (全局解释器锁)"] -- "导致" --> U["多线程无法利用多核并行计算"];
        U -- "主要影响" --> Q;
        V["无GIL Python (实验性)"] -- "移除GIL后" --> W["CPU密集型任务性能大增"];
        W -- "代表" --> X["未来发展方向"];
        T -- "正在被解决" --> V;
        S -- "不受GIL影响, 但受限于" --> T;
    end

    style A fill:#FFB6C1,stroke:#A52A2A,stroke-width:2px
    style C fill:#DC143C,stroke:#333,stroke-width:2px
    style D fill:#98FB98,stroke:#006400,stroke-width:2px
    style G fill:#3CB371,stroke:#333,stroke-width:2px
    style H fill:#ADD8E6,stroke:#4682B4,stroke-width:1px
    style L fill:#87CEEB,stroke:#4682B4,stroke-width:2px
    style O fill:#F0E68C,stroke:#BDB76B,stroke-width:1px
    style Q fill:#F4A460,stroke:#8B4513,stroke-width:1px
    style P fill:#F4A460,stroke:#8B4513,stroke-width:1px
    style T fill:#DDA0DD,stroke:#800080,stroke-width:1px
    style V fill:#BA55D3,stroke:#4B0082,stroke-width:2px
</Mermaid_Diagram>

Content:
当我们从网上接在图片实际上会发生两件事一是向网站发送请求二是等待网站发出片在这个过程中只有第一件事需要CPU干活第二件事CPU支持在旁边休息什么也不干那如果我们要现在很多图片CPU就会重复这个流程最后算下来休息的时间远比干活的时间多得多而你尊贵的CPU的主人看到CPU这样休息很时心痛想要炸干CPU这就是使用多线程的时候线程是CPU执行任务的基本单位刚刚的例子就是我们的程序在单线程运行的样子完成了一个任务才会开始下一个任务而如果我们使用多线程来处理这个程序当CPU发现现在任务不需要自己了不会休息而转移到别的任务上继续干整个流程耗比的时间大大减少我们来看一个具体的代码例子这是一个用来携带图片的简单程序我通过记录程序的开始时间和结束时间来测量这个程序以后会花多久这个韩数模拟了现在图片里面的Sleep 1模拟了现在图片时需要等待的时间通过FOR讯悬我们来P掉下来图片以后会寻找案5次所以我们会下载5张图片最后将这个程序所耗费的时间打印出来运行一下看看这个程序会花多久你可能也能猜到它会花5秒钟因为它是单线程的只有完成了前一个任务才会做下一个任务同样的功能我使用多线程也是线了你现在暂时不用关心我具体是怎么实现的我们先跑跑看结果看看结果有什么差别跑一下可以看到只花飞了1秒钟这样的结果是符合我们刚刚的模型的因为CPU在不同的任务之间切换让每一个次下载的1秒钟是一起等待的而不是先等待一个再等待另一个接下来我们就看看具体怎么改写从原来的单线程代码改写为多线程代码多线程的要点程简单主要就是三部创建线程开始线程结束线程想要创建线程我们需要使用Dradding Cool里面的Drad是它的名称也能看出来的就是一个线程对象然后在这里创建线程对象把我自动不全了我们可以看到Drad的对象它有两个参数一个是Target XArtsTarget说明这个线程要做什么任务你说我们传说一个韩数RArts说明完成这个任务所需要的参数也就是这个韩数所需要的参数它需要一个URL这样我们就定义好了一个线程我们再多定一几个线程顿便是Target XArts完成了第一步创建线程接下来是开始线程开始线程我们只需要调用Drad对象的Star方法就可以了同样给Target XArts也开始这样我们就完成了第二步开始线程还剩最后一部结束线程但在结束线程之前我想先给你看一件奇妙的事情我们如果不结束线程会怎么样呢难道这个线程就不会结束吗其实也不是我们运行看看可以看到很奇怪明明是放在程序最后的一句话反而在最开始打引出来了接著才是我们定义好的Target XArts的结果这是为什么呢首先要知道线程它会分为主线程和紫线程的区别我们这个程序就是一个主线程就是你运行的那个程序它就是主线程而我们在这个程序里面所定义的线程叫做紫线程也就是Target XArts是紫线程当我们不在主线程中等待紫线程完成主线程是不会等待紫线程完成而是继续运行所以这就导致当运行到这一行的时候主线程继续往下运行直到打引出最后的打引一句而紫线程在主线程已经打完这一行一句之后还在继续运行于是就有了我们现在的结果所以我们还需要刚刚说的结束线程其实是等待线程结束我们可以通过Droid对象的装饮调查这样子就完成了运行看看它应该就是只花费了一秒没错就是只花费了一秒这样子虽然有用但老实说这样子手动一个一个碰箭然后一个一个开始一个个结束挺顺的你可能会想到我们可以用Forex还来批量的创建确实是可以的就像这样子我们创建一个列表来存放创建的阶层然后使用Forex还接著我们再对这个列表来便利它等待它结束我们也运行一下这个交文结果应该是一样的确实也是一样就是一秒钟但这种协法它其实并不现代这样的协法我们对每个人物都创建了一个线程那如果任务量比较大可能有1万个或者更多那我们不可能创建1万个线程吧这种情况我们可以说1万个任务我们大概只创建几十个线程然后这些线程我们循环使用这种循环使用固定数量线程的模式叫做线程池我们可以通过拍放的concarton的Code来创建线程池删掉原本的代码删掉right我们来使用concarton使用这个Code的Builders然后我们来创建一个线程池通过Wid而Wid是拍放了一个特性叫做上下文管理器我在之前的一期视频中提到过使用Wid创建一个线程池也要帮我自动不全我就用它写的这个吧然后这里要注意一下the red blue executor它有一个max workers参数这个参数就是我们刚刚提到的这个线程池中它可以有多少个线程这里写设定了是10所以说这个线程池它最多只能有10个线程在工作但其实这个参数就算我们自己不填拍放也会自己选择一个合适的参数填进去那么我一般其实是不填的接著我们调用这个excoder的map方法这个map其实跟拍放内置的那个map 盘数差不多它的第一个参数是一个盘数然后第二个参数会作为第一个参数的参数传进去听起来有点复杂其实就是说Range10的话就是把从0到9这10个值分别作为download image的参数传进去这样子它返回的会是我们的线程结果我们来写一个reveiled等于这个但我们这个韩书不返回结果所以我想把这里的prin改成written这样子我们再打印一下reveiled里面的东西好我们跑一下看看可以看到跟刚刚的结果是一样的就是差1.01秒diamar部分就先到此为止再提升程序效率方面还有两个概念常常会和多线程一起提到一个是多进程一个是斜程他们的使用场景不太一样那我们的任务大部分时间用在CPU的计算是比如说训练模型图像处理是平边把肩膀这种任务叫做CPU密集型任务通常是用多进程来加速因为多进程可以其动多个CPU核心来加速计算而当我们这任务其实没做太多计算大部分时间是用在书书书书比如说读写文件网络下载的这种任务叫做IOMID型任务通常用写程来加速我之前有过专门的一期视频写上我写程它的本质其实就是运行在单线程上的一个循环机制那么这次的主角单线程它的使用场景是什么在排访的3.4之前多进程的地位其实很尴尬它在IOMID型任务的表现不如写成因为写程没有现成切换的开销而CPU密集型任务多进程又几乎完全没有用但是在排访3.14之后多进程也可以用在CPU密集型任务了因为在最新的排访3.14种提供了一个没有GIO的版本GIO的全名是Globo Interpreter Locke让同一时间只能有一个现成访问排访解释器这意味著即使我们的程序使用了多现成也只是现成在交替运行不会有两个现成同时运行的时候这样的好处在于使用者不用玩心多现存同时访问同一个内存的情况这种情况叫现成竞争会发生很可怕的事情这确定也很明显效率不够高所以许多人对GIO生物痛诀在最新的排访3.14种有两个排访版本一个是依然有GIO的一个是已经没有GIO的接下来我们将通过一个代码来看看有GIO和没有GIO的排访3.14能给时间上带来怎样的变化我准备了一个CPU密集型任务让我们分别用这两个版本的排访来泡泡看首先我们先使用没有GIO的新版本泡泡看可以看到指花费了0.07秒非常快然后我们再使用普通版本的3.14泡泡看花费了0.24秒这个差距还是满明显的差不多有快4倍的差距虽然说速度上却是去掉了GIO可以更快但是去掉GIO其实改变了很多排访的底层预先机制比如说引用技术、垃圾回收的所以你的生产代码在目前这个时候并不是和一个转去用没有GIO的版本具体没有GIO让排访的引用技术和垃圾回收发生了什么样的变化呢我在这支星球中提到过感兴趣的话可以加入的支星球最后我们来快速总结一下多谢仁可以让你的程序同时开始多了任务CPU可以在他们之间交替执行速暖运行时间通过排访的Duradin Cool我们可以管理现成但更什么样的方式是通过Concar Cool使用现成池没有GIOPingron的CPU密集性任务上也是用多现成但现在不一定还是最好的选择如果你有任何疑问或者意见可以去下面评论区留言如果觉得这个视频有帮助请帮我点个赞或者分享给任何你任务有需要的人感谢你的观看我们下次再见
