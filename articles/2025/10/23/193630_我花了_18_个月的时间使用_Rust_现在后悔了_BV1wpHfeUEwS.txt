Timestamp: 2025-10-23T19:36:30.281150
Title: 我花了 18 个月的时间使用 Rust，现在后悔了 BV1wpHfeUEwS
URL: https://b23.tv/XLinciF
Status: success
Duration: 38:35

Description:
好的，这是对所提供文本内容的深度提炼与总结。

### **一、核心观点概要**

这份内容是对一篇“开发者用 Rust 重构项目后深感后悔”文章的实时评论与深度剖析。评论者并非简单地赞同或反对，而是借此探讨了 Rust 语言的内在矛盾：其强大的性能与安全优势，与极高的学习门槛和独特的编程范式之间的冲突。

评论者引入了 **“成功之坑”（Pit of Success）** 的概念来解释这一现象。他认为，Rust 的“成功之坑”过浅，意味着开发者很难像使用其他语言那样，凭直觉或通用编程经验就“自然地”写出正确、地道的代码。相反，开发者需要投入大量时间刻意练习，并彻底转变思维模式（摆脱所谓的“动态语言大脑”），才能真正驾驭它。因此，文章作者的挫败感，虽然部分源于“技能问题”（Skill Issue），但更深层次地暴露了 Rust 在开发者体验和学习曲线方面的固有挑战。

---

### **二、内容结构化分析**

**1. 事件起因：对 Rust 的强烈批评**
*   **背景**：一位开发者耗时18个月，用 Rust 重构其算法交易平台后，发表文章表达了极大的悔恨和失望。
*   **核心抱怨点**：
    *   **语法与语义**：极其冗长、复杂且不直观，尤其是在结合异步（Async）、生命周期（Lifetimes）和 Trait 时，会产生像 `Pin<Box<dyn Future>>` 这样令人望而生畏的类型签名。
    *   **错误处理**：机制糟糕，当错误发生时，很难获得清晰的堆栈跟踪来定位问题根源，`?` 操作符的便利性反而导致错误上下文容易丢失。
    *   **社区文化**：呈“邪教”化趋势，对于批评和疑问，社区成员倾向于用“这是你的技能问题”来回应，缺乏建设性。
    *   **开发效率**：严格的编译器和语言复杂性严重拖慢了开发迭代速度，与其带来的性能优势不成正比。

**2. 评论者的辩证剖析**
*   **承认“技能问题”，但点明其背后逻辑**：
    *   **思维定式**：评论者指出，文章作者试图将 JavaScript 等动态语言中的抽象模式（如封装异步辅助函数）生硬地套用在 Rust 上，这是导致挫败感的主要技术原因。Rust 要求开发者遵循其独特的所有权和生命周期规则，而不是通用模式。
    *   **学习曲线的陡峭性**：Rust 的学习不是线性的。掌握了所有权和借用检查后，生命周期、泛型，尤其是异步编程，是三个层层递进的巨大门槛，当它们结合在一起时，难度呈指数级增长。
*   **对具体批评的回应与补充**：
    *   **错误处理**：评论者同意 `?` 操作符易被滥用，导致错误处理被推迟到调用栈的顶层，从而丢失关键信息。他建议使用 `anyhow` 这类库来添加上下文，或者通过设置环境变量 `RUST_BACKTRACE=1` 来获取堆栈信息，但这恰恰说明了原生体验的不足。
    *   **社区问题**：评论者部分认同社区（尤其是一些领导角色）存在不友好的情况，但他也强调不应以偏概全，并希望能将其他社区（如PHP）的友好氛围引入。
*   **引入核心概念：“成功之坑”**：
    *   一个设计优秀的系统应该让用户轻易地做出正确的选择（即“掉入成功之坑”）。
    *   评论者认为 Rust 在这方面做得不够好，其设计使得开发者需要不断摸索、重构，才能找到正确的路径，而非自然而然地抵达。

---

### **三、 overarching Framework：内容的辩证框架**

该内容采用 **“正-反-合”** 的辩证框架：
1.  **正（Thesis）**：直接呈现文章作者对 Rust 的激烈批评和负面体验。
2.  **反（Antithesis）**：评论者并未全盘接受，而是深入分析这些批评，指出其中的“技能问题”和思维模式错位，同时为 Rust 的某些设计进行辩护，并补充了解决方案。
3.  **合（Synthesis）**：最终，评论者将双方观点融合，得出一个更深刻的结论——这些问题的根源在于 Rust 的核心设计哲学，即为了极致的性能与安全，在学习曲线和开发者体验上做出了巨大妥协，形成了一个“浅浅的成功之坑”。

---

### **四、核心要点一句话总结**

Rust 的强大性能与安全保障是以极陡峭的学习曲线和苛刻的编程范式为代价的，这使得开发者若未完全掌握其核心理念，极易陷入困境与挫败感之中。

---

### **五、概念关系图 (Mermaid Conceptual Map)**

<Mermaid_Diagram>
graph TD
    subgraph "事件背景: 开发者困境"
        A["耗时18个月用Rust重构算法交易平台"] --> B["充满悔恨"];
    end

    subgraph "文章作者的核心批评"
        B -- "引出" --> C1["冗长复杂的语法"];
        B -- "引出" --> C2["糟糕的错误处理"];
        B -- "引出" --> C3["不友好的社区"];
        B -- "引出" --> C4["开发效率低下"];
    end

    C1 --> D1["异步(Async)与生命周期噩梦"];
    C2 --> D2["缺乏堆栈跟踪, 上下文丢失"];
    C3 --> D3["“技能问题”式回应"];
    C4 --> D4["严格的编译器成为阻碍"];

    subgraph "评论者的深度剖析 (正反论证)"
        E["“技能问题” Skill Issue"]
        C1 -- "部分归因于" --> E;
        C2 -- "部分归因于" --> E;

        F["“动态语言大脑”的思维定式"] -- "导致" --> C1;
        G["‘?’操作符的便利陷阱"] -- "导致" --> C2;
        H["社区文化确实存在问题"] -- "证实" --> C3;

        E -- "是现象, 但非本质" --> I{"Rust的核心挑战"};
    end

    subgraph "最终结论: Rust的设计哲学与代价"
        I --> J["Rust的“成功之坑”过浅"];
        J -- "意味着" --> K["开发者不易“自然”写出好代码"];
        K -- "要求" --> L["极高的学习成本与刻意练习"];
        L --> M["强大的性能安全以牺牲开发体验为代价"];
    end

    style A fill:#E6E6FA,stroke:#333,stroke-width:2px
    style B fill:#FFB6C1,stroke:#B22222,stroke-width:2px
    style C1 fill:#FFDAB9,stroke:#333,stroke-width:1px
    style C2 fill:#FFDAB9,stroke:#333,stroke-width:1px
    style C3 fill:#FFDAB9,stroke:#333,stroke-width:1px
    style C4 fill:#FFDAB9,stroke:#333,stroke-width:1px
    style D1 fill:#FFE4E1,stroke:#333,stroke-width:1px
    style D2 fill:#FFE4E1,stroke:#333,stroke-width:1px
    style D3 fill:#FFE4E1,stroke:#333,stroke-width:1px
    style D4 fill:#FFE4E1,stroke:#333,stroke-width:1px
    style E fill:#ADD8E6,stroke:#4682B4,stroke-width:2px
    style I fill:#ADD8E6,stroke:#4682B4,stroke-width:2px
    style J fill:#90EE90,stroke:#2E8B57,stroke-width:2px
    style M fill:#98FB98,stroke:#2E8B57,stroke-width:2px
    linkStyle 1 stroke:#B22222,stroke-width:2px;
    linkStyle 2 stroke:#B22222,stroke-width:2px;
    linkStyle 3 stroke:#B22222,stroke-width:2px;
    linkStyle 4 stroke:#B22222,stroke-width:2px;
</Mermaid_Diagram>

Content:
I spent 18 months rebuilding my algorithmic trading platform in Rust. I'm filled with regret. I would love it if this article was like, I'm filled with regret for not doing it sooner. Like, how funny would that be? Alright, Austin Starks, take us on a wild ride. I was a young, hopeful, rust fanatic. On paper, rust seat... Okay, this is not seeming very pro-rest. This is not pro-rest at all. On paper, rust seemed like the programming language designed by the gods. Not only is it the fastest programming language out there, it's also one of the safest. Well, technically it's really hard for rust to actually be the fastest language out there. It's very easy for it to be not fast. In fact, it's quite optimized to be not fast and due to the safety. But hey, C++ is not faster. C is not faster. None of the languages are faster. Anything that's at the tippy-topped. Just remember, right? The top of the performance pyramid is going to be filled with managed memory language. So you got rust, you got C, you got zig, you got C++. I'm sure there's other ones. Nim might fall in there. But the reality is the reason why rust often goes from the fastest to the next level is because you use things like RCs, ARCs, and mutices to effectively get around rust. Right? Or more so, clone. Yeah, I guess Odin would be in here as well. So this is like a very typical... This is like the typical problem here. Right? People don't use ARCs and C++. I mean, you use ARCs if you use shared pointers in C++. And if you look at the bottom of the pyramid, you find a snake and a big yellow square. Go-laying falls into these two categories, right? Go as fast. Once you have runtime managed memory, which is RCs and ARCs, it's no longer fast. You fall down into garbage collected. I put a heavy emphasis on garbage collected because there's not garbage collector, but you are no longer managing your own memory. You are letting something else manage your memory. Java doesn't exist, it's just a fantasy. It is. Where did Java hurt you? I'm not alone in thinking rust was this perfect language. If you read about rust programming language online, you'll likely encounter overwhelmingly positive opinions. Every guide on medium, every post on Reddit, every answer on Stack Overflow, everything is glowing. I can't wait to catch a bullet by this. I feel like I'm about to catch a bullet by rust. Given this, I decided to migrate away from TypeScript, rewrite my entire open source algorithmic trading system in rust. I gave rust a neutral rating before. I take that back. Dang. Dang. Okay, I really hope that we get some really good ones. Right? I hope we get something really good here. By the way, if you're doing algorithmic trading, I would assume you'd want to be able to react really, really fast. So I could see you using a very, I could see why rust would be a natural decision. Typically, you don't want to do algorithmic trading in slower garbage collected language because a couple hundred milliseconds could cost you the trade. Right? Just real talk. That it makes sense why you'd want to use something that's better than TypeScript. I wrote my X, let's see, I wrote about my experience with rust four months ago. In my last article, I concluded that while I really like the speed and some aspects of the language design, such as Enums and strong typing, I didn't really love the language. What you're discovering is that you don't in love in post safety. That's what you're discovering. My article is met with harsh criticism on Reddit, including one highly upvoted comment that accused me of chat GPTing to write my article. Dang. This is a lot of upvotes for something that literally isn't true. I don't use chat GPT to write any of my blogs. I just simply don't. I hate how it sounds. This is just how I write. Nowadays, I don't even use chat GPT to correct my writing. This is genuinely my writing style. Dude, I'm right there with you. I actually tried to use chat GPT to help me with some stuff and it just became very frustrating. It became very, very frustration. But if he is a robot, ooh, ooh. Anyways, after posting, I had thought that I'd given that I didn't give Rust a fair shot. Maybe I was just naive or came in with misplaced expectations. Now after working with the language for a little while longer, I can confidently make one conclusion. The language absolutely fucking sucks. I think the language is great. So maybe I'm not that intense, but dude, this is funny. But I've always said I think Rust has this. Rust feels better than it is because when you're solving a black box problem, it's like really, really easy. It's really, really great. He can still turn it around. He can still turn it around. There's some things that make Rust really good at. I love it for basic command line operations along with marrying that with some file reads, transforms and stuff. It's really good for that. What I despise about Rust, I want, let's see, if you want to find an article about what's right with Rust, look literally anywhere on the internet. You'll be hard pressed to find anything less than neutral about the language. This article will be focused, uh, focused rant about what I despise about this crabby language. All right, let's see if we can, let's see if we can figure this out. Horrendous verbose unintuitive syntax and semantics. Yes, when you get into this level, this is what I always say. The moment you start getting into this world, this is where things start getting like good Rust becomes shitty really quick. Like really like once you like when you hit into like a dude, a pinbox dying future is crazy. Like this is crazy. It's a Haskell dressed up as sea like language to trick normies. This cause this exact same problem. Yeah, that's due to async. I know I've always said async is where things just get all f'd up. In the moment you get into async land and you try to do something that's really clever. Dude, every single time. What is, what is this? Okay. So send, send means it can cross. It can go across, it can go across, um, hazing boundaries, correct? And then, uh, plus, uh, tick underscore means the unnamed lifetime. If I'm not mistaken. This is where I start breaking down to is once we start getting into this world, this means it can cross async boundaries and it could, uh, and it has a lifetime that you don't need to, um, that we're not mentioning, right? So that means the function that you're passing in F is a mutable function that takes in the client session that returns a future at some point in the world that return that can be crossed over the boundaries and has an output of R where R is send and static. Async is very hard. It's very, very hard. Yeah. So I'm going to get what I'm looking at here. I generally get what I'm looking at. It's just that once you get into this world, it is. It's just super hard. Like generally speaking, it's very, it gets very, very hard. All right. So all of this looks pretty good. All of this looks pretty good. None of this looks like, see, the rest of this looks pretty good, right? I would say that everything else in here just looks pretty straight, straight forward, right? Anybody who ever said that rust doesn't have a trosity, some atrocious semantics is lying to your face. I see the thing is, I think one thing that's really nice though that you're kind of, you're kind of missing is the fact that you can go operation session await. If it's okay, we do this. If it's not okay, we do that. Like I think this is actually really nice. Right. I think that this is a really nice thing. And then you have a for loop. You have all of this. It actually reads really nice. Like this part, this is what I'm talking about when rust looks really good is this right here. This is really nice rust. And there's a lot going on here that is actually shockingly crazy, right? You have to start a session which awaits something. You have to start a transaction. What's awaits something? You then have to do this operation and match on the airs. And if you get the air, then you will turn out the result else. You're going to go max retry as exceeded. This is really, this is nice code. It's this part right up here that just gets so effed up. This part gets so effed up. There are certain things where if you don't have access to an extremely powerful large language model, then writing the function becomes literally impossible. I don't want to spend 90 minutes figuring out why where clause in my run transaction fund. Let's see, figuring out the where clause in my run transaction. Yeah, the where clause has become exceedingly frustrating. I'm on your team. And if you define your generics in the wrong place, run clauses can be super frustrating. Like they can become super, super frustrating. That's why I like a language like OCaml, though having an exceptionally similar type system gets away with a lot is because it's garbage collected. It can just simply drop some of these difficulties. And that's that. Yeah, the large language model is an interesting is a very interesting call out saying unless if I have access to this, I to me, it says you just need to understand more about rust internally for you to be able to do this. And so this is that language curve. You know, I jokingly made that video where I said rust learning curve is like this. Once you hit async, it's non differentiable. It's because this like skill issues here. The problem is that the borrow checker when you're learning is like a steep. It's like an upright curve. And then you get it. And that's it. Once you get the borrow checker, it's easy. But then when you add in lifetimes, it's like another's just upright curve. And then when you add in async, it's like just such it like goes, it goes off the table and it becomes so hard because it's it's it's just really difficult when you marry all the concepts of lifetimes of traits and of async. When you put these all three together, now you get this whole problem that's really, really difficult and it is most certainly a skill issue. It's most certainly a skill issue, but it's a very excessive and difficult skill issue. So the rust curve is the Debian logo. Exactly. Right. My God, the curve is non functional. In the end, I had to abandon the idea of a helper function entirely. Yeah. So again, this is just that's because you're writing it the not rust way. Don't write a helper function. Can we all agree? This is one of those things that I always made a problem of is that in JavaScript, you abstract out these similar functionalities across async operations in Rust. You don't want to do that because you will find that you hate your life. You do you find that you hate your life and it sucks a whole bunch because you do this and you just you have to like be okay with code duplication at some level or you have to be a genuine master of rust or just given to Arc mutex. Arc mutex makes it very easy. Oh, I read that one. Okay. You say he's also making it complicated by using a Mongo transaction. I'm not sure if that's true. A lot of people want to use. By the way, this code girl, I can see your experience is showing right here. Wrong duplication is better than wrong abstraction. Absolutely. Hands down 100% correct because you can always fix an abstraction. You can always or you can always fix code duplication with abstraction. Very hard to fix it. It fix abstraction. By the way, I forgot what else. Oh, no, my cam died. My cam died. It actually wasn't my camera. It's my, it's my, what do you call them? My HDMI converter. Hold on. Almost there. Almost there. Whoopsies. Hold on. Hold on. There we go. I blame Karen. I thought it was my Linux. Nope. There we go. You're moving again. There we go. There we go. All right. In the end, I had to abandon the idea of a helper function entirely because I litter, I quit literally couldn't get the code to compile. Yeah. I mean, dude, I've made this mistake a lot with Rust and I feel like you make the same mistake with Zig as well. I think the problem, I truly think the problem here is what I would like to refer to as JavaScript brain. JavaScript brain or really dynamic language brain, dynamic language brain says abstract on all forms of code duplication. And so you kind of adopt this without realizing it. You adopt it really quickly. And also a big problem about dynamic programming along with structural programming such as Go is that you adopt structural patterns and you think a certain way. You think you think in interfaces. And again, Rust does not necessarily make traits easy and Zig, they don't even have traits. They don't even have traits. They don't even have them at all. And so it makes things really hard. What's the meme with like the four people talking about like talking about something in those last guy that's like, you guys have interfaces? What's that meme called? Dry is overrated and people overuse the concept. Absolutely. They use it constantly and it is very, very dangerous. I've been it's true. I've been coding and see 89 lately and I find my J.S. brain really leads me into the wrong in into some bad places. Yeah. What is it called? We are the millers. Oh, yeah. This one, this one, this one. Only along the lines of like JavaScript, uh, TypeScript interfaces are great, right? Go laying it's something, something along like the lines of go laying structural. I'm sure there's Python. There's some sort of, there's some, I'd have to think about this more, but this is happening. I got to think about, I got to think about this still. I know there's a joke in there. So we'll just make this, we'll make the quick and easy joke, which I'll just grab the first one, right? I know sometimes it broke cooked for nothing. I know there's something, there's something there's something there's something there. Something there that's really good. And I don't know what it is. Zig draft shit post. It's a draft. There's definitely something there that's really good. It's just going to take too long to think about. And so we say move on. Okay. This is not what it looks like. When people claim as Russ biggest strength, a stretch compiler to eliminate errors is one of Russ biggest flaws. Just, uh, just give me the garbage collector and let me do what I want to do. We'll talk. This is real. This is absolutely real. Russ biggest strength is also its biggest weakness, which is also very reflective of all other ones. JavaScript's biggest strength is the fact that you can just add a property to anything. JavaScript's biggest weaknesses, you could just add a property to anything, right? Like that, that's, it's the, every language has the exact same problem, right? In contrast, if I were writing this exact same function and go, it would look like something like this. Well, go is actually really great though. And go gives you the abstraction ability of TypeScript with the, with the 99% speed of rust. It's, it's, it's very impressive. Uh, run transaction, do all this one. Yeah. Yeah. Start a client session. There we go. Defer session and yup. Do all this thing. Grab all that good stuff. Do this one. Yup. This is all looking good. Grab all this stuff. Oh yeah. Oh yeah. Oh yeah. Oh yeah. Oh yeah. Oh yeah. Oh yeah. Oh yeah. Do the returns. So easy to read and understand. It really is easy to read and understand. And all the people, I see a bunch of people saying, if air equals nil, blah, blah, blah, if we were to do this in TypeScript, one, two, three, four, five of those would be hidden errors in which you would not know you need to catch or not. So you would just get randomly borked. Whereas at least in go, I know when I'm about to get borked and I can handle it. Okay. So come on, don't even try that with me. Don't come on. While the core of the function remains relatively the same, you don't have to do backflips to figure out how to make the day code work. It just works. Agreed. Horrendous air handling. Oh, that's interesting. I would kind of argue my only problem. I will say this about rust. One of its big problems is that due to the question mark operator, you defer a ton of air handling really easily. The convenience of not handling an error is so easy that I often find I think less about errors and I often find myself oopsie-dazing. It's skill issue, skill issue, fair, please, please. It's a skill issue. But nonetheless, I find it so convenient that I forget to like really think about how I should handle this. Rust does have some very nice things with errors as long as you avoid unsafe unwraps. Oh, yeah. You can, you can be a damn sure that at the code will run and keep running. No point errors exceptions and unhandled errors just don't happen anymore. Yay, right? Wrong. Because when your data is wrong or something unexpected happens, you'll be fighting to figure out what the hell happened. Maybe I'm just an idiot and can't figure out how to enable stack traces. But when an error happens in my application, I have no idea why. Well, I mean, back, back trace equals one, right? Rust underscore back trace equals one. Am I incorrect on that one? I don't think so, right? Right? Definitely some skill issues on that one. For prod, why not? I mean, if you're going to have exceptions, why not? Why not have a trace? Assuming that you've that you handled 99% of your exceptions or your errors and this one you couldn't handle, why not? Like I totally get when you have one and you handle it, you don't need a stack trace, right? By the way, this also would be largely this. This also is very, very nice to consider with asserts, right? Running a bunch of simulations and asserts and ensuring that you can't have these kind of things. You can really figure out a lot of your application before you actually have it running with actual money doing trading. You know what I mean? I still use X errors and percent W for stack traces and go. See, I haven't used X, X errors. I just still use errors and pretty much do rap stacks still, right? In contrast, I actually like goes handling, right? I like the fact that you don't have stack traces instead. You just build your own stack and I build my own stack and so I get all the relevant bits in where the error happened and I actually find it to be really nice. Like generally speaking, I find it to be very nice. In contrast with the language like Python, you get these beautiful art-like stack traces that tell you exactly what happened down to the line number. Even in Go, you have errors wrap. Yep, which enable you to look at the entire error stack in your application, which is only the places you're really concerned about, which is also nice. Perhaps I'm a goddamn idiot because when I encounter an air and rust, I'm like, I'm in Lala land trying to figure out what happened to the to the or what happened. Wait, trying to figure out what the hell happened. Well, I could not read that again. I'm going to say it again. The question mark operator due to the extreme convenience of it all, I think leads more people down this. There's this concept. There's a very important concept in programming that you need to internalize, which is called the pit of success. You want to make it so that doing the right thing is so easy that people just fall into the right move and that's one of the problems with rust extremely convenient air handling is that a lot of people just question mark out the errors really quickly. And so you end up handling an error like 10 functions higher with absolutely no indication into where this air happened. And I see this a lot. I see this quite a bit. I'm not saying that if air is better, if air equals nil is better, but at least you have to think about it a little bit more holistically in go, even though it's more boilerplate. You have to think about it. You have to wrap it. You have to add context. It's also why I like anyhow. I can add context at every level. And by adding context at every level, I get go like air handling, but with the convenience of rust, right? A diner is just crazy. Don't do diner. A diner is nuts. Anyhow, this error friends. Yeah. I need this e-print LN littered throughout my application. In fact, no, I'm not an idiot. This is a flawed language design. I think this is just again, I think he's just when you use rust, you don't fall into the pit of success. And by not being in the pit of success, I think it's very easy to blame the tool as opposed to the knowledge of it. And remember, I'm not at this point, I am not a rust lover. I am not a rust lover. I think it has a lot of things going forward, but I actually think that Zig is significantly better. I think it gives you the right amount of safety with giving you the right amount of control over your program. I think it's the best of both worlds. And I would say that this right here is definitely much more of a skill issue that's very obvious. Like, you goofed up. You goofed up. Hey, dude, it took me like a year to really, really, really, really, really, really, really, took me like a year to really get a good grasp on errors in rust, like to really understand a nice way to handle rust. It took a long, it, oopsie daisies, it took a long time. And so I definitely don't blame that at all. Criving community, hot take the rust community isn't as nice and cool as they pretend to be. Absolutely. Rust community is probably, I would say the least friendly. Zig might be the least friendly community, but then rust is right afterwards. I think JavaScript and TypeScript generally have a pretty friendly community. All right, like, I can shit. Well, okay, PHP has the nicest community. We can all agree to that. Anyone that disagrees that PHP is not the nicest community, I would like to, I would like to mention Adam Elmore and Aaron Francis. Okay. You can't, you cannot beat Adam Elmore and Aaron Francis as the nicest people in the universe. Yeah, PHP is a very nice, they're super, super nice, very, very nice community. And I would like, the reason why I'm going to Laravel is that I, or Lara Khan is that I am obsessed with how well and how good their community is. And I want to learn from it. I want to bring it in. I want to bring it to the mainstream software world where we can stop, like, where we can actually be a lot better. Like even notice this, I'm not like, I'm not dunking on this guy. I'm not being mean to him. I'm saying, Hey, this is a really natural conclusion. I think a lot of people run into. I'm fully on his team. I'm trying to like, I'm trying to bring the goodness of that PHP community outside because I think it's really healthy and I'd love to see more of it. And I agree fully. I think the Rust community specifically in the more leadership roles are some of the meanest people I've ever interacted with in my entire lifetime. Like absolutely the meanest people. It is shocking. It is shocking how much of their superiority. Now there's some good ones. I can think of, uh, uh, gosh, what's it? It's shepherd something shepherd. Um, gosh, why I do it. I can see his name. Dude, his name is like Derp Shepherd or Derp something. Derp shadow. Gosh, why can't I remember his name? Really a Shep master. Uh, dude, uh, Derp. Yeah, Derp really nice guy. Shepherds, awases, shepherds, awases. There you go. I actually think he's a really nice guy and he's an exceptionally talented person, like outrageously talented and still like communicates in a really nice way. Like I actually think that just genuinely a huge amount of, uh, huge amount of, uh, respect for the guy, right? Absolutely. Huge amount of respect. Uh, all right, because MongoDB is shitty. MongoDB is not a real database. It's a key value dock stored and no squeal storage system that literally to the dying from, uh, for marketing metrics. It didn't even provide support for asset or transactions till more recently. And for the longest time, it just blindly corrupted your data due to its poor cue to write design. There are better databases. Don't make rust look bad for using MongoDB. I mean, this is actually just terrible advice. I mean, really the thing that he was struggling with is having helper functions, which is typically I find to be very difficult for doing a retry over some async operation. Right. You could generalize this to retry over async operation. And Mongo not going to make it for sure. Mongo not going to make it, but this response is wild. Right. Um, but again, I'd also like to say that random response on the internet is not reflective of the community. So just remember this that I don't think, you know what I mean? Someone just said something and it's very, very true. I think generally speaking, when I, when I think of, when I think of the Rust community, I think of, I, I just come back to this picture often and I can't, I can't undo it. Cause once I, once it's in the, once it's in the brain, it's just stuck there. It's just stuck there forever. I'd really love to see a turnaround in the community and be a little bit more approachable. Uh, for example, I asked the question on the Rust subreddit, how to improve error handling with MongoDB Rust great. My answer range from switch to Postgres. Why am I using MongoDB at all? MongoDB is bad and go and Python too. And actually helpful suggestion to improve error messages. Okay. That's good. That's good. I do. I always find this strange. When somebody asks a question, how do I handle this situation better? I've always found it such a strange answer to be like used Postgres. Like I will say that to DAX or to TJ, but I would never say that to an Internet random person. You know what I mean? That's, that just feels weird. Uh, there is no other programming community that's as cult-like as Rust. They ignore all the giant glaring flaws with the language. Uh, like it's crazy learning curve, verbosity, horrible error messages, crazy syntax and questionable language design choices. They'd rather say it's a skill issue when the develop, uh, with the developer. That's insane to me. I do think you're, you're definitely having some level of skill issues. I think one of the hardest parts about about writing in different languages is adopting the mindset of that specific language. And it's very, very hard. And so I'd revisit this maybe a bit more. Like I'm on board with you that I don't think Rust fits all situations, but I think that, uh, horrible design choices. I actually think a lot of the design choices are really good. I think there's a lot of really cool things like, dude, impel, impel, uh, uh, what's it called? Impel, uh, from and try from is like one of my favorite things of all time. Yeah, he's doing it solo with no mentor. Yeah. That's very, very hard. Impel from an impel try from is probably my favorite, uh, design feature of all time. It's so good. It's like shockingly good. I, I wish more languages had, um, that I just like shadowing, uh, in Rust a lot. Funny, you know, it's funny. You should say that because I was on your team. I thought shadowing in Rust was like such a bad idea. And now I love shadowing in Rust. And the reason being, um, and the reason being, I have an example somewhere, uh, here, I can just search the word maybe. There we go. I always am like, Hey, get an index of something. If it equals null, I want to just return this back out. But if it doesn't equal null, I want to like unwrap that null. Cause I just, I generally hate indenting. I try not to indent. Uh, so I'm not going to have the inverse of this, which is capture grouping, uh, and then getting out of it. And so I, I wish I could, I really wish I could just do this. Right. Like I actually wish I could shadow. I think shadowing is really, really nice. I actually really do like shadowing now that I understand it before I didn't like it, even when I used it and I did understand it. That's kind of a dick phrase to say. I did understand it, but I just didn't now that I've used enough times, I actually really, really like this. Right. What is shadowing? Just what I just did right there. This right here is a maybe you size. This right here is a you size. So you a shadow is to change its type. I'm going to change its type from option, you size to you size. You can use or else. Yeah. Yeah. I mean, those are things that, you know, this is me. This is like, this is like some of my first zig I ever wrote. I know there's better ways. I know there is like an or else something, something, something. I haven't quite got there yet. Right. I'm still learning all the things, you know, I, you know, I like to, um, I like to write a language in a way that's familiar with me, how to handle it. And then as I get better, I like to try to get better at it. You know, I like to kind of like, like, as you can see right here, I'm kind of getting good at the catching. Right. I'm getting there. I'm getting there. Just please. Let me, let me get there. I'm getting there slowly, though. I do agree with you. I do agree with you that I guess I could do something along the lines of. Oh, whoopsies. I just realized that I was yanking the whole wrong thing. Whoa, whoa, whoa, whoa, whoa, whoa, that was crazy. So you're saying I can go or else return null. Right. That's really, really nice. Thank you. I know I was the ink and wrong. Very, very beautiful. Like these things, like this again, Zig has some really nice operations here. This is very, very nice. But again, what's the use case of shadowing? When you wish to change a variable type, but keep the same name, right? Very, very nice. All right. Final words with all this being said, Rust has some pros. It's fast and well, that's mainly at no, no, no, no, no, no, no. Multi-threaded programming. I find to be generally speaking, multi-threaded programming and Rust is pretty enjoyable. Just multi-threading itself. Of course, I cheat with our commutex and or clone. Forgive me. But if you clone and or arc mutex, async is really not that bad. There's plenty of reasons to actually really like it. Erz's values, I think generally is a good way to go. But if you're trying to get maximum performance and async, I find it very difficult. I do like the idea of having the reminder of like, hey, you can't have this like here's a good example. If you use channels with go, there's like these four rules of channels that just make it super, super hard to work with. And I hate it. Whereas when you work with channels with Rust, because it has an optional type, it actually makes it really, really easy to use a channel. You can't get stuck in a whole set of things. And this just genuinely makes async programming significantly nicer, just like at an entire level. I can't remember that. Let's see the four bad things about go laying channels, right? There's like the four things you got to know. I know there's one, whatever. I don't even want to. I don't even want to look for it. We're not even going to look for it. But there's like these four rules of things that are very, very annoying. And Rust just doesn't have it due to the options. That means you can like, here's one thing. If you return a nil through a channel, you close the channel. If I'm not mistaken, whereas with Rust, because you have options, you can have effectively some null, right? You can say, Hey, this is this is empty. There's like there's a bunch of stuff. A closed channel is only you're mistaken. I'm afraid I'm going to stake it on that one. Okay. My bad. My bad. I'm so I don't use channels a lot. I thought there was like no nils reading from a nil channel. Panic. Yes, reading from a nil panic, uh, nills and, uh, going and channels. I thought there was a whole way. Okay. Yeah. I know there's like a whole bunch to it. Like I said, I'm not great at go. I use almost all my go has no channels except for a couple and I find channels to be really great, but I know that Rust had a really nice, it has really nice ways to know what to do here. Okay. Let's look at this. The accident channel send, uh, to, uh, let's see, a send to a nil channel blocks forever. Like that sucks. Can we all agree that this is bad? That's one really nice part about Rust is that it just returns an error and says, Hey, channel use of closed channel. It's very, very nice. Um, receive from a nil channel blocks forever. It can't you get around this by doing a receive with two arguments? Can't you? You can get around that by doing a, uh, a, like a receive with, uh, X and done, right? Can't you get around that now with that? So isn't that, isn't that axiom kind of, uh, generally dead? Yeah, not as okay. Yeah, yeah, yeah, yeah. It's the valo K pattern. Yeah, that's I didn't, I didn't want to write all this stuff. You know what I mean? Um, let's see, send to a closed channel panics also again. Um, that's pretty reasonable. Uh, I'd rather have it return an error though. The weird part is that go makes such usage of errors. I'm surprised that they didn't just send an air, uh, an air back, right? I feel like the usage, a channel two would be really nice if they had errors and stuff. And then what's that receive from a closed channel returns the zero value immediately. This is a course because they don't have options. Right. So again, if you had an option, you can tell that a channel is closed because it returns a none, right? That means there was nothing there as opposed to something that's empty, which is very, very different. Right. So an option would be really, really nice. And so I would prefer that over this. I knew there were some, there's some quirkiness, right? And so I find that this one is like a very, I find this one to be very difficult. Yeah, you can always use val. Okay. You can always use val. Okay. And that, that should be used. You should use val. Okay. It's just, I would rather have an option type that makes sense. And so what I find that is when I read from a channel, so I do this thing, I forget where I do it, but I do, I do a thing where I check for, um, I check for results and how I check for results is that what I do is, uh, what is it? Is that I do a, like a function call, like a function get. I'm way too zoomed in and I'll do like a select and then I'll do it like a poll. From X and then I'll also do like a default return return return something, right? And so that way I have like a default return and this and that way I do it's like a non blocking quick value select. And I know this is like a, this is some level of a pattern. Anyways, I found, you know, this article, this article is skill issues, but I think I think the thing that you have to, um, you have to pull from this. Is that just because there's skill issues doesn't mean there's not real issues as well. I think the pit of success with rust is a bit shallow. I think it's very easy to do the wrong thing. And that's why I think it's pretty universally agreed that with rust, people find that they build something, they refactor it, they build it new. They refactor it. They build it again. They refactor it, right? And they find themselves in this constant refactoring thing because they're not, it's very hard to write it right the first time or even write it good enough the first time. And so I find that it's just that rust doesn't doesn't have the same ability to just fall into the, into the correct way. At least that's my general perception of it. I think if I wrote it all the time, I could, I could fall into the right way very easily. I think that if I just had enough, uh, just had enough reps, I think rust would be very easy. At all points, including in the async world. But I think because I don't have enough reps, I don't do it 40, 50, 60 hours a week. I don't fall into that. There you go. The pit of skill issues. It's a pit of skill issues more than anything else. Russ is fun with this rust less practical. Sure. I guess it's also safe to if we compare it to C++, it's obviously the better language. Um, I do feel like that's also again, I think that this just when I when I hear this phrase, what I hear is that you're either comparing it to C++ 11 and below. Or B, you've never really done C++ and you heard it's, you heard it's stupid. And so therefore you kind of like dunk on it. You know, if you use unique pointers or shared pointers and everything, you, you generally, it's pretty easy to do the right thing and go. I mean, in C++, it's more verbose than I like. Can we all agree? It's more verbose than we like, but generally speaking, long as you do, long as you stick to a certain things, it's pretty easy. And then of course, there's also like all the crazy operation overloads, uh, and, and the weird crazy copy constructors, the L values are about. There's some, there's some hard parts that I think take a long time to learn to master C++ is like mastering rust. I'd rather have my application to take a few dozen milliseconds longer to run if it means my development time is cut in half, which is an interesting trade off to make for an algorithmic trading. Because our algorithmic trading, I would assume a few dozen milliseconds can be impactful. On the bright side, if we choose to write my application in go, I'd also probably have some regret. What if it could be faster? I'd think to myself, there's yet another article about how rust is the best thing since sliced bread. Oh geez, I made a mistake. At least the, I mean, article FOMO influencer FOMO is real. Like real talk, influ, influ, influencer FOMO is super real. By the way, I did build an arbitrage across across different trades for cryptos. And we used Bellman's Ford's maximum flow problem to detect multi leg arbitrage. And it was pretty sweet. I made some money, but the biggest problem is I just didn't have $10 million to put in or I literally could have made. An incredible amount of money back in the day when there were such inefficiencies in the market. At the very least, now that I know rust, I feel like I can learn anything. Maybe I'll pick up OCaml for the hell of it. It can't be much worse than rust, can it? OCaml's great, but I think you're going to run into things that you dislike about OCaml equally, but probably less. I spent this whole weekend fixing it's just milliseconds performance. Dude, people do that. You can learn anything. Just put in the time. You can learn anything. You really can. Thank you for reading. If you're interested in algorithm trading and AI, subscribe to Aurora's insights. Want to see how fast rust really is? A create accounts on Nexus trade. Today. Interesting. Let's see what the comments are. Oh, are there any comments? I was wondering if there's comments. Let's check out some comments. I completely lost it in the low IQ article. Damn. Damn. Dude, it's so much nicer to say the word skill issues. Dude, I do like this. Well, Cornell, I went to see a meme. I am a gem fellow. And I'm a software engineer making six figures. What about me is low IQ, wingy face? You know, you don't need to judge yourself a little, little, little word, little word from the experienced. You know what? Instead of that, I'll just show you. Go to YouTube. Go to the prime engine. I have a short that I thought was very, very good, which I tried to make it as obvious as possible. I have a short that I thought was really, really good. Right. Right here. We're not going to listen to it. Nope. Nope. And the comments are just man, discover asserts. Then we call this defensive program. That sounds like strong typing with extra steps, right? Like they completely miss what asserts are about and they say a bunch of stuff. So instead, in 20 years, just imagine what else this guy hasn't figured out. So instead you just don't, you just don't respond. Sound like you sound like a loser. You just don't respond because honestly, it's easier and I'm okay with that. And I try, I try just never to respond. Because I'm just like, man, you know, it just, it just makes you feel shitty. And then they, then they're like trying to talk to do it. It's just like I ain't about it. Uh, that's still, let's see, that's still a not rust. That's just MongoDB crate you're complaining about, brother. It's really funny. You're supposed to write your own errors and overload the source methods for the stack trace. Anyhow, does a good job. Dot context. Uh, you can't blame rust for you choosing the wrong language for your use case. If you didn't care about compile time safety and needed faster iteration, you should have, uh, you should have known to use language like go or Python instead. The problem is is that you can say these things, but often personally, I don't know those things until I do them and I get burnt by them. Right? Cause you can, you can generalize this advice to a whole bunch of you should have, right? You ought to have known. And I find that I don't know until I have goofed up several times. You know what I mean? And I think that that is really, really, really, really obvious only when you're on the other side, prime wants to agree and disagree. Same time. Exactly. No, I, I do. I do want to agree because it is correct, but it's so hard to tell somebody that, you know, you don't know until you know, like, you know, I, I've known about asserts for so long. I've seen them in code for so long. I never used them. Then all of a sudden I used them and I really understood them. Now I can't stop using them. Right? Like you could not have explained it to me until someone named Jorin, the Tiger Beetle, uh, database guy gave such an impressive presentation. I said, I must be missing something. I will figure this out. And now that I have now I have been love it despite the fact that I've known about them for like a decade. Oh, you too. After Tiger Beetle. Yeah, it's just one of those things that's like, it's super hard to explain something until you've experienced it, programming the negative space article. Yeah, it's, it's good. It's very hard. You know, you should explore and you should use technologies incorrectly because you will never know why to use them correctly. Performance matters. Uh, standards, uh, standard. Let's see. Oh, for high frequency trading. Yeah. Standard algal bots that do crypto, not so much. Okay. Okay. You should see the FPG and algos that are nanoseconds sensitive. Yeah. You're talking about like Jane Street, O camel on stuff. Dude, it's crazy. But in this space for almost a decade and there are some wild stuff out there, Russ go, et cetera, are not even considered where big money is. Yeah. Isn't it like just you're burning FPGAs? I know that when it comes to forex exchange, it's our forex. It's all about, it's all about FPGAs and nanoseconds. Sleep the beast. Thank you very much for the five gifted subs. Appreciate that. Anyways, sure. Children learn by exploring. Yeah. And I think that's we shouldn't discredit exploring. We really should be very careful about that. Don't don't. I think it is good insights in the sense that the pit of success is extremely hard to fall into with rust. And I think that if you're going to do rust, you got to learn the language really, really well to be effective. And that is a huge danger to most people is learning the language extremely well before jumping in. So before you rewrite your stuff, maybe spend six months really learning the language, read through the book. Understand about allocations, read through the async book, understand that, practice pin, pin project, all that crap. And then once you get it all done, then maybe, you know, it can be better. Anyways, the name. Is the prime engine. I don't know why I slapped my ball. I honestly have no idea why the ball slapping just happened.
