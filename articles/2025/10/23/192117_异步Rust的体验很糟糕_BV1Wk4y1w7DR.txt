Timestamp: 2025-10-23T19:21:17.650989
Title: 异步Rust的体验很糟糕 BV1Wk4y1w7DR
URL: https://b23.tv/a2CaTp4
Status: success
Duration: 32:28

Description:
好的，这是对所提供文本内容的深度提炼与结构化总结。

### **核心思想摘要**

#### **引言：文章核心论点**
文章以《一部 Rust 是一门糟糕的语言》为题，深入探讨了 Rust 的 `async/await` 异步编程模型。作者并非全盘否定 Rust，而是**精确地批评 `async` Rust 在解决大规模并发问题时，因其底层设计哲学与异步编程的动态天性存在根本性冲突，从而导致了极高的复杂性和诸多实践痛点**。

---

### **一、 性能优化的需求：并发与并行**
为了让代码运行得更快，现代编程需要解决两个核心问题，这催生了对并发与并行的需求。

*   **并行性 (Parallelism)**：在多个CPU核心上**同时**运行代码，旨在提高整体吞吐量（多个人一起干活）。
*   **并发性 (Concurrency)**：将任务分解为可独立运行的部分，以提高资源利用率，**允许**不同部分交替或同时执行（合理安排工作流程以实现高效）。
*   **关系**：通常先进行并发设计（任务分解），再利用并行能力（多核执行）来加速。

### **二、 并发模型的演进与挑战**
文章回顾了解决并发问题的几种历史模型及其优缺点。

1.  **多进程模型**：
    *   **优点**：由操作系统调度，进程间内存隔离，安全性高。
    *   **缺点**：进程间通信（IPC）开销巨大，因为数据需要在内核空间进行复制。
2.  **多线程模型（共享内存）**：
    *   **优点**：线程共享内存，通信开销远小于进程。
    *   **缺点**：被称为“危险的游戏”，极易引发**竞态条件、死锁**等难以调试的问题，需要依赖互斥锁（Mutex）、条件变量等复杂机制来保证同步。
3.  **通道模型 (Channel)**：
    *   **思想**：借鉴 Tony Hoare 的“通信顺序进程”（CSP）理论，提倡“不要通过共享内存来通信，而要通过通信来共享内存”。
    *   **优点**：线程间保持隔离，通过消息传递进行同步和通信，极大提升了安全性和代码清晰度。Rust 标准库中的 `mpsc::channel` 就是此模型的实现，适用于大多数CPU密集型任务。

### **三、 `async` Rust 的诞生及其核心矛盾**
对于需要处理海量并发连接（如 C10K 问题）的场景，传统线程模型因资源消耗过大而不适用，这催生了用户态的轻量级任务（或称协程/Green Thread）。

*   **Rust 的方案**：`async/await` 语法糖 + `Future` 特质。`async` 函数不阻塞，而是返回一个代表未来结果的 `Future`（状态机），由一个异步运行时（Runtime）来调度执行。
*   **核心矛盾**：
    *   **Rust 的核心设计**：在**编译时**通过所有权系统和生命周期检查，进行**静态内存安全验证**。编译器必须在运行前证明所有引用的有效性。
    *   **异步编程的天性**：任务的执行和完成依赖于**运行时**的外部事件（如网络IO），其执行流程和数据访问模式是**动态且不可预测的**。

> 这种“**静态编译时证明**”与“**动态运行时调度**”之间的根本性张力，是导致 `async` Rust 变得异常复杂和痛苦的根源。

### **四、 `async` Rust 的实践痛点**
上述核心矛盾直接导致了以下一系列开发中的实际问题：

1.  **生命周期与所有权传播**：为了让编译器通过检查，跨越 `.await` 点的数据必须满足 `Send`（可在线程间移动）和 `'static`（拥有静态生命周期）约束。这导致这些约束像病毒一样在代码库中传播。
2.  **`Arc<Mutex<T>>` 的泛滥**：当无法满足 `Send` 或 `'static` 时，开发者被迫大量使用 `Arc`（原子引用计数）来共享状态。文章批评这是一种“**世界上最差的垃圾回收器**”——它解决了编译问题，但带来了运行时的性能开销、潜在的死锁风险，并且无法像真正的GC那样自动处理循环引用。
3.  **复杂性急剧增加**：
    *   **病毒式传播**：调用 `async` 函数的函数自身也必须是 `async`。
    *   **生态割裂**：`async` 代码与同步代码难以直接混用。
    *   **手动装箱**：递归 `async` 函数会产生无限大的类型，需要开发者手动进行堆分配（`Box::pin`）。
4.  **极高的心智负担**：开发者要么必须深入理解异步运行时的复杂底层工作原理，要么只能在代码中到处添加 `.clone()` 和 `Arc` 并祈祷一切顺利，这与 Rust 通常所追求的精确和安全背道而驰。

---
### **核心结论**

`async` Rust 因其核心的静态内存安全模型与异步编程的动态需求存在根本性冲突，导致其在实践中变得极其复杂，对于绝大多数（99%）的并发场景而言，它是一个增加了不必要痛苦的过度设计工具。

### **内容的总体框架**

该内容遵循一个“**问题 -> 演进 -> 方案 -> 冲突 -> 后果**”的逻辑框架来构建其论点：

1.  **提出问题**：我们需要高性能，因此需要并发与并行。
2.  **追溯演进**：回顾了从多进程到多线程再到通道模型的历史解决方案，并指出各自的局限性。
3.  **引入新方案**：针对C10K等大规模并发场景，介绍了 `async` Rust 作为解决方案。
4.  **揭示核心冲突**：深入剖析 `async` Rust 与 Rust 语言静态检查哲学的根本性矛盾。
5.  **展示不良后果**：列举由该冲突引发的一系列实践中的痛点，从而支撑其“`async` Rust 是糟糕语言”的核心论点。

### **概念关系图 (Mermaid)**

<Mermaid_Diagram>
graph TD
    subgraph "需求与背景"
        A["性能优化需求"] --> B["并行 (Parallelism)"];
        A --> C["并发 (Concurrency)"];
    end

    subgraph "并发模型的演进"
        C --> D["多进程模型"];
        D -- "昂贵的IPC" --> E["多线程共享内存"];
        E -- "死锁/竞态条件风险" --> F["通道模型 (Channel)"];
        F -- "适用于多数场景" --> G["Rust标准库 MPSC"];
    end

    subgraph "大规模并发挑战与 `async` Rust"
        H["C10K 问题 (海量IO)"] --> I["轻量级任务 (协程)"];
        I --> J["`async`/`await` Rust"];
        K["Rust核心设计哲学"] --> J;
    end

    subgraph "核心冲突"
        L["静态验证 (编译时)"]
        M["动态调度 (运行时)"]
        K -- "强调" --> L;
        J -- "依赖" --> M;
        L <--> N{"<font color=red><b>根本性冲突</b></font>"};
        M <--> N;
    end

    subgraph "导致的实践痛点"
        O["`Send` / `'static` 约束传播"];
        P["`Arc<Mutex<T>>` 泛滥"];
        Q["`async` 的病毒式传染"];
        R["极高的心智负担"];
    end

    N ==> O;
    N ==> P;
    N ==> Q;
    N ==> R;
    P -- "被批评为'糟糕的GC'" --> P;
    
    style A fill:#FFF3AD,stroke:#333,stroke-width:2px
    style B fill:#BDE9F5,stroke:#333,stroke-width:1px
    style C fill:#BDE9F5,stroke:#333,stroke-width:1px
    style D fill:#E6E6FA,stroke:#333,stroke-width:1px
    style E fill:#E6E6FA,stroke:#333,stroke-width:1px
    style F fill:#D4EDDA,stroke:#333,stroke-width:1px
    style G fill:#D4EDDA,stroke:#333,stroke-width:1px
    style H fill:#FFC0CB,stroke:#333,stroke-width:1px
    style I fill:#ADD8E6,stroke:#333,stroke-width:1px
    style J fill:#ADD8E6,stroke:#333,stroke-width:1px
    style K fill:#F9F7D8,stroke:#333,stroke-width:2px
    style L fill:#F5B7B1,stroke:#333,stroke-width:1px
    style M fill:#AED6F1,stroke:#333,stroke-width:1px
    style N fill:#FF6347,stroke:#A52A2A,stroke-width:3px,color:#fff
    style O fill:#D7BDE2,stroke:#333,stroke-width:1px
    style P fill:#D7BDE2,stroke:#333,stroke-width:1px
    style Q fill:#D7BDE2,stroke:#333,stroke-width:1px
    style R fill:#D7BDE2,stroke:#333,stroke-width:1px
</Mermaid_Diagram>

Content:
看一篇Rustler很有趣的一篇文章它这个是8号发的一个文章像是我们来讲比较有意思你看它的标题这叫一部Rustler是一门糟糕的语言而且它这里面一直讲的就是讲Rustler里面一步的一些问题我们来看一下很有意思它是讲的我们先要理解一下它为什么这么讲首先要探讨一下就是为什么一部Rustler会存在我们来看一下它是讲为什么会存在看一下这就是我们说这个一部为什么有有的原因假如我们希望我们代码能够运行的特别快我们需要解决两个问题一个问题是什么就是我们要充分利用整台计算机的性能到2023年了接著到2023年了即使说像我们的手机都有8个处理器核心8个核如果我们想要充分发挥机性能超过百分之二的率率我们就需要同时十人多个核心就是要多核就是第一个要有的因素第二就是说我们想要等待缓慢的操作完成缓慢的操作Runtime继续执行其他任务不仅仅是在这赶等计算机这计算的实验用发生过一条消息到固定完甚至只是打开一个文件都需要花费非常长的时间在这个时间里面我们完全可以同时执行数百万个其他的任务就像做到病情一个就是要多核一个做到病情就是解决这两个问题因此我们不得不依来病情性和病发性解决这些问题我们要盖固一下这两个概念一个是病情和病发估计经常我们经常我们可以问到的问题会怎么样的问题它这个讲得很通俗一种而且很容易理解什么和病情和病发不能解放什么病情性是什么是指在多个CPU上面同时运行一套代码这个就是说可以提高整体的性能多个人一起干活那就是病情病发是什么呢病发性是指将问题分解为相互独立的部分然后让他们可以独立运行这样就可以提高效率这样可以通知进行也可以进行做天有病发从而可以病行这是其实一个是针对CPU的多核去做的事情但是病发是什么是为了做去相互独立的分解去做的他们不同点在这里它也讲到了这两者不相同病发和这个病情它两不相同当核计算机已经在半个世纪中同时运行病发代码已经都有了但是病情病发之间他们之间存在联系那许多在线讨论的往往互列的我们通常这样成绩分解什么病发的部分以便这些部分可以进行病情就跟我们刚才讲的讲先完成病发再去病情就是达到病发的瞧接然后再去病情就是这样子就一种比较有错的方式去进行这样子就有提高效率这样可以保持处理器核心一直保持很高效的工作就是它一直在工作如果说我们不关心性能为什么废心要做这个事呢对吧我们为什么还搞什么病发干嘛的没有标去做病发对不对这个是讲病情和病发我们为什么要做了一个背景我们为什么要去这么做重要的解决什么我们要解决它一个性能跑得更快或者说这个CPU怎么利用力更高可能是干净不够事那么怎么样进行病发呢我们怎么来病发呢你看就提到这里了要构建一个病发系统最简单的方法之一是将代码分成多个进程就是你首先给它分割相互独立的这个进程就是做了病发刚才病发定义过了我们要做病发背景操作系统是一个金桥而高效的病发迹子亚洲操作系统已经是了它跟硬件一起卸成工作是这么难的让每个进程都以为自己独想的整个计算机整个计算机都差不多用走了但是操作系统的调度程序免费为我们提供了这种病情性可以在任何准备好的进程之间轮流运行就是准备好了大家都轮流运行就像CPU时间片一样或者说多合一样这个合理用和它用就就可以利用可用的CPU合在以前以往这是一种非常常见的方法今天我们仍然是将这个夏尔命令连接在一起的时候使用这种方式因为夏尔的话我们这么做那么做去把它砲就砲砲的用这个砲砲那一种方式去进行就怎么让它去做这是怎么做到病发就是大概讲了一下病发怎么做但是这种方法存在一些限制存在什么限制呢就是说CPU1干这个火CPU干它火CPU3干那个火ABC的各样干活进程进的通性并不是年假的就是说进程之间相互之间有通性的话它们的代价是很高的不是说很容易就能达到它们将会是很不通这是因为什么呢因为大多数实现都需要将数据伏制到操作系统的内存然后再成内存当中拿过来这个先给过去然后再拿过来就这个操作是对性能上面是一个很大的一个杀伤进程进程之间通性是怎么通用好是个问题我们再看它的底下咱们讲就是互刺所病发被视为有害首先是这么个讲了除此所他认为病发了讲是为何或者说HALL是正确的HALL它提供了一个它之前讲了一个什么事呢底下有人说有引用那个其他人说的话就是说但有人变灵问题的时候也会想因为预热这个问题的时候比如说进程之间不好沟通进程和进程之间沟通很安贵怎么办他有人就想我知道了我用现成不就行了吗然后他就遇到了新的问题它是这么个说的这个叫Net batch怎么讲的然后我们就讲了我们可以通过使用现成的避免这些开销就是我们相互就沟通的这个开销它可以避免的开销这些现成什么共享相同的内存因为都在内存大家是供用的现在就是下一个买卖物也你们去沟通这样就没有那么大的代价不需要怎么考出去放出去考过来这样的话那么通常的经验教训告诉我们什么要用一些神秘的根据将他们连接起来现成之间你看看现成之间要做什么跟RUSH的我们知道有做什么现成之间有护制所条件变量和新考量和这个生活的就这些东西需要做这些然后他认为这是一场这是一场非常危险的这个游戏简单的错误就是哪怕现成之间沟通简单的错误会让你遭受什么近态、条件、实所然后其他可怕问题的困扰他是说当只会在下雨的星期二和温度是三的背书才出现他的意思是什么呀就是说如果要去把这些问题都解决出现的概率是非常非常非常低的这个东西你要把它搞成功了是很难的他的概率很小你能不能搞定如果你想真正的了解东西现在一年上是怎么工作的那算是保佑你吧那就是超级难难搞定他在一年上面到底是怎么跑的搞清楚这个问题很难受不说搞不定但是很费力、很费硬然后看看他讲话是怎么讲他的理论也就是说他如果要解决这个问题还有另外一种方法是什么我们来看就是在进程和进程之间怎么保持通性刘逼怎么不是那么安贵的进程之间怎么通性他有另外一种方法在他的1978年的论文通性送去进程中突而后来建议使用对列或者通道将现成进竞技起来他们可以运来发生消息进程之间可以运他的发生消息所以有很多优点还有优点其实这个我们基本都以之就是现成享受内事进程的隔离现成和现实际上是相互隔离的和程序的其他部分不贡献内存其他不贡献内存相互隔离对于内存安全的编程源来说就会让意外干扰其他现成变得困难就是你现成现实际上相互干扰就很难吗很难形成这是一个非常好的一个加分项每个现成都有一组非常明显的输入也就是他接输消息通道的一个通道合一个输出他接下来发出消息的一个通道其实相当于非常明显的一个输入输出的通道这很好理解也很容易调适你可以为通道停下均率以强大的方式长开系统的运行情况车辆每个现成的通土那样等等这些都可以去做还有一个就是通道是同步的他们这件事要做同步的如果通道空技术者会等待指导有消息为止通道是空道我就等著前段时间都会等著如果通道满的话我们发送者就会等著我发播出去就等了一点现成在有工作要做的时候他就不会修免如果他超越了系统的其余部分他就会涨停一下他如果超过了他就涨停一下而且是非常Greaseful的涨停这是做志愿千恶的方式去解决他进程之间的一个问题然后在经历了几十年的护制所封宽之后就是大家都在于用这个护制所我想护制的许多现代编程员都听成了货的建议就踩拉拉货的建议就是什么在他们标准库的那种提供的千恶提供的通道在Rus<|ar|>CenterNPSCChanner就把这个放进来了把Channer放进来了那么大多数软件在这里就可以停下来了就搞定了嘛就可以OK了使用现成和通道构建变化系统他把语言当中这么搞就OK了搞定了大多数软件但是他把语用于病情化CPU密集型旬环供具比如说Russel的Rion或者Hatchcl的Path像结合你就有一个强大的组合就可以有强大的组合能去病情CPU这些东西密集型旬环供具所有这个东西能够把它搞成了这个都能搞定了但是但是说到什么了但是特技讲有些问题需要大量的病发处理就是你之前那种相互沟通的能够相互沟通好你看我刚那个R传统相互进行这样就把这个病情搞定了嘛基本上就能搞了但是这都可以吃的可以病发了还有一个问题经典的例子是什么就是单卡哥在1999年提出了一个1100K的问题1100K是什么问题就是说一个连接数万个病发运户的Web夫妻在这个规模上就是1万个C10K就是C10K在这种规模上现成并不注意下去问题什么原因呢尽管他们相对比较容易对资源的消耗比较便宜消费的精力比较小但是每一个连接起动一个现成会导致计算机性能极具下降就现成对于你这个资源的耗费不大但是你每一个连接起动这个现成会导致你性能下降为了解决这个问题一些病程语言提供的一种病发模式其中任务在用户空间创建和管理就不依赖操作系统的帮助这就解决什么问题就是我起现成的话不需要跟操弃的I want to take something每个事都要去就像我们就像做什么事情要先领导这个请事件I want to do this同意了我赶著这种难那么现在就算我不需要去找领导这么深情的同意了我直接去就干就完了所以说任务放在用户空间就创建管理这就可以了对吧还有一个是什么是Runtime将这些任务调度到一个操作系统的一个现成池上放在现成池里面通常会根据CPU的核心数量分配现成以最大程度的实现病性处理它是放在现成池的这种方式两种方式去做假设问题有些变成的原因是最近两种方式去解决的那么这种方式有许多名称比如说叫什么Green Thread就是绿色现成青年级现成青年级现成青年级进成或者是先成之前讲到的Fiber式或者是要斜成等等而且还伴随著什么伴随著一些于服的困境不断的头额他们最近微妙的区别就是绿色现成跟青年级现成他们之间因为不一样的区别这很微妙的那种现区别就很于服其实他们都是一个东西说不定还是这个意思都是一个东西对吧然后RAS的产业一种什么聊完一段解决呢我们之前在学URAAS的社科看到过就他用的是Sync Weight模型的解决这个问题那么这种模型在以前的变成原始人也出现过比如说这个随下破或者NodeGIS里面都有过在这里标记为Sync的韩数他不会主塞他不会主塞所以说他的地码繁华一个什么繁华一个Future或者是PromisePromise就是会繁华一个Promise可以等待等待的人会以产生结果这个我们之前介绍Future的时候知道这个玩意了对吧我们再来看一方面RAS中的Future非常小而且速度快这个都已知道这要归功于他们是写作调度就是他是是说白了那是写成对吧是写作调度的还有就是他无对战设计他没有每个人来都要出一个对战出一个对战的设计不要对战但于其他支持用户困间并发的变成原不同RAS的什么了试图在想成员成了完全的低级困择的同时是提供这种出象提供这种出象就是说你要低级然后同时要出象你看看所以他就讲了这两者之间存在非常根本性的一个什么紧张关系这相互之间多少会有一点冲突非常可怜的SyncRAS成员长长进入其中左右伪被加在原设计目标和他们试图构建了高兵发生世界之间又要达到我的设计目的我要安全我要用你的同时又可以高兵发又安全又要高兵发整体安在之间矛盾的其实所以RAS的试图在编译是静态验证是静态验证成誉中每个对象和引用的身边主席就是我在内行系统中编译的时候我要静态验证的印象每个对象的这个引用的身边主席是不是OK的是不是正常的但是Future Promise是相反的就是我们可以将代码和他引用的数据分析成千三个小片段可以在任何时间任何形成上运行那么这是基于我们只有在Runtime后Runtime这个时候就其中后才能知道条件然后在这里面去验证就很麻糬对不对相当于说你在印证之前我作为程序员我就已经知道你应该是哪个怎么走的了这个Runtime什么东西都知道了安排好了很妥了然后你才去跑这个东西你不用行的话除非说你这个老师逻辑思维跟这个机器一样刘必否则你没办法去把你这个东西都规划好就说白了就像那样现在就说我做了一个非常刘必的规划我往这个上面往两个上面一试试完全符合就是完全气和就像我在纸上写了个程序然后我往电脑的一书你马上不会有错这个太太难了对不对所以算你看那讲什么东西就一个客户段不去数据的比例应该是在该客户段的这个Soky的有数据是可读是运行你看这个多难对不对有一个比例就你客户段的话有Soky的我立马就去读了我怎么知道怎么知道它有这个东西的但是没有任何生命周期这个注时可以告诉我们何时发生这种情况就是我们什么时候知道它有输出这个难度就太难了对不对所以它讲到就这里面就说在Ratham Future这个怎么去设计尤其是那种高病发的话就更加难以知道你如果就两个现成之间差不多三个现成哪怕五个现成你可能都能想到明白但是更多你能想清楚它之间的关系吗对吧这个时候你看它就有个像B1C保证一切都会顺利进行这个都会一切顺利进行这个一切都会顺利进行的这个时候就是我们就会面临著处理原始现成相同的调档相同的调档就是数据必须标记为Send我们会看到一个Send然后并进行移动在外前走对吧或者是通过具有Stady一个生命租汽的隐运去传递它有生命租汽这两种方法说起来容易说起来难就你我知道你的Sync和Water的机制是什么样子都知道但是我把他们能受到这么精准这个太难了对吧这两种方法都讲了就说起来容易说起来难移动数据就是不永远的话至少不可能的数据的情况下通常都不可行因为在意义不在马上常常会起动许多共享共共状态的融运也很麻烦没有像FlySkill不这样的等加工具搬著我们除了永远之外的任何的现状你看像这种像这种上面在马上就就 out了跑不了了只有把Sync把Sendable这里面把它clown进去然后这样才能进行才能跑跟原始的现成不同你可能只需要在少数几个韩国中处理这些很烦的事情但由于一步的传播的性质这类情况会不断发生由于调用你一步韩说的任何韩说本身必须是一步的你需要在每个地方一直去解决这个问题无时无刻不顾不需要关注它随时都在关注它它一步是不是脖子上是不对的然后只需要使用Ark解决我的问题你看这个其中说有一种是这么讲的你看你看它就讲了又说到这个什么Ark的事情今年丰富的Russel的Calf会告诉你Russel的提供一种简单的问题允与管理跨多个形成的动态生命处期我们称之为什么Ark原则营运抗体原则营运抗体对这个尽管Ark确实解决了眼前的问题解决了什么问题就确保解决用检查通过就用把这个接用把这个给它通过了把这个问题给它解决掉了就是包走就是在这个编译的时候包著钱给你们是通过了让我们带马能够顺利编译但是它也不是什么它也不是您的大妙要它也不是这个银子弹能解决所有问题它不是一老云一的解决方案如果如果能让用Ark的话就会面临什么让你面临世界上最差的那一回收器像纳基回收一样对象的生命中心以及他们代表了资源像内存文件稍微等于是没法确定的但是但你因为因此失去实际这个纳基回收能带来的好处现在纳基回收给你带来的麻烦本来即使是给我们带来好处的然后再看不要相信纳基回收输入纳的这种传言这种说法最多是对眼纸和通编的误解甚至在最坏情况下它是一种非常奇怪的这种心理上的手现代的或者移动式的纳基回收器可以提供更高的分配通透量对吧减少这种说法而且不需要你玩这种弱的就是VicPoint那种那样我地面这个循环泄露做的这种无关紧要的这种游戏你甚至可以通过把它叫做什么延迟消毁那七片系统的成员让他们的事像最重要的软件像这种利润这种大气回收其实就没有标大家回收上面就写了很有问题那再看由于这个螺丝斜层是无对战的大家知道所以说编辑将每个斜层转换成一个状态机其实这个在赶讲菲小时候也讲了它就像那一个状态机这个状态机都会不断地进展到下一个而为的操作那但这种躲遮任何地归的这种一部韩宿都变成了这个地归的你的内心当运估长世成这个韩宿内部它自己的时候会遇到这种非常难懂的这种错误除非他们手动的这些进行包装或者使用一个完成相同工作的一个什么就是一样的东西然后再做一个Creator上去否则你这个面就是在内部调用自己的时候搞蒙了就这样搞蒙了那重要的区别在于什么Future在等待之前什么也不做但是它是个就会在Runtime是Runtime新成词中启动并且反悔一个标记为什么它完成了一个Future你没有就没有任何东西可以阻止你在Future中调用这个阻塞的这个代码阻塞式的代码也没有什么可以阻止这个被调用的阻塞Runtime的现成所以说你知道这正式我们试图通过这个一部操作来避免了这个问题反而它有形成这个问题来看把这一切混合在一起把中上所说这使得一部Rustle跟正常的Rustle有很大的不同它有更多的陷阱更难理解回去教学或者去学习就迫使用户要么两条路可以走要么是深入的理解这些初象实际是如何工作的编写复杂的代码就出了它们就做了把这个一部做得非常的精确你跟Mive他们都非常合理或者是什么或者在代码中谁数添加什么R啊个屁屁屁屁其他的一些这种很奇怪的这些这些东西然后起到一切顺利就是在很多不符合这个一部手把这个什么R什么东西强硬的让它去正常这样就是你看得最后能不能搞定了就是说它的它符杂路太高了那RAS的这种拥护者作者认为它自己也是其中之一可能会认为这些批评的有点严果歧视它的确有在我底但是那一把它夸大了当然我见过整个经验的就是非常有经验的开发团队在试图在一个新的像不中RAS的像很快就现入了这些细致部体的困境不管就是这个教学RAS的损命能挑战有多大一部操作都是增加了一套新的问题一部操作人家更拿那么这些问题在其他原种根本不存在了也无法过分也无法过分强调在Hashikra或者Govu的一部代码这是非常正常的代码你可能会说这是一个不公平的一个比较毕竟这些语言将主材和非主材代码之间区别就是这种主材和非主材的问题全部抛给谁抛给了Rontan我不去做你的编译缓解不做这个检查我这不管你这个东西直接Rontan我们会不会出问题再说吧当然这的确是很不公平但生命周期就是通过纳结回收了解决的但是正式重点所在在进行这种编程的时候这些就是比较纯粹一点的优势了也许RAS的不是运用大功病发运酷坤间而验了好工具所以我们可以省一省别给那些不必要的百分之几有的下面把它去搞这种病发它是这么认为的它认为的病发只需要1%的纠结而且它举了一些例子因为哪些当中其实不需要运到这个病发的比如说有一个文件它可能位于这个护念网的另一段就是有一个文件大家都可以用那谁都能解决NF还是就解决了就不需要做这个突然我们可以通过在进程之间贵峡内存的减少这个IPC的开销但这会什么会放弃多进程主要以后之一操作系统将它们相互隔离Processed这块有隔离有没有早就最近叫MacBall出了一本经常说专门针对RUSD但在任何病程运动很好地解释了低级病发的基本原理如果它说有劝求可以看这个这支你们进行的它进行了简化并非每个程序都可以表示为DAG对 其实就是并不是每个程序都可以做这种搞病的病发你仍然可以找到其他的机缘的好机会比如说原子标示来只是全局状态的变化等等不过这个Haw的模型是一个很好的模型选择Haw的模型是什么就是有Channel的反思去做所以也是一个好办法其中的一点一个解决在例如说每个现成都会有一个4K的PCB这个困之快并且在现成之间切换需要通过操作系统调度程序进行与普通的行速调理相比将三下我们切换到操作系统那一层开销就更大它的多就是说这种的话就没有有些情况就不要去用它与其他源不同Ross源总没有为FuelT的提供Rontane而是将这个任务委托给谁了委托给扩了比如说脱机的都酷这对用过来说Ross的构建过去Cago和生态系统富裕开发者选择在特定的同样更合适的提的方式但这个基本统统都不重要可以像样式要跟脱机已经被你进到原装所有相当规则的那样式你可以用通过命令运行整个Rontane在FuelT的完成的时候主要是打破自己的练习但你不能不应该管犯了去这么去做然后它下面也讲了很多问题然后我把这个问题跑给了这个谁跑给了这个GPT我看GPT来总结一下跟我的理解是不是完全一样我们来看看GPT是怎么说的GPT他是怎么讲他说GPN文章表达到关于什么关于Ross的编程与原装一步编程我们都讲到的SyncWater的一些批评和反思虽然它说它的标题是叫SyncRossBadNanguage但作者并不是要抽离的编离Ross就是它跑了在Ross中进行一步编程的可能并没有那些挑战的问题它的要点是什么的变发需求背景就变发需求背景其实我们已经讲到过了不存负然后变发后并有什么差别也讲到过了那么并方模型的演变作者提到这历史上不存的病方模型包括这个多精层然后多现层当时这些模型程度存在一个问题比如说进程间通性开销后性质验的近代条件这些去问题就出事了就找到更好的解决方案对吧但是现成之间通性开销出的问题那么现成之间特朗普有近代问题就是相互竞争然后拖年后的建议就是搞什么搞这个通道对列后的通道它给了这个那一步Ross的挑战作者就讨论了什么在Ross中进行这个一步编程的时候可能遇到问题一步编程允许这个韩出立即反回一个Future或者Promise不会主赛但是带来一个更复杂就带来了很大的一个复杂性Ross在编一手印成就说每个对象和隐形的生命周期其实问你就是就是这个生命周期你很难确认保持这种矛盾的这里其实这篇文章我认为它强调了非常明显的强调的一个点就是说你引用了生命周期和你编译之间的一个冲突矛盾生命周期你很难确定它所以说这个在一步编程的灵活性灵活性它之间就存在了非常一个一个一个冲突关系之在里面可能会需要处理这个隐形传递和生命周期的这个问题其实我认为第五点是这个文章中重重的这种孙阿克的问题问题问题问题问题问题问题的话解决生命周期问题的方法当它能解决的基本上就是什么解决编译的问题其实更多一些可能会导致那种管理的问题大会有一个文件的那种那么一步编程的复杂性作者就它就强调了一步编程在Ross中的复杂性以及于传统的Ross变成相比它需要更多的学习和努力理解和处理这里面其实也就说了就是Ross的那种难在哪里这个其实就它其中一个然后最后它结论就讲了结论就说文章最后讨论了一步编程在特定隐瞻价值以及Ross的是否适合进行大国病发的任务科学作者认为都大数下面它吃的说99%对吧Ross提供了足够的婚剧当然需要高度病发特定产品那种可能才需要这种高级的婚剧和更不幸它是这样认为的总的那讲的话文章是提供了对Ross的一步编程一些思考强调了这个挑战后复杂性同时也提出了对于这个病发变成的不同方法和模型的这个思考鼓励我们就是在这个变成的所谓更加谨慎同时可以认识到Ross的病不是这个思考所有内行的病发所以这个的确是这个地方就是读下了是挺有意思的一个点基本上做了一个这样的总结而且我们读下来感觉这个的确是有比较有意思点就是这个它的最最有意思的就是它为什么会是这个样子的对吧
