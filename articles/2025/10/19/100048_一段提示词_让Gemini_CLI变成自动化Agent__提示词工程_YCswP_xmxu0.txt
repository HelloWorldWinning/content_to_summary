Timestamp: 2025-10-19T10:00:48.927336
Title: 一段提示词 让Gemini CLI变成自动化Agent！ 提示词工程 YCswP_xmxu0
URL: https://youtube.com/watch?v=YCswP_xmxu0&si=HN72KMFhTfIrAPz0
Status: success
Duration: 11:58

Description:
好的，这是对所提供文本的核心思想进行的提炼和总结。

### **一、 核心思想纲要**

1.  **初始问题：简单提示词的局限性**
    *   直接、模糊的指令（如“翻译文章并下载图片”）会导致AI执行任务时表现不稳定、失败率高。
    *   根本原因在于用户自己没有把任务想清楚，AI无法理解模糊的需求。

2.  **核心框架：像程序员一样思考**
    *   解决问题的秘诀是**分解任务**。
    *   采用**“输入-过程-输出” (Input-Process-Output)** 的逻辑框架来清晰地定义一个任务。
        *   **输入 (Input):** 任务的起点，例如一篇文章的URL。
        *   **输出 (Output):** 任务的最终交付物，例如三个版本的Markdown文件和所有本地图片。
        *   **过程 (Process):** 实现从输入到输出的详细、明确的步骤。

3.  **关键挑战：AI的“短期记忆”**
    *   对于步骤繁多（如20-30步）或操作复杂（如下载100张图）的长期任务，AI会因为上下文过长、噪音增多而“忘记”自己该做什么，导致任务偏离或失败。

4.  **解决方案：为AI引入“长期记忆”机制**
    *   **方法：** 让AI学会**记工作笔记 (`Progress.md`)**。
    *   **笔记设计：**
        *   **任务清单 (Checklist):** 宏观上跟踪总体任务进度。
        *   **详细进度 (Detailed Progress):** 微观上跟踪多步操作（如图片下载）的细节。
        *   **当前状态 (Current Task):** 实时报告AI正在执行的具体动作。
    *   **执行规则：**
        *   在所有步骤开始前（步骤零），先创建并初始化笔记。
        *   在提示词中设定总规则：**每完成一步，都必须更新笔记文件**。
        *   利用 `Few-Shot` 示例，在提示词中直接给出笔记的格式范本。

5.  **方法论原理：利用Transformer架构的特性**
    *   大模型对上下文的**开头和结尾**信息最为敏感。
    *   我们的策略将两个最关键的信息放在了这两个位置：
        *   **开头 (Context Start):** 我们的**提示词**，定义了任务目标和行为准则。
        *   **结尾 (Context End):** AI自己**实时更新的笔记**，记录了当前进度和状态。
    *   这种方式能最大化地帮助AI保持专注，即使在复杂任务中也不会偏离轨道。

6.  **实践应用：封装为可复用命令**
    *   可以将这套精心设计的提示词封装成一个自定义命令（如在GIMNAI CLI中），通过占位符（如`ARGS`）接收动态输入（如不同的URL），实现一键式自动化处理。

---

### **二、 核心结论 (一句话)**

高效AI提示词工程的本质，是**将一个复杂任务彻底想清楚并进行逻辑化、步骤化的拆解，再通过外部笔记机制赋予AI“长期记忆”以确保其稳定执行**。

---

### **三、 总体框架 (Overarching Framework)**

该内容的核心框架是 **“输入 (Input) - 过程 (Process) - 输出 (Output)”** 的编程思维模型，并在此基础上，针对“过程”的复杂性，引入了 **“基于外部文件的工作笔记 (External Progress File)”** 作为AI的长期记忆解决方案。

---

### **四、 核心概念图 (Mermaid Conceptual Map)**

<Mermaid_Diagram>
graph LR
    subgraph "问题与基础方案"
        A["简单模糊的提示词"] --> B["结果不可靠/失败"];
        C["高级提示词方法论"] --> D{"核心框架: IPO模型"};
    end

    subgraph "IPO模型详解"
        D_I["输入 (Input)<br>e.g., 文章URL"] --> D_P;
        D_P["过程 (Process)<br>一系列明确步骤"] --> D_O["输出 (Output)<br>e.g., Markdown文档, 本地图片"];
    end

    subgraph "核心挑战与解决方案"
        D_P -- "当过程复杂时<br>引发" --> E["AI短期记忆问题<br>(长上下文导致遗忘)"];
        F["解决方案: 赋予AI长期记忆"] -- "通过" --> G["设计工作笔记<br>(Progress.md)"];
        E -- "被解决" --> G;
    end

    subgraph "长期记忆机制 (工作笔记)"
        G --> H["1. 任务清单 (总进度)"];
        G --> I["2. 详细进度 (如下载列表)"];
        G --> J["3. 当前状态 (正在做什么)"];
        G -- "实现原理" --> K["利用Transformer<br>对上下文'首尾敏感'的特性"];
    end

    subgraph "原理应用"
        K_Start["上下文<b>开头</b><br>(我们的提示词)"] -- "协同作用" --> K_End["上下文<b>结尾</b><br>(AI更新的笔记)"];
        K --> K_Start;
        K --> K_End;
        K_End --> L["[AI始终明确目标与进度]"];
    end

    subgraph "最终实践"
        C --> M["将完整提示词<br>封装为可复用命令<br>(e.g., GIMNAI CLI)"];
        D_I -- "作为参数" --> M;
        M -- "一键执行" --> D_O;
    end

    A --> C;

    style A fill:#FFB6C1,stroke:#333,stroke-width:2px;
    style B fill:#FFB6C1,stroke:#333,stroke-width:1px;
    style C fill:#90EE90,stroke:#333,stroke-width:2px;
    style D fill:#F9F7D8,stroke:#333,stroke-width:2px,color:#333;
    style D_I fill:#ADD8E6,stroke:#333,stroke-width:1px;
    style D_P fill:#ADD8E6,stroke:#333,stroke-width:1px;
    style D_O fill:#ADD8E6,stroke:#333,stroke-width:1px;
    style E fill:#FFCCCB,stroke:#A52A2A,stroke-width:2px;
    style F fill:#98FB98,stroke:#006400,stroke-width:2px;
    style G fill:#90EE90,stroke:#333,stroke-width:1.5px;
    style H fill:#E0FFFF,stroke:#333,stroke-width:1px;
    style I fill:#E0FFFF,stroke:#333,stroke-width:1px;
    style J fill:#E0FFFF,stroke:#333,stroke-width:1px;
    style K fill:#FFFACD,stroke:#333,stroke-width:1.5px;
    style K_Start fill:#FFDAB9,stroke:#333,stroke-width:1px;
    style K_End fill:#FFDAB9,stroke:#333,stroke-width:1px;
    style L fill:#90EE90,stroke:#333,stroke-width:1px;
    style M fill:#FFD700,stroke:#333,stroke-width:2px;

</Mermaid_Diagram>

Content:
今天我们一行代码都不解只用一个纯文字的提示词来给GIMNA CRI增加一个超酷的穿醉的明明我们只需要给它任何一篇文章的UI后比如说这篇GIMNA CRI的帮助文档AI就会首先分解任务并通过PURGWET文件实时报告自己的进度它会帮我们下载文章然后下载文章里的所有图片然后再把它们排半场MARGDON格式再发一层中文和中英文两个版本并且让声称的文档使用下载套本地的图片让我们的文档能够完全地理现使用而最最关键的是这个方法不只是用于GIMNA CRI无论是Cloud Desktop还是Cirrus Studio这样的工具只要它能访问本地的文件只像命令就能使用这套提示词今天我们就把上一期视频中详细介绍过了上下文工程技巧应用到十占中从零开始打造这样一个全自动的提示词本期视频不需要前置知识可以单独观看但如果你想了解更多的技巧可以参考这期理论视频以及关注我的知识星球获得更多的AI和Python知识视频连接和最终的提示词我也会放到评论区现在我们从一个最简单的ProM的鞋起比如说我直接和AI说把这篇文章翻译成中文并且保存成MARGDON格式在下载后里面的图片现在我们把ProM的直接复制到GML-CRI中运行一下我们可以看到MARGDON模型确实翻译了文章但是或许图片却失败了而且整个过程也并不是非常稳定GML-CRI有的时候能够找到图片有的时候又不能如果想要让AI更好的为我们服务关键在于我们自己先要把事情想清楚我们到底想要什么我就要报款我要无彩办案的黑这种话我们自己都理解不了AI同样也理解不了那么我们要怎么才能把一件事情讲清楚秘决就是把一个事情分解通常我们可以把事情拆分为三个要素输入是什么输出是什么以及过程是什么没错虽然我们不写程序但是完全可以像程序原样的思考因为只有逻辑才是最高效最清晰的比较方式这里我们首先来定义输入和输出首先输入是什么呢很简单就是这片文章的URL接着我们来定义输出我们想要格式画后的原文我们还想要中英文版本和纯中文版本以及最最重要的我们还要文章里面的所有图片资源现在我们把定义好的输入和输出直接组合成一个新的promet요我们故意先不定义过程看看只靠这两部分AI能做到什么程度我们来看结果效果其实已经好很多了AI正确地生成了文章的三个版本可惜它依然没有把图片下载下来好了为了解决这个问题这就引出了我们最关键的故事过程为了实现视频开头的那种全自动的效果整个工作流其实可以拆解成非常清晰的五个大步骤访问泛站下载图片改写成markdown翻译成中英文最后再生成纯中文版本这里我们就把他们一个一个的定义清楚首先是访问泛站我们直接让AI访问输入中文王子这里有一个问题不同的AI 诊特他们内置的绑艺流浪功能差异非常大有的会访会完整的html代码有的责质会访会纯文版比如说gmail.sei这样就会漏掉我们后面需要下载的图片链接为了消除这种不确定性最好的方法就是指定一个同一可靠的访问方式这里我推荐一款命令行的流浪器叫做link死它是一个免费开源的纯文本流浪器纯文本流浪器这种上古的产物本应该在互联网博物馆中和迎海威蚀空之类的坐在一起可谁能想到它这种纸提取核心文本和链接的这种解漏的纯粹反而让它在AI领域大有作为这大概就是老子所说的无微而至吧总之我们通过一条命令link死就可以把往严内容一文字形式渲染出来了非常适合与AI进行协作所以我们加上一条规则让AI必须使用link死命令来访问网站最后为了调试方便我们再加一个要求让AZN的把获取到的原始内容保存到肉典TXT文件里面完成第一步我们就有了往严的文字内容接下来我们定义步骤二下载图片同样我们先把这个任务拆解一下让AI去分析上一步生成的肉典TXT文件把里面所有的图片连接都提取出来然后在一张一张的下载到RESORSIS文件家里最后和访问网也一样为了确保整个下载过程在不同的AZN的上面表现一致我们可以明确地让AZN的使用CURL命令来进行下载顺便说一下CURL是一个非常常见的命令行下载工具到这里我们已经有了完整的网业内容和图片最复杂的两个步骤已经被我们处理好了剩下的三四五步都是这个拆解任务的逻辑比较简单我就不细讲了有心理的同学可以暂停阅读一下这里要特别注意一下步骤三的最后一条指令将article MD中的图片连接只向RESORSIS文件加这一步保证了我们生成的稳当可以理现使用现在我们就把所有的输入输出和过程都拼起来于是promp长成了这个样子我们直接把它复制到GIMNA CLI中来运行一下可以看到AI完全按照我们的指令生成了全部的三个markdown文件RESORSIS文件加里面也下载好了所有的图片我们检查一下markdown的代码图片连接也是只向RESORSIS文件加的对于这片只有几张图片的小文章我们的promp表现的是非常出色的但这套提示词能应对更复杂的任务吗比如说一片文章里面有100多张图片需要下载或者我们的任务本身就有230个步骤AI还能像现在这样撕入清晰的从头走到尾吗答案是大概率是不能的因为AI只擅长处理短期记忆执行的步骤越多上下文里的噪音也就越多AI也就越容易忘记自己试试到底应该干什么关于上下文的详细原理大家可以参考之前的那期视频现在我们就来解决这个AIAZN的领域最核心的难题之一如何让AI拥有长期记忆这个问题其实有一个进户于标准答案的解决方案那就是让AI学会计笔记我们可以设计一个专属的工作笔记让AI在执行流程中无端的进行更新我们一起来设计一下这个笔记看看到底应该长什么样子首先我们得知道总的任务进度可以用一个任务力的表来实现完成一项就打一个钩但是这还不够对于下载图片这种多部操作我们还需要更详细的进度好 那我们就再加一个图片下载的进度为了让状态更加清晰最好还能让AI实时报告它正在做什么所以我们再加上当前任务者一下好 针对我们的任务笔记格式差不多这个样子就行了接下来我们就把这个格式做一个例子直接放到promp的最后面这个操作在AI领域有一个专业的名词叫做FewShout也就是在promp中举例子我们的笔记格式就是一个例子然后我们在所有的步骤最前面加一个步骤零专门指导AI来生成笔记我们就让AI按照例子生成一个名叫Progress MD的文件接着我们在提示词的最顶上增加一条总规则每完成一步都必须更新Progress.MD文件然后下载图片我们也需要改造一下从肉点TXT中提取连接之后我们要让AI把练机写到Progress的图片下载进度部分然后我们再强调每下载万一张图片就必须更新一次状态好了我们把屏幕中所有的东西按照顺序组合起来这就是我们最终的带有长期记忆功能的promp到了我们再来把它复制到JM9-CRI中运行一次这次请注意看Progress的文件的变化AI会根据我们设计的格式不断的更新自己的工作笔记最终生成所有的指定文件注意一下这里我们让AI去更新Progress文件并不是单纯只是因为它看着很酷当然了看着很酷也是重要的原因之一而更重要的原因是AI震荡会维护和AI通信的历史我们叫做上下文上下文最开头就是我们的提示词之后AI每调用一次工具比如说用Links下载网页或者用Curl下载每一张图片这些信息都会被追加到上下文的墨围AI就是通过阅读上下文来理解自己正在做什么的但是如果上下文太长AI就容于范军而更新Progress MD文件这个动作同样也会增加到上下文之中我们通过提示词让AI每完成一步都更新Progress文件所以Progress的更新内容就被穿插到了每一次工具调用之间而现在大模型使用的Transformer架构对上下文开头和墨围的信息会非常的敏感基本不会被AI忘记在我们任务中上下文的开头和结尾是什么呢开头是我们的提示词告诉了AI要做什么以及如何做而墨围则是AI自己记得笔记告诉AI现在做到哪里我们就是这样最大化的利用了AI最敏锐的两个部分让AI即使在处理复杂的任务时也不会跑偏现在我们的Progress已经可以直接复制到各种AZEN的中去运行了最后我们再说一下视频开头在GMAX AI中把提示词包装成命令的方法这个过程其实非常的简单我们可以在下面的位置建立一个文件这个文件名就是我们想要给GMAX AI添加的命令刚才我们写的提示词直接放到Progress属性中注意我们之前的输入是固定的绑纸现在我们可以把它替换成2X这个站位服这样我们就能在GMAX AI中执行穿斯雷的命令了命令后面加了绑纸就会在执行的时候替换掉提示词中的2X站位服我们最后再来演示一遍完整的流程通过穿斯雷的命令我们启动下载和翻译的功能AI会不断的通过Progress.MD文件更新自己的状态最终生成英文、中文、中英文三个版本的文章并且文章中的所有图片资源都是指向本地的好了 今天你能看到这里我强烈建议你配合实力代码自己写一些类似的Prob的实现一些复杂功能这样不仅能对Prob有更深的了解而且也许会和我一样发现实际上最简单也是最难的事情就是把一件事情想明白了我们到底多久没有把一件事情真正想明白了呢希望从今以后当我们遇到任何难题的时候都少一分困惑多一分清晰这里是双旋老王我们下期再见
