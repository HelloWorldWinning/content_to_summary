Timestamp: 2025-10-29T22:32:58.162313
Title: 自动化防御性编程，让你变得无法取代！
URL: https://youtube.com/watch?v=L2PK7hrCxjA&si=T19E4OAoOriua1aa
Status: success
Duration: 11:26

Description:
好的，这是根据您提供的文本内容提炼的核心思想摘要。

### **核心思想摘要**

#### **一、 “防御性编程”的双重含义**

1.  **传统含义**：编写代码时预先考虑并处理潜在的异常情况，以增强程序的健壮性和稳定性。
2.  **衍生含义（视频核心）**：一种讽刺性的说法，指通过编写极其复杂、晦涩难懂的代码，使得他人无法接手维护，从而巩固自己职位的“编程方式”。这种方式的核心是代码混淆。

#### **二、 自动化防御性编程：基于抽象语法树 (AST) 的代码混淆**

为了解决“自己也看不懂”的弊端，视频提出了一种自动化方案：保留一份可读的源代码，并利用它自动生成一份功能相同但难以理解的混淆代码。

*   **核心工具**：Python 内置的 `ast` (Abstract Syntax Tree) 模块。
*   **基本流程 (Parse-Transform-Unparse)**：
    1.  **解析 (Parse)**：使用 `ast.parse()` 将清晰的源代码转换成一个树状的、程序化的数据结构——抽象语法树。
    2.  **转换 (Transform)**：通过继承 `ast.NodeTransformer` 类并重写特定的 `visit_` 方法，遍历并修改 AST 的节点，实现混淆逻辑。
    3.  **生成 (Unparse)**：使用 `ast.unparse()` 将被修改后的 AST 重新转换成代码字符串。

#### **三、 具体代码混淆技巧示例**

1.  **替换常量**：将代码中的 `True` 和 `False` 替换为结果等价但形式复杂的表达式（例如 `(1+1==2)` 替代 `True`），增加理解成本。
2.  **颠倒比较操作**：修改 `Compare` 节点，将 `a == b` 这样的比较颠倒为 `b == a`，轻微扰乱阅读习惯。
3.  **重命名内置函数**：
    *   修改 `Call` 节点，将对 `range()`、`print()` 等内置函数的调用，随机替换成其他内置函数名（如 `round()`、`isinstance()`）。
    *   在生成代码的开头，通过 `exec()` 注入代码，将这些被“占用”的函数名重新映射回其原始的内置函数（例如，执行 `round = builtins.range`），以保证程序功能正常。

---

### **核心观点**

核心观点是利用 Python 的抽象语法树 (AST) 技术，可以系统性地、自动化地修改源代码结构，从而实现代码混淆，在保持功能不变的同时，极大地降低代码的可读性。

---

### **总体框架**

本内容的核心框架是 **“解析-转换-生成 (Parse-Transform-Unparse)”** 的三步自动化代码处理流程：

1.  **解析 (Parse)**: 将人类可读的 Python 源代码作为输入，通过 `ast.parse` 将其转换为机器易于处理的抽象语法树 (AST) 对象。
2.  **转换 (Transform)**: 这是实现混淆的核心步骤。通过自定义的 `NodeTransformer` 遍历 AST，并针对特定类型的节点（如常量、比较运算、函数调用等）应用预设的混淆规则进行修改。
3.  **生成 (Unparse)**: 将经过修改、结构已经混淆的 AST 对象，通过 `ast.unparse` 转换回功能等价但语法晦涩的 Python 源代码字符串，作为最终输出。

---

### **概念关系图 (Mermaid Map)**

<Mermaid_Diagram>
graph TD
    subgraph "总体框架：自动化代码混淆"
        A["可读的源代码"] --> B{"1. 解析 (ast.parse)"};
        B --> C["抽象语法树 (AST)"];
        C --> D{"2. 转换 (ast.NodeTransformer)"};
        D --> E["修改后的AST"];
        E --> F{"3. 生成 (ast.unparse)"};
        F --> G["混淆后的源代码"];
    end

    subgraph "核心：AST转换技术 (具体混淆手段)"
        D -- "遍历并修改节点" --> H["定义 visit_Node 方法"];
        H --> I["目标: Constant 节点 (常量)"];
        H --> J["目标: Compare 节点 (比较)"];
        H --> K["目标: Call 节点 (函数调用)"];

        I -- "实现混淆" --> L["替换为等价表达式<br/>(e.g., True -> 1==1)"];
        J -- "实现混淆" --> M["颠倒比较操作数<br/>(e.g., a==b -> b==a)"];
        K -- "实现混淆" --> N["重命名内置函数<br/>(e.g., range -> round)"];
    end

    subgraph "运行时支持 (确保功能)"
         N -- "需要" --> O["生成函数名映射关系"];
         O --> P["注入前置代码 (exec)<br/>(e.g., round = builtins.range)"];
         P -- "作为前缀加入到" --> G;
    end

    style A fill:#90EE90,stroke:#333,stroke-width:2px,color:#333;
    style G fill:#FFB6C1,stroke:#333,stroke-width:2px,color:#333;
    style C fill:#FFFFE0,stroke:#333,stroke-width:1px,color:#333;
    style E fill:#FFFFE0,stroke:#333,stroke-width:1px,color:#333;
    style B fill:#ADD8E6,stroke:#333,stroke-width:1px,color:#333;
    style D fill:#ADD8E6,stroke:#333,stroke-width:1px,color:#333;
    style F fill:#ADD8E6,stroke:#333,stroke-width:1px,color:#333;
    style H fill:#F9F7D8,stroke:#333,stroke-width:1px,color:#333;
    style P fill:#F9F7D8,stroke:#333,stroke-width:1px,color:#333;
    style I fill:#f8d7da,stroke:#333,stroke-width:1px,color:#333;
    style J fill:#f8d7da,stroke:#333,stroke-width:1px,color:#333;
    style K fill:#f8d7da,stroke:#333,stroke-width:1px,color:#333;
</Mermaid_Diagram>

Content:
这期视频我们来讲防御性编程这个词原来是个好词本来指的是你在编程的时候多想一点可能发生的意外情况让你的程序更稳定但是这两年他隐身出了一个新的意思就是我写的这个程序如果没有人能看得懂就没有人能够取代我未知防御性编程但是这种防御性编程有一个前提就是你写的那个代码你自己得能看得懂如果你写那个代码你自己也看不懂那就白坊了对吧工资留你也没有用所以这期视频我们来讲这个自动化防御性编程也就是你手里留着一份你自己能看得懂的原代码然后根据这个原代码在生成一份别人看不懂的原代码好 我们看这个例子这个例子特别简单就是一个判断素数的寒数小于二反回FOSS否则的话过一遍如果能备挨成厨反回FOSS否则往回处然后我们打印1-49里面的所有素数结果也很知观没什么新鲜的那我们怎么来进行防御性编程呢首先我们看这个称FOSS之类的是不是太直光了这别人一眼就能看出来我们想反回的是真还是假对吧那我们就想能不能把这个程序里的称和FOSS换成其他等价的值这时候你肯定觉得很简单对吧我直接做一个文本T划不对吧了吗但是文本T划这种事太漏了对吧不符合我们频道的风格再说文本T划可能对付一下称跟FOSS还行面对一些其他的常量可能不是那么好用所以今天给大家介绍一个拍赏的BUTYMOSG叫做ASTAST就是AppsRex Syntax3中文叫做抽象语法数它可以把我们原来码根据给定的语法变成一个数状结构比如说这里我们把刚才的文件读进来然后Pars一下打印这棵树这个树大概就是这个样子上来定义了一个名字叫Isprime的韩树这个韩树有一个BUTYBUTY的第一个部分对应的是一个If statement这里如果N小于2的话就返回一个常量FOSS我们可以看到这个结点有一个ConstantValueDomgingFOSS这里就是我们感兴趣的地方了我们希望把Constant换成一个别的东西下面大家可以简单看一下比如说这是一个Falloop每一个AST的结点对应了一种语法结构这个Falloop的Buddy里也是一个If statement同样的我们可以找到这种Constant的结点当然大家可以看到除了刺捆FOSS之外像零这种常量也是Constant结点而AST这个Moggio还给了一个非常实用的功能叫做Anpors也就是它可以把一个语法树在恢复成圆代码当然这个圆代码不一定一模一样它只是恢复成可以生成这个语法树的圆代码比如说我们看Anpors出来的圆代码跟我们写的圆代码几乎是一模一样的只是中间少了一个空航所以我们就可以利用这个机制从圆代码生成语法树然后修改语法树中我们需要修改的部分最后把修改过的语法树再变回圆代码我们就完成了防御的过程好 那怎么修改语法树呢AST提供了一个可以继承的class叫做NoTransformer通过这个class我们可以进行对AST里面节点修改而修改的方式就是在我们眼神出来的这个class里面定义这种Visit下华界什么东西的方法当然啊 这里需要大家对拍当AST的节点比较熟比如这里我们知道我们要找的是ConstantExpression这个呢 大家就只能去翻门的也没有什么素程的方法回到来嘛我们知道我们要找的节点叫做Constant所以我们就定一个方法叫做Visit下华界Constant这个方法会在语法树变例的时候被调用而我们需要返回一个替代这个节点的新节点我们这里写了一个非常简单的逻辑还是大家先熟悉一下如果这个Constant的节点的bellulose是刺入的话我们就返回一个falseConstant节点反正如果是false我们就返回一个刺的节点如果都不是的话我们就返回原节点也就是不修改接下来我们建立这个Transformer Instance用这个Visit的韩树产生一个新的树如果我们对节点进行的修改大家记得运行一下FixMeasing Locations这个韩树会帮你在新加进去的节点上面填入一些跟原代玩的信息最后我们把这个语法树变回原代嘛然后把它打印出来大家可以对比一下啊我们把所有的刺都变成false那当然这只是一个例子我们把韩树的功能改了对吧这是不行的我们要保证韩树的功能同时让其他人读懂那这里我们就有很多方案了对吧比如说我们可以定一个全局编量叫做false然后把它的直射成处但那样的话第一你要想办法写入全局编量第二你的Lint很有可能会出错取决于你怎么写入的这个全局编量所以这里我们采用另外一种方式我们可以把刺跟false替换成一些直射刺跟false表达式这里我们稍微做一个小trick因为想手动够造一个表达式的node相对来说比较难所以这里我们把表达式的自负刷直接parts一下然后取body0的value这样我们就相当于用了ast这个库帮我们够建立一个表达式对应的node我们看这6个随便写了两个表达式一个结果是刺一个结果是false当然这里你要是高性的话你可以弄一堆表达式然后renden对吧你整一个大的list里面全是一些奇怪的表达式然后这些表达式的结果都是刺然后对于每一个不同的刺你都renden随机选一个这样你程序里的每一个刺跟false的表达式都不一样对吧这也都马上看分了我们现在这个代码就明显比刚才更难堵了对吧已经看不清哪反回的是刺哪反回的是false了接下来我们干嘛呢好我们做一个小修改吧我们在鞋比较的时候这两个比较的东西经常是有一个顺序的这个顺序一般是符合我们人类的正常思维的那我们这里就可以把等号两个东西掉个个在绝大多数情况下A等一等于B就意味着B等一等A当然了这是拍荡你切接有可能对吧如果你写那个代码不能这么处理你就别这么处理那这后我们要处理的节点是这个compair节点compair节点相比于concent的节点就稍微更复杂一点了首先这个节点下面还有其他的节点也就是说compair节点不是意识节点其次拍荡知识这种连续的compair因此它的操作和比较的东西都是list那我们为了简单旗舰我们只处理只有一个compair的情况好那由于这个节点不是业子节点我们在进行处理之前必须要先调用一下这个generic visit 弹数也就是让我这个节点包含的其他节点先处理 visit 这个事比如假设有这个compair里面有一个a等于等于赤这个赤我还要通过 visit constant 把它变掉呢所以要先变先调用这个generic visit变完了我包含的节点我再来变自己如果我比较的对象只有一个并且比较的方法式等于等于我就把左和右给换掉把右边的方左边来把左边的方右边去改完之后大家看这里我们的元代码就从n 于爱等于0变成了0等于n于爱了当然这个改动可能点小对吧大家看着不过眼我们就来点过眼的我们知道拍摊有很多bilt in 韩束是在元代码里面可以直接使用的比如说这里我们使用到了range是bilt in 韩束同样的print也是bilt in 韩束这个bilt in 韩束看起来是在太好懂了对不对我们能不能让它看着不这么好懂呢我们知道在拍摊里bilt in 韩束并不是reserved word他们只是一些语言 level的全局编辆而已也就是说只要我定义一些module level的全局编辆就可以在他寻找bilt in 韩束的时候给他解写来我们在这里换一下韩束名所对应的韩束就可以让这段代码看似调用的一个韩束实际上调用的是另外一个韩束了这里首先我们建立了一个mapping我们把所有bilt in 韩束的韩束名人拿出来然后让每一个韩束的韩束名随机对应一个韩束建立一个新的一对应的关系接着我们来处理这个靠节点同样的也要先ginnavich visit因为这个靠节点下面也有其他的节点如果靠这个今天使用的韩束是通过名字来调用的我们就检查一下这个名字是不是在我们的mapping里也就是调用的韩束名是不是一个bilt in 韩束如果是的话我们建立一个新的靠节点把他的名字变成我们给他对应的名字也就是在这个园代码里面我们把所有的bilt in 韩束都换了一个名人换成了其他的bilt in 韩束比如我们随便跑一下这个range就变成了round的 对吧然后下面的print 变成了is instance当然如果光正变的程序不对 对吧因为我们只是自己建立了一些这个mapping我们写出来的文件并不知道我们改了这件事所以我们要在这个module之前改一下全局变量我们想达到的效果大约是round的等于bilt in 点range然后is instance等于bilt in 点print但是如果直接这么写的话看着太漏了 对吧被人一眼就看出破诈了我们多多少少得让他更加难以识别一点所以呢我们做这么一件事首先建立一个set把所有用到的bilt in 韩束都记住下来这个操作是让我们少生成一点没有必要的待马我们不需要把所有我们mapping的bilt in 韩束都写出来只需要把用到的写出来就可以了每一次改node的时候把这个用过的bilt in 记住下来接下来我们生成一度而在module 运行之前需要运行的待马首先我们要input built in然后对于每一个mapping我们都做一下这个target等于bilt in 点原来那个方式比如这里可能是round的等于bilt in 点range也就是我们建立了一个新的全局变量round然后round的值是bilt in 点range这样我们调用round的时候实际上调用的是内置韩束range最后我们把这段待马给做一个bilt in 专业bilt in 专业的动物不是加密但它可以让你的意图不那么明确的直接出现了原来马上我们把这段生成的待马放到我们刚才原来的前面用exec 执行一下这样我们就建立了我们全局变量的那个mapping我们看运行完了之后是这个效果我们把刚才打印的东西写入一个文件可以看到左边就是我们新的打印素术的待马了简单看一看可以说还是比较离谱的我们运行一下还是原来的味道功能没有任何改变可以说我们还是比较圆满的完成了任务当然这只是抛转引运对吧我们这期视频只是带您入个门告诉你有什么样的方法你可以用这个方法对asT进行任何你想做的修改你可以去改边量连组的吧你可以去改其他的一些常亮我们这里就不一一演示了其实这种所谓防御性编程自古以来就有只不过那时候它有一个更专业的名字叫做混销我们这次给大家来的是一个相对娱乐性一点的混销就是怎么让你的Lintr不报警的情况下还能让这个待马让人看不住当然了真的编程的时候不推荐打这么做就是娱乐一下好那这一视频的理解喜欢它几点关注主点赞跟投币的同学们都记不需要防御性编程也不会被公司毕业
