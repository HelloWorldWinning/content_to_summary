Timestamp: 2025-05-15T10:36:11.566825
Title: Gemini 2.5 Pro vs Claude 3.7 Sonnet: Which AI is better for coding?
URL: https://www.youtube.com/watch?v=AVdVJ_hD_vo
Status: success
Duration: 19:01

Description:
好的，这是对文本内容的提炼和总结：

**核心观点：** Gemini 2.5 Pro 在大型项目代码编写方面表现出色，与 Claude Sonnet 3.7 相比具有竞争力，尤其是在处理大型项目时，更大的上下文窗口使其更具优势。

**总体框架：**

1.  **引言：**
    *   程序员已广泛使用 AI 和大型语言模型。
    *   此前 Claude Sonnet 在代码编写方面一直领先。
    *   Google 的 Gemini 系列模型起初表现不如 Anthropic 的 Claude。
2.  **Gemini 2.5 Pro 的崛起：**
    *   Gemini 2.5 Pro 在基准测试中超越了 Sonnet 3.7。
    *   Gemini 2.5 Pro 拥有更大的上下文窗口（100 万 token）。
3.  **实测对比：**
    *   使用密码管理器项目 DeriVault 进行测试。
    *   测试模型在大型项目中编码的能力和响应质量。
    *   使用大上下文技术（将整个代码库上传到模型）。
4.  **Claude Sonnet 3.7 的工作流程：**
    *   使用 Claude Projects 功能，上传项目代码库。
    *   使用 AI Digest 工具生成包含整个代码库的 markdown 文件。
    *   要求 Claude 提出改进建议并编写代码。
5.  **Gemini 2.5 Pro 的工作流程：**
    *   使用 AI Studio，选择 Gemini 2.5 Pro 模型。
    *   将项目指令设置为系统指令。
    *   上传代码库文件。
    *   要求 Gemini 提出改进建议并编写代码。
6.  **测试结果对比：**
    *   改进建议：Gemini 的建议更侧重于项目分析，而 Claude 更侧重于功能实现。
    *   暗黑模式实现：要求两个模型为应用程序实现暗黑模式。
    *   代码质量：Gemini 生成的代码更简洁，但 Claude 在某些方面考虑更周全。
    *   最终评价：Gemini 在暗黑模式实现方面略胜一筹。
7.  **结论：**
    *   Gemini 2.5 Pro 在编码方面表现出色，尤其是在处理大型项目时。
    *   Gemini 2.5 Pro 具有更大的上下文窗口和免费使用的优势。
    *   建议在大型编码项目中使用 Gemini 2.5 Pro。

<Mermaid_Diagram>
```mermaid
graph TD
    subgraph Claude Sonnet 3.7
        A[Claude Projects] --> B(上传代码库);
        B --> C{AI Digest};
        C --> D[生成 Markdown 文件];
        D --> A;
        E[提出改进建议] --> F(代码实现);
    end

    subgraph Gemini 2.5 Pro
        G[AI Studio] --> H(设置系统指令);
        H --> I[上传代码库];
        J[提出改进建议] --> K(代码实现);
    end

    L[DeriVault 项目] --> B;
    L --> I;

    M[实测对比] -- "暗黑模式实现" --> F;
    M -- "暗黑模式实现" --> K;

    N[大型语言模型] -- 性能对比 --> M;

    style A fill:#f9f,stroke:#333,stroke-width:2px
    style B fill:#ccf,stroke:#333,stroke-width:2px
    style C fill:#ccf,stroke:#333,stroke-width:2px
    style D fill:#ccf,stroke:#333,stroke-width:2px
    style E fill:#ffc,stroke:#333,stroke-width:2px
    style F fill:#ffc,stroke:#333,stroke-width:2px
    style G fill:#f9f,stroke:#333,stroke-width:2px
    style H fill:#ccf,stroke:#333,stroke-width:2px
    style I fill:#ccf,stroke:#333,stroke-width:2px
    style J fill:#ffc,stroke:#333,stroke-width:2px
    style K fill:#ffc,stroke:#333,stroke-width:2px
    style L fill:#fff,stroke:#333,stroke-width:2px
    style M fill:#ccf,stroke:#333,stroke-width:2px
    style N fill:#f9f,stroke:#333,stroke-width:2px
```
</Mermaid_Diagram>


Content:
WEBVTT Kind: captions Language: en If you're a programmer, then you're likely already using AI and large language models as part of your workflow. Of course, as developers we want to use the best models possible. And for some time now, Claude Sonnet has been the undisputed king of models used for programming. It has earned the top spot in multiple code-focused benchmarks, such as the Aider LLM leaderboard and LiveBench. And when Anthropic recently upgraded the Sonnet model from 3. 5 to 3. 7, it gained an even bigger lead in benchmarks. The Gemini series of models from Google haven't quite had the same fanfare or good benchmark scores. It seems pretty clear that Google is choosing a different strategy than Anthropic here. Instead of trying to be the best model, they're integrating their own models into different parts of the Google ecosystem, from Gmail to Docs to their enterprise offerings. But that strategy seems to have been somewhat upended, in a positive way, by the release of Gemini 2. 5 Pro. This model has quickly overtaken the top spot from Sonnet 3. 7 in many benchmarks. It also sports a 1 million token context window, or about 4 times larger than what Sonnet 3. 7 offers as of today. This increased context window can potentially make Gemini a more flexible model, especially if your projects contain a lot of code or documentation. But enough about specs. How does it feel to actually use this new Gemini model for day-to-day programming? Is it really as good as benchmarks say, or does reality fall short of the expectations? That's why today I'm gonna put Gemini 2. 5 Pro through its paces, and see how it stacks up with the latest Claude Sonnet 3. 7 thinking model, when coding in a large project with hundreds of files. I'll devise a number of tests in one of my real-world projects, and then we'll see how well Gemini stacks up versus Claude, not only in its programming chops, but also the quality and feel of the responses. To test all this, I'll be using my large context technique, as shown in one of my earlier videos. If you're interested in using this technique for your projects, you can find a link to the video in the card above. Without further ado, let's get into it. Now let's go head-to-head with these models in a not very scientific, but really a real-world test. So let's first start with what we're going to be testing. So the project we're going to be working with today is a password manager that I'm working on called DeriVault. It's an offline-first deterministic password manager written in Svelte and SvelteKit. And we don't really need to know that much about the project, just that it has like a number of different routes. You can save the different sites you have, you can get the passwords for your different sites, and that's about it. Free, simple application has a few screens, and we're going to see if both these LLMs can actually do any work in this documentation, and also suggest improvements for things to do. And to start with, I'm going to show you my Claude workflow, which is actually how I've been developing this application. So what I'm doing is I'm using Claude projects. So I have this project called DeriVault, and I have added a default prompt for it that tells it all the things that this project is about. And I'm also adding my project code base. So all of the code for my project is uploaded to this Claude projects feature. And that allows me to, in a really efficient way, ask the LLM to do pretty complicated things, because it doesn't have to do any sort of agentic workflow, like you would see with Claude or Claude Code. Instead, it has all the projects in the context, and it can reference the files freely. And if your project is not super big, this is a really great alternative. So you might wonder, how do I get the whole code base in here? I use a tool that I built for that called AI Digest. It's this package right here, and you don't even need to install it, you can use it with npx. I'm going to show you how I do it in the project. So all I need to do here is to go to a terminal and type "npx ai-digest". And then in a few seconds, you are going to get a codebase. md markdown file that has a collated, merged version of your whole code base. So what I do then is simply to upload it into Claude projects. And now I'm ready to go. I have the most up-to-date version of the code available to use for prompting. Now let's have Claude suggest some improvements for this project. And of course, I'm going to use Extended Thinking, because Gemini Pro 2. 5 is also a Thinking model, so it only seems fair that that would give them the best edge against each other. Now that took a couple of minutes actually, but let's have a look first at the brainstorm chain, or rather the chain of thought chain. So Claude was thinking about the current features, and then it suggested a few features here. And what's really funny is that it not only suggested a bunch of features, but it actually started writing those features out. And I think this is quite a fun peculiarity of Claude. I think that some of their older models have been seen by people as kind of a little bit lazy. Like it wouldn't, you know, it would just tell you like, "Oh, you start by doing this, " and so on and so forth. And people really didn't like that, so I think they tuned these later models to be extremely elaborate in their writing. If you give them a task, they're gonna do the task, and sometimes even more, which can be to the detriment of whatever it is you're trying to do. Let's have a look here at what it suggested. So, customizing the password character set, and it just gives me the code right away here for the whole feature. Dark mode support, health check, password categories and tags, an autolock feature, secure notes, password sharing, emergency recover options. I would say all of these are really good features, and just the fact that it actually like wrote out a basic implementation of each is quite impressive, honestly. Now, let's go ahead and repeat this experiment with Gemini 2. 5 Pro. So to use Gemini 2. 5 Pro, I believe as of today it is only available in the AI Studio. Now, right off the bat, AI Studio is not really comparable to the Claude offerings, because Claude Pro, the consumer level offering and the API, are both said to not train on your code. So Anthropic will not train on the prompts that you provided. Meanwhile, at AI Studio, I do believe that you have to actually approve them to train on the inputs and outputs. So even though as of today, Gemini 2. 5 Pro experimental is free, you might not be able to use it, because you maybe don't want Google to have your source code. But this app that you're working with is open source, so let's press on. So I'm in AI Studio now, I have selected this brand new 2. 5 Pro experimental model. And in order to kind of give it a fair chance, I'm going to reproduce the same workflow. So I'm going to add a system instruction, which is going to be the equivalent to the system prompt that we have, or rather the projects prompt. So I'm going to use these project instructions as the system instructions. We don't have the same type of way to upload files into projects like in Claude, but we can, of course, upload a file. So I'm just going to go ahead and upload the same code base file into Gemini. It's going to take a few seconds. And what's cool here is we get to see how many tokens it is. It's 126, 000 tokens. And the reason it's so many is because I also include the Svelte and SvelteKit documentation into the projects to kind of give it an edge in writing Svelte and SvelteKit. So that's something to keep in mind. There we go. And that's basically it. That's the whole setup. And I'm going to go ahead and ask exactly the same prompt. And let's see how Gemini 2. 5 Pro does. All right. Then it has finished. Let's first look at the chain of thought here. Understand the core concepts, identify strengths and weaknesses, brainstorm categories for improvement. Honestly, I like this chain of thought better than the Claude one, because I do think these are more important questions to ask rather than if you look at the Claude one. That was more about, like, existing current features and potential additions. While this is, I think, a better analysis of the existing project. And then we go into the actual suggestions here. Let's have a look. So we have time-based, one-time passwords. And this is not a bad idea. I don't know exactly how well it aligns with the whole app concept. It's a little bit more out there, I would say, than any of the Claude suggestions. Then it has a very similar suggestion, customizable password generation parameters, secure notes, which is also a feature that Claude suggested, a browser extension that is a great feature. We have tagging here as well, which is a suggestion Claude did as well. Favicon fetching, that's pretty funny. So showing the Favicons. Again, not 100% sure that is, like, in line with a privacy-focused password manager app, but it is definitely an interesting suggestion. Better search. I like how it broke it down more by, like, what kind of category of feature it is. That's pretty nice. And then it suggested a few advanced features, like a history visualization. Again, it's, you know, I. . . These are good suggestions. And, you know, if you told me this was Claude, I would believe it. But having seen the Claude output just now for the same prompt, I do prefer Claude, like, a little bit more. Now, you know, of course, this is just a simple test. So your particular prompt or project might work better in Gemini. I do still think this is very, very impressive. This is definitely a lot better than the old models. So now let's ask it to implement an actual feature. So maybe we can pick something from these features that it suggested. After having, like, looked it over, let's see if we can ask both of these LLMs to implement a dark mode for the app. This can be a little bit challenging, I think, because it has to change a lot of different files. And I'm actually not sure if, like, how many files would need to change for it to work. But let's try it and let's start with Claude. So one of the things I like most about Claude is that it works really well across many different files. It can make changes across many different files in a single prompt. And also that it actually listens to me when I tell it to provide me the full file. So what it actually did was, like, in the cases where it modified existing files, it's given me, like, the whole file back. And I just need to kind of copy paste or you can use an MCP for that if you're using Claude, but kind of easily copy paste stuff into your existing project. So I'm going to go ahead and I'm going to copy and paste all this code into my project. I'm going to look at the diffs and I'm going to come back and I'm going to tell you what I thought of Claude's work. All right. So after a lot of copying and pasting, this is what I ended up with. This is the kind of zero shot that Claude presented. Looks pretty, pretty good at first glance. I don't see the buttons here, but I don't think they were here before you entered the password, before either. Let's go ahead and enter my vault password. And let's see here. Everything looks good. This page almost looks good. It did miss this one field. Doesn't feel like a giant deal, honestly. Can easily be reprompted and asked for. But all the different components look okay. This text, yeah, everything looks great. This, the styling of this button is slightly different. I guess this is the toggle for the theme. Let's see. Okay. So we have light, dark, and the kind of like OS system level. You know, very good. I could easily reprompt it to fix these minor issues, but all in all, Claude did a good job. I'm also going to look at the code a little bit and see what I think about that. So as we saw, like why this features is kind of like a good test, but also maybe a difficult test is that it requires changes in a lot of different files. So there's a lot of different parts of the code that needs to change. And the LLM kind of has to juggle all these and remember like what it did where. But looking at the code, it did create a few new different files. This theme provider pattern, it's not the most common sort pattern, I will say. Typically you would use something like context for this. But what is nice is that all of this is in line with our kind of existing design system. That we have and everything looks pretty good. And then it did do this theme provider thing that is a little bit strange. And then it asked me actually manually to update the backgrounds on all pages, which is like, it didn't write out all the code for it, but it is very important to do so because that's how you get this black background on each page. More than approved for Claude. Let's see how Gemini fares with the same prompt. All right, now Gemini is done and it also seems to have generated several different files. So again, I'm gonna go ahead and paste these in and then let's see how that works. Okay, and this is what we ended up with on the Google side. So again, it's looking really, really good. It really looks like it took advantage of all the Tailwind kind of built in dark mode stuff. Because everything looks good except for this password field again. It didn't add a theme toggle here. Instead, it added a toggle in the settings here. So same thing here. You can select between the device, the light mode and the dark mode. Now we didn't specify where we wanted the toggle place. And I think both of these are totally, totally valid things to do. I'm going to go through the code for each change here and I'm going to see which one I actually think did best on the coding side. Now I've reviewed both of the change sets from Claude and Gemini. And I thought I would go over a few of the similarities and differences. In terms of pure code size, the Claude PR turned out to be a little bit bigger. But that is actually because it did a thing that I didn't even see, which is that it added the theme toggle in the settings page as well. So as you can see here, now I'm at the on the Claude one, it added the theme toggle down here, but it also added it up here. And personally, I'm not really a fan of all the things it did here. Like it wrote like a description text, but no other items have a description text like this. And while it does work, I do feel like this is a little bit over-engineered for what I asked it to do. But once you kind of take away that change, you see here 202 additions. If we compare it to the Gemini one, which is 160 additions, they are more or less equal code-wise if you take away that extra settings page. But now when it comes to code, first of all, there are some things that they both, the both modes did, that is really impressive. One of these was that both models correctly understood that there's going to be a flash of like the wrong theme when you load the page. And they tried to fix it by making a change to app. html, which is a file that in SvelteKit runs very, very early in the sort of bootstrap process, meaning we can get around the issue of this white blink that you would see in a typical client side application. So that is really impressive. Claude was a little bit more wordy here, but eventually they did the same thing, which is to use match media to figure out the preference and save that in a local storage. Then, as I mentioned, I think Claude did something strange here with this theme provider. It's not a pattern that I'm very familiar with in Svelte. It's a pretty common pattern in React. And I think Claude is very tuned to React in general. The toggle buttons themselves look fairly, fairly similar and nothing really out of the ordinary here between Gemini and Claude. Again, I do think that Claude kind of over-engineered some stuff here. Like it made this derived store that does a bunch of logic inside of it to kind of, again, check match media. This feels a little bit over-engineered. And for that reason, it also created a whole separate file just to store all those like special things around theming. Meanwhile, Gemini just added the theme as a store and that was it. So again, I would give an additional point to Gemini for that. One thing that I am not as happy about is that Gemini put all of the dark mode code in the root layout, which is honestly, it is a little bit like it doesn't belong there. It really belongs in some sort of context or something along those lines. So this is not my favorite change. But looking at it as a whole, you know, it almost pains me to say, but I prefer the Gemini output here. And like I mentioned, this is kind of like a worst case scenario. Like you typically don't ask your LLM to refactor and add dark mode to a whole app, but both of them did it, which I was extremely surprised because I genuinely thought that Gemini would fall apart at such a difficult task. But it did it and I'm extremely impressed. And I think that with the fact that it's free right now, if you don't mind the privacy implications and with the fact that it has four times the context of Claude, I think this is very, very competitive. If you want to do like coding with really, really big projects, it's hard not to recommend Gemini. I'm going to be spending a lot more time with Gemini from now on, I think. That's it for the video. Thank you so much for watching. I hope you like this little head to head between the two models. If you'd like to see more content like this, please leave a comment. Or if you have a different experience where you thought that maybe Claude did better for your particular use case, please leave a like and subscribe and I'll see you in the next video.
