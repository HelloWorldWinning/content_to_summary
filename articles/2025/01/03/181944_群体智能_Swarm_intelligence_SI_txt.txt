Timestamp: 2025-01-03T18:19:44.806690
Title: 群体智能（Swarm intelligence，SI.txt
URL: Text file upload
Status: success
Duration: 0:00

Description:
## Summary of Swarm Intelligence and Bio-Inspired Algorithms

**I. Core Ideas:**

*   **Introduction:**
    *   Swarm Intelligence (SI) and bio-inspired algorithms have garnered significant research interest in optimization and computational intelligence.
    *   These nature-inspired metaheuristics, particularly SI-based algorithms, are widely used due to their advantages over traditional methods.
    *   This article analyzes the key components of these algorithms: evolutionary operators and their functions.
    *   The aim is to provide an overview for critical analysis of individual algorithms in later articles.
*   **Optimization Algorithm Analysis:**
    *   Optimization algorithms are iterative processes, aiming to refine an initial guess to converge on an optimal solution.
    *   These algorithms can be viewed as self-organizing systems, Markov chains, or through their core components like exploration and exploitation.
    *   An "ideal" algorithm for any problem may not exist, but the search for efficient ones continues.
    *   The core idea of the algorithm is to balance exploration of the search space and exploitation of promising solutions.
    *   Self-organization of the algorithm involves having a large solution space with high degrees of freedom, with a selective mechanism, and allows long term evolution.
*   **Evolutionary Operators:**
    *   **Crossover:** Primarily for mixing and local search within subspaces to enhance convergence.
    *   **Mutation:** A global search mechanism for introducing diversity and potentially escaping local optima.
    *   **Selection:** Drives the system towards desired states by favoring better solutions, providing a form of exploitation.
*   **Specific Algorithms Analysis:**
    *   The article analyzes various algorithms, including Simulated Annealing, Genetic Algorithms, Differential Evolution, Ant and Bee Algorithms, Particle Swarm Optimization, Firefly Algorithm, Cuckoo Search, Bat Algorithm, Harmony Search, and Flower Pollination Algorithm.
    *   Most of the mentioned algorithms mainly use variation and selection, with crossover playing a less significant role in some of them.
    *   The effectiveness of crossover, mutation and selection is dependent on the algorithm and problem and is still an area of research.
*   **Parameter Tuning and Control:**
    *   Algorithm parameters greatly impact their performance, and tuning is essential for optimization.
    *   Parameter tuning is a hyperoptimization problem, seeking optimal parameter sets.
    *   Parameter control, changing parameters during iteration for better performance, is another challenging area.
    *   Parameter tuning and parameter control can be viewed as a two-objective optimization problem and solved with multi-objective optimization methods.
*   **Discussion:**
    *   The balance of exploration and exploitation through different evolutionary operators requires further research.
    *   The impact of specific operators on an algorithms performance is not yet completely understood.
    *   Although there is an importance of developing new algorithms, the focus should be on more efficient and novel approaches that solve key problems in optimization.

**II. Core Point:**

*   The core point is the analysis of nature-inspired metaheuristic algorithms to understand their optimization mechanisms, which centers on the balance between exploration and exploitation, driven by evolutionary operators and parameters.

**III. Fundamental Point:**

*   The fundamental point is that while many algorithms have been developed, there's still a need for fundamental insights into how to achieve a better balance between exploration and exploitation, as well as ways to dynamically and effectively control the algorithms' internal parameters.

---
## 简体中文总结：

**I. 核心思想:**

*   **简介:**
    *   群体智能（SI）和生物启发式算法在优化和计算智能领域引起了广泛的研究兴趣。
    *   这些自然启发的元启发式算法，特别是基于SI的算法，由于其相对于传统方法的优势而被广泛使用。
    *   本文分析了这些算法的关键组成部分：进化算子及其功能。
    *   目的是为读者提供一个概述，以便在后续文章中批判性地分析每种算法。
*   **优化算法分析:**
    *   优化算法是一个迭代过程，旨在将初始猜测改进并收敛到最优解。
    *   这些算法可以被视为自组织系统、马尔可夫链，或者通过其核心组件（如探索和利用）进行分析。
    *   针对任何问题的“理想”算法可能不存在，但对高效算法的探索仍在继续。
    *   算法的核心思想是平衡搜索空间的探索和有希望的解决方案的利用。
    *   算法的自组织涉及到：拥有足够大自由度或状态的解空间、选择机制和允许长期演化。
*   **进化算子:**
    *   **交叉:** 主要用于子空间内的混合和局部搜索，以增强收敛性。
    *   **变异:** 一种引入多样性并可能逃脱局部最优的全局搜索机制。
    *   **选择:** 通过偏好更好的解决方案来驱动系统朝着期望的状态发展，提供一种利用形式。
*   **具体算法分析:**
    *   文章分析了各种算法，包括模拟退火、遗传算法、差分进化、蚁群和蜜蜂算法、粒子群优化、萤火虫算法、布谷鸟搜索、蝙蝠算法、和声搜索和花朵授粉算法。
    *   大多数提到的算法主要使用变异和选择，而交叉在其中一些算法中作用较小。
    *   交叉，变异和选择的有效性取决于算法和问题，并且仍然是一个研究领域。
*   **参数调整和控制:**
    *   算法参数对其性能有很大影响，参数调整对于优化至关重要。
    *   参数调整是一个超优化问题，旨在寻找最佳参数集。
    *   参数控制，在迭代过程中改变参数以获得更好的性能，是另一个具有挑战性的领域。
    *   参数调整和参数控制可以被视为双目标优化问题，并使用多目标优化方法来解决。
*   **讨论:**
    *   通过不同的进化算子来实现探索和利用的平衡，需要进一步研究。
    *   特定算子对算法性能的影响尚未完全了解。
    *   尽管开发新算法很重要，但重点应该放在更高效和新颖的方法上，以解决优化中的关键问题。

**II. 核心要点:**

*   核心要点是对自然启发的元启发式算法进行分析，以了解其优化机制，其核心在于探索和利用之间的平衡，由进化算子和参数驱动。

**III. 基本要点:**

*   基本要点是，尽管已经开发了许多算法，但仍然需要深入了解如何在探索和利用之间实现更好的平衡，以及如何动态有效地控制算法的内部参数。


Content:
群体智能（Swarm intelligence，SI）和生物启发计算引起了研究人员极大的兴趣和关注。在优化、计算智能和计算机科学领域，生物启发式算法尤其是基于 SI 的算法已经变得非常流行。事实上，这些自然启发式的元启发式算法现在是最广泛使用的优化和计算智能算法。基于 SI 的算法，如蚁群优化算法、蜂群优化算法、粒子群优化、布谷鸟搜索和萤火虫算法等与传统算法相比具有许多优点。

这里，我们分析了这些自然启发式算法的关键组成部分，即进化算子和相应的功能。我们不打算对每种算法进行详细的介绍，因为这些算法将在后续文章中逐一介绍。这里的主要目的是提供一个概述，以便读者可以在阅读后续文章的同时批判性地分析每个算法。

简介
正如我们在优化算法导论 中讨论的那样，优化算法是一个从初始猜测开始的迭代过程。经过一定的（足够大的）迭代次数后，它可以收敛到一个稳定的解，在理想情况下，是感兴趣问题的最优解 [19, 30]。这本质上是一个以解为状态、以收敛解为吸引子的自组织系统。这种迭代的自组织系统可以根据一组规则或数学方程进行演变。因此，这样一个复杂的系统可以相互作用并自组织地形成一定的收敛状态，呈现出一些自组织的突现特征。在这个意义上，一个有效的优化算法的适当设计相当于找到有效的方法来模拟自组织系统的进化，特别是进化的生物系统[ 1, 16]。

或者，我们可以把算法看作马尔可夫链，算法的行为受其解的状态和转移控制。事实上，不同的视图可以帮助从不同的角度分析算法。我们还可以根据其关键组成（如探索和开发）或使用演化算子生成解的方式来分析算法。这里，我们从不同的角度回顾和讨论大多数自然启发式算法。

优化算法分析
可以从不同的角度分析优化算法。这里，我们将它分析为一个迭代过程、一个自组织系统、两个冲突组件和三个演化算子。

作为迭代过程的算法
从理论上讲，算法 A 是一个迭代过程，其目的是对给定问题，在迭代或时间 t ，从当前的解 $x^t$ 上产生新的更好的解 $x^{t+1}$。例如，Newton-Raphson 法找 f(x) 的最优值等同于在 d 维空间中搜寻 $f^{'}(x) = 0$ 的临界点或根 [28, 25]。即，

 
 

很明显，在 $f^{'}(x^t) \to 0$ 的最优点附近，收敛速度可能会变得非常慢。有时候真正的收敛速度可能不会那么快。一个简单的改进收敛的方法是修改之前的公式引入参数 p，如下所示：

 
 
 

这里 $x_*$ 是最优解，或迭代公式的一个不动点。值得指出的是，参数 p 的设置取决于迭代公式和待优化目标 f(x) 的最优 $x_*$。

一般来说，我们可以将前面的迭代方程写成

 

对于确定性方法是有效的。然而，在现代元启发式算法中经常使用随机化，在很多情况下，随机化以一组 m 个随机变量 $\epsilon = (\epsilon_1, \epsilon_2, ..., \epsilon_m)$ 的形式出现在算法中。例如，在模拟退火中，有一个随机变量，而在粒子群优化 [17] 中，有两个随机变量。另外，算法中通常有一组 k 个的参数。例如，在粒子群优化中，有四个参数（两个学习参数，一个惯性权重和一个种群规模）。一般来说，我们可以有一个参数向量 $p = (p_1, p_2, ..., p_k)$。在数学上，我们可以写出一个具有 k 个参数和 m 个随机变量的算法

 

其中 A 是从给定解（一个 d-维向量 $x^t$）到新解向量 $x^{t+1}$ 非线性映射。

值得指出的是，上述公式 (4) 是针对基于轨迹的（trajectory-based）单代理（single-agent）系统。对于具有 n 个解的群算法，我们可以将前面的迭代公式扩展为：

 
 
 

其中 $p_1, ..., p_k$ 是 k 个算法相关参数，$\epsilon_1, ..., \epsilon_m$ 是 m 个随机变量。

算法 (4) 的这个观点主要是动态的或者泛函的。认为泛函 (4) 是一个动态系统，它将向平衡态或吸引子态演化。原则上，系统的行为可以用 A 的特征值和它的参数来解释。然而，这并没有提供足够的关于多样性和复杂的特点的洞察力。自组织可以提供更好的洞察力，正如我们可以看到的那样。

理想算法？
在给定精度下寻找最优解所需的迭代次数 t 在很大程度上决定了算法的总体计算工作量和性能。一个更好的算法应该使用更少的计算和迭代。

在迭代算法或公式 (1) 的极端情况下，理想算法只需要一次迭代 t = 1。你可能想知道这样的算法是否在实践中存在。答案是要看情况。实际上，对于二次函数，如 $f(x)=ax^2$（其中 a > 0），众所周知的 Newton-Raphson 法

 
 

是理想的算法。如果我们从任意随机猜测 $x_0 = b$ 开始迭代，则有

 
 
 

给出全局最优解 $f_* (0) = 0, \text{ at } x_* = 0$。

显然，我们可以将这个思想扩展到整个二次函数类。甚至可以扩展到更广义的凸函数。但是，许多问题不是凸的，当然也不是二次的。因此，所谓的理想算法一般不存在。正如我们前面提到的那样，没有很好的解决 NP-难（NP-hard）问题的算法。

文献中有许多优化算法，没有一个算法适用于所有的问题。尽管如此，寻找有效的算法仍然是研究人员的主要工作。这种寻找“圣杯”的努力将继续下去，除非某些人在分析上证明并非如此。

表 1 自组织与优化算法的相似性

自组织	特征	算法	特性
噪声、扰动	多样性	随机性	逃脱局部最优
选择机制	结构	选择	收敛性
重组	状态改变	演化	解
自组织系统
一个复杂的系统可能是自组织的条件：当系统足够大，具有足够高的自由度或可能的状态 S。此外，必须允许系统在远离噪声和远离平衡状态的长时间内演化。最重要的是，必须有选择机制来确保自组织是可能的。也就是说，复杂系统中自组织的主要条件是：

系统规模较大，具有足够数量的自由度或状态
系统中有足够的多样性，如扰动、噪声或混沌边缘，或者远离均衡。
系统允许长期演化
系统中存在选择机制或不变的法则
也就是说，一个具有状态 S 的系统由具有一组参数 α 的机制 α(t) 驱动将向自组织状态 $S_*$ 演化。也就是

 

从自组织的角度来看，算法 (4) 是一个自组织系统，从许多可能的状态 $x^t$ 开始，并试图收敛到由算法 A 驱动的最优解/状态 $x_*$：

 

通过比较自组织的条件和算法的特点，我们可以得出如表 1 所示内容。

然而，自组织系统和算法之间有一些显着的差异。对于自组织来说，自组织状态的途径可能并不清楚，时间也不是一个重要的因素。另一方面，对于算法来说，使算法收敛的途径是非常重要的，并且收敛的速度是至关重要的，因此需要最小的计算代价才能达到真正的全局最优。

探索和开发
自然启发优化算法也可以从它们探索搜索空间的方式进行分析。实质上，所有的算法都应该有两个关键组件：开发和探索（exploitation and exploration），这也称为强化和多样化 [4]。

开发利用从感兴趣的问题中获取的任何信息来帮助生成优于现有解的新解。但是，这个过程通常是局部的，信息（如梯度）也是局部的。因此，这是局部搜索。例如，爬山法是一种使用导数信息来指导搜索过程的方法。事实上，新的步骤总是试图爬上局部的梯度。开发的优点是通常会有很高的收敛速度，但是它的缺点是它可以陷入局部最优，因为最终的解大体上取决于起点。

另一方面，探索使搜寻搜索空间更有效率，可以产生远离当前解的多样性足够的解。因此，搜索通常是全局范围内的。探索的优势在于它不太可能陷入局部最优，全局最优可以更容易获得。然而，由于许多新的解远不能满足全局最优的要求，因此它的缺点是收敛速度慢，并且会浪费一些计算量。

因此，需要最终的平衡，以使算法达到良好的性能。太多开发和太少探索意味着系统可能会更快地收敛，但是找到真正全局最优的可能性会很低。另一方面，太少的开发和太多的探索可能会导致搜索路径漫长、收敛速度非常慢。最佳平衡意味着适当的探索和开发量，这可能导致算法的最佳性能。因此，平衡至关重要。

然而，寻求达到这种平衡的方式仍然是一个悬而未决的问题。事实上，在现有的文献中，没有算法声称达到了这种平衡。实质上，平衡本身是一个超优化问题，因为它是优化算法的优化问题。另外，这种平衡可能取决于许多因素，如：算法的工作机制、参数的设置、这些参数的调整和控制，甚至包括要考虑的问题。此外，这种平衡可能并不普遍存在，它可能因问题而异。

这些未解决的问题和谜团可能会激发这方面的更多研究。我们可以预计在不久的将来相关文献的数量将会增加。

演化算子
直接查看算法的操作方法，也有助于了解其工作原理。让我们以遗传算法为例。遗传算法（Genetic algorithms，GA）是一类基于生物系统达尔文进化（演化）抽象的算法，由 J.Holland 和他的合作者在 20 世纪六七十年代首创。遗传算法使用遗传算子，如：交叉、重组、变异和选择 [14]。已经表明，遗传算法具有超过传统算法的许多优点。三个优点是明显的：无梯度、高度探索性和并行性。GA 不需要梯度/导数信息，因此 GA 可以处理复杂的、不连续的问题。交叉和变异的随机性使得 GA 能够更有效地探索搜索空间，更有可能达到全局最优。另外，遗传算法是基于种群的，具有多个染色体，因此可以以并行的方式实现 [29, 30]。

遗传算法中的三个关键演化算子可以概括为：

交叉（Crossover），两个亲本染色体（解）的重组。通过将一个染色体的一部分与另一个染色体的相应部分交换以产生后代（新的解）。
变异（Mutation），改变染色体的一部分（一位或几位）以产生新的遗传特征。在二进制编码中，变异可以简单地通过在 0 和 1 之间翻转来实现。变异可以在单个位点或多个位点同时发生。
选择（Selection），适者生存，意味着最高质量的染色体和特征将保留在种群中。这通常会采取某种形式的精英主义，最简单的形式是让最好的基因传给下一代。
从理论上讲，交叉是一个混合的过程，在子空间中广泛的局部搜索 [2, 3]。可以通过一个例子来说明。对于总搜索空间为 $\Omega = \Re^8$ 的 8 维问题，如果父解是 $\mathbf{x_1} = [aaaaaabb],\quad \mathbf{x_2} = [aaaaaaaa]$，其中 a 和 b 可以是二进制值，或者问题解的第 i 个组成/维度的实数值。经过交叉，后代将是四种可能之一：[aaaaaaba]、[aaaaaaab]、[aaaaaaaa] 或 [aaaaaabb]。无论如何，前六个变量总是 [aaaaaa]。这意味着交叉或重组将在子空间（该空间仅第 7 个和第 8 个变量发生变化）产生解。在前 6 个变量不同的子空间中将不存在解。换句话说，在这种情况下，交叉算子将仅在子空间 $S = [aaaaaa] \cup \Re^2 \in \Omega$ 内创建解。因此，交叉是一种局部搜索算子，尽管如果子空间足够大，它也可以成为一个全局算子。

另一方面，变异为全局探索提供了一种机制。在前面的例子中，如果我们改变第一维中的一个解，它将产生一个可能不在子空间中的解。例如，对于解 $\mathbf{x_1} = [aaaaaabb] \in S$，如果它的第一个 a 变成了 b，那么它就会生成一个新解 $\mathbf{x_q} = [baaaaabb] \not \in S$。实际上，$\mathbf{x_q}$ 可能与现有解非常不同，并跳出之前的子空间。出于这个原因，变异是一个全局算子。然而，如果变异率足够低且步长很小，那么变异可以是局部的。因此，局部或全局之间的边界可以是相互的，也可以是相对的。

交叉和变异将为新的解提供多样性。然而，交叉提供了良好的混合，并且它的多样性主要局限于子空间中。变异可以提供更好的多样子，虽然某些解可能使种群远离收敛/进化特征。

值得指出的是，选择是一个具有双重作用的特殊算子：在子空间中选择最好的解，并为自组织或收敛提供动力。没有选择，就没有动力来选择最适合系统的解，因此选择使系统能够随着目标而发展。通过适当的选择机制，只有更适合的解和期望的阶段可以被允许逐渐传递，而种群中不适合的解将逐渐消亡。选择可以像高度精英主义一样简单，只有最好的才被选择。显然，其他形式的选择机制，如适应度比例交叉，也可以使用。

三个演化算子的​​作用和主要功能可以分为：

交叉主要用于子空间内的混合。这将有助于系统的收敛。
变异是全局搜索的一个主要机制，并且可以泛化为一种随机化技术
选择为系统向期望的状态演化提供了动力，它本质上是一种强大的开发操作。
变异可以采用不同的形式，一种方法是简单地使用随机移动或随机化。例如，传统的 Hooke-Jeeves 模式搜索（PS）也是一种无梯度的方法，启发了许多新的算法。模式搜索的关键步骤是一个维度的连续增量，其次是沿着其他维度的增量。该步骤在必要时会尝试并缩小 [10]。

模式搜索的思想可以通过下面的等式产生：

 

这可以写成向量方程

 

本质上，$\delta \mathbf{x}$ 在 d 维空间中相当于一个 2d 方向上的变异算子。正如我们将要看到的，差分进化在较高维上使用这种变异。

自然启发式算法
有十多种受欢迎的自然启发式优化算法。在本章的其余部分，我们将从演化算子以及探索和开发的角度对每种算法进行了分析。

模拟退火
最简单的随机算法，可能是在 1983 年由 Kirkpatrick 等人基于金属退火过程的特点，开发的模拟退火算法 [18]。从当前的解或状态 $x_i$，接受一个新的解 $x_j$ 的概率为

 
 
 

其中 f 是要被最小化的目标函数，Z 是归一化因子。

Kirkpatrick 等人的原始文章展示了如何解决非常具有挑战性的问题。然而，从当前的解中产生新的解可能取决于具体实现和感兴趣的问题。无论产生什么样的方式，这些新的解都会形成一个马尔可夫链，或者更具体地说，随机游走。

因此，主要的算子是通过随机游走产生新的解，因此随机化可看作一个变异或探索性的搜索机制。通过测试解是否变得更好（问题最小化的值更小）来实现选择。严格地说，模拟退火不是一种演化（进化）算法，因此算法中没有交叉算子。另外，由于接受是以概率条件进行的，所以开发能力相对较弱。这就是为什么模拟退火在实践中经常收敛很慢，尽管它善于探索，并具有良好的寻找全局最优的特性（以大量的函数评估为代价）。

遗传算法
遗传算法（Genetic algorithms，GA）由 John Holland 开发 [14]，基本上构成了现代进化计算的基础。如前所述，遗传算法有三个关键的遗传算子：交叉、变异和选择。尽管在原始遗传算法中没有明确的数学方程，但它提供了如何从父解/字符串中产生后代的详细过程和步骤。

交叉有助于开发和增强收敛性。实证结果和理论研究都表明，需要相对较高的交叉概率 $p_c \in [0.6, 0.95]$，而变异概率 $p_m$ 通常很低在 0.001 到 0.05 左右。这些值对应于高度的混合和开发、相对较低的探索程度。在实践中，这意味着遗传算法可以很好地收敛，并且在许多情况下可以很容易地实现全局最优。选择或者说适者生存提供了一个很好的机制来选择最优解。精英主义可以保证最好的解将保留在种群中，这将增强算法的收敛性。但是，全局最优性将在某些特定的条件下达到，变异可以看成是一把双刃剑，它可以增加找到全局最优的概率，但同时会放慢收敛。

差分进化
差分进化（Differential evolution ，DE）由 R. Storn 和 K. Price 于 1996 年和 1997 年开发 [23, 24]。事实上，现代 DE 与传统的模式搜索中的变异算子有很强的相似性。事实上，DE 中的变异可以看作是任意随机方向（$x_p - x_q$）的广义模式搜索

 

其中 F 是取自 [0, 2] 的差分权重，r、p、q、i 是由随机置换生成的四个不同的整数。

此外，DE 还有一个由交叉概率 $C_r = [0, 1]$ 控制的交叉算子，交叉可以用两种方式：二项和指数。选择与遗传算法中使用的基本相同。选择最合适的，对于最小化问题，是最小的目标值。因此，我们有

 
 

大多数研究集中在 F、Cr 和种群大小 n 的选择以及变异方案的修改上。另外，可以清楚地看到，当检查上述等式中的条件时，也使用了选择。几乎所有的 DE 变体都使用交叉、变异和选择，主要区别在于变异和交叉。例如，DE/Rand/1/Bin 使用三个向量来进行变异和二项式交叉。有超过 10 种不同的 DE 变种 [22]。

蚂蚁与蜜蜂算法
蚂蚁算法，尤其是由 M. Dorigo 开发的蚁群优化 [5, 6]，模仿了蚂蚁的觅食行为。首先，所有蚂蚁算法都使用信息素作为化学信使，信息素浓度作为质量解的指标来解感兴趣的问题。从实现的角度来看，解与信息素浓度有关，导致以较高信息素浓度为标志的路线和路径作为离散组合问题的更好解。

仔细研究蚁群优化，我们看到随机路线的生成主要依靠变异，而基于信息素的选择提供了一种选择较短路线的机制。蚂蚁算法中没有明确的交叉。然而，变异并不像在遗传算法中翻转数字那样简单。新解基本上是由适应度比例变异产生的。例如，蚂蚁在特定节点 i 的网络问题中选择从节点 i 到节点 j 的路线的概率由下式给出

 
 

其中 $\alpha > 0,\quad \beta > 0$ 为影响参数，$\phi_{ij}$ 为 i 与 j 之间路径上的信息素浓度，$d_{ij}$ 为同一路线的可取性。这些选择与某些关于路线的先验知识有微妙的关系，如通常会用到距离 $s_{ij}$，因此有 $d_{ij} \propto 1/s_{ij}$。

另一方面，蜜蜂算法通常不使用信息素 [20]。例如，在人工蜂群（artificial bee colony，ABC）优化算法 [15] 中，蜂群中的蜜蜂分为三组：雇佣蜂（觅食蜜蜂）、旁观蜂（观察者蜜蜂）和侦察蜂。随机化是由侦察蜂和雇用蜂进行的，两者是主要的变异。选择与蜂蜜或目标有关。没有明显的交叉。

ACO 和 ABC 只使用变异和适应度相关的选择，它们具有良好的全局搜索能力。一般来说，他们可以相对有效地探索搜索空间，但由于缺少交叉，收敛速度可能会很慢，因此子空间的开发能力非常有限。实际上，在许多元启发式算法中，交叉的缺乏是非​​常普遍的。

在探索和开发方面，蚂蚁和蜜蜂算法都具有较强的探索能力，但其开发能力较低。这可以解释为什么它们可以很好地执行一些困难的优化，但计算的工作量，如函数评估的次数可以非常高。

粒子群优化
粒子群优化（Particle swarm optimization，PSO）由 Kennedy 和 Eberhart 于 1995 年基于群体行为，如鱼类和鸟类的自然教育开发 [17]。本质上，粒子的位置和速度，$x_i$ 和 $v_i$ 分别进行如下更新：

 

 

式中 $\epsilon_1$ 和 $\epsilon_2$ 是两个取 0 和 1 之间值的随机向量。参数 $\alpha$ 和 $\beta$ 是学习参数或加速度常数，通常认为 $\alpha \approx \beta \approx 2$。

通过比较上面的方程和第 3 节中的模式搜索，我们可以看到新的位置是由模式搜索类的变异产生的，而选择是通过使用当前的全局最优解 $g^* $ ，以及个体最佳 $x_i^* $，进行的。然而，个体最优的作用并不十分清楚，当前的全局最优似乎对于选择算子非常重要，如加速粒子群优化 [17, 29, 37] 所示。

因此，PSO 主要包括变异和选择。在 PSO 中没有交叉，这意味着 PSO 的粒子在探索性方面具有高移动性。然而，$g^* $ 的使用似乎是非常有选择性的，这就像是一把双刃剑。它的优点是它可以通过提取当前最好的 $g^* $ 来加快收敛速度​​，同时也可能导致过早收敛，这可能不是所关心问题的真正最优解。

萤火虫算法
萤火虫算法（firefly algorithm ，FA）是由 Xin-She Yang 在 2008 年开发的 [29, 32, 33]，基于热带萤火虫的闪烁模式和行为。 FA 简单、灵活、易于实现。

萤火虫 i 的运动受另一个更具吸引力（更明亮的）萤火虫 j 吸引 ，由下式确定：

 

其中第二项是由吸引力引起的，$\beta_0$ 是 r = 0 的零距离处的吸引力。第三项是随机化，$\alpha$ 是随机化参数，$\epsilon_i^t$ 是在时间 t 服从高斯分布的随机向量。其他的研究也关注于 $\epsilon_i^t$ 的随机化，其可以很容易地扩展到其他分布，如 Lévy 飞行 [32, 33]。 Fister 等人对萤火虫算法及其变种进行了全面的综述 [8]。

从上面的等式中，我们可以看到，变异既用于局部搜索，也用于全局搜索。当它服从高斯分布和 Lévy飞行，它会在更大范围内产生变异。另一方面，如果 $\alpha$ 为一个非常小的值，那么变异的可能非常小，因此被限制在子空间中。有趣的是，公式中没有明确的选择，因为在 FA 中不使用 $g^* $。然而，在 FA 两个循环的更新期间，使用了排序和选择。

FA 的一个新特征是使用了吸引力，这是第一个使用吸引力的基于 SI 的算法。由于局部吸引力强于长距离吸引力，因此 FA 中的种群可以自动细分为多个子群，每个群可能围绕局部模式群聚。在所有的局部模式中，总是有一个全局最优，即问题的真正的最优。FA FA可以自然有效地处理多峰问题。

从公式 (18) 可以看出，当 $\gamma = 0, \alpha = 0$ 时，FA 退化为差分进化的变体。当 $\beta_0$ 时，退化为模拟退火。当 $x_j^t$ 被 $g^* $ 代替时，FA 变成加速 PSO。因此，DE、加速粒子群优化（APSO）和 SA 是萤火虫算法的特例，FA 可以具有所有这三种算法的优点。因此，FA 具有通用性和高效性，比其他算法如遗传算法和粒子群算法性能更好，并不奇怪。

布谷鸟搜索
布谷鸟搜索（Cuckoo search，CS）是由Xin-She Yang 和 Suash Deb 在 2009 年开发的最新自然启发式算法之一 [39]。 CS 基于布谷鸟的寄生行为。另外，这个算法使用所谓 Lévy 飞行 [21] 增强性能，而不是简单的各向同性随机游走。最近的研究表明 CS 可能比 PSO 和遗传算法效率更高 [11, 12, 40, 41, 26] 。

CS 使用局部随机游走和全局探索性随机游走的平衡组合，由开关参数 $p_a$ 控制。局部随机游走可写成

 

其中 $x_j^t, x_k^t$ 是通过随即置换随机选择的两个不同的解，$H(u)$ 是 Heaviside 函数。$\epsilon$ 是均匀分布的采样值，$s$ 是步长，$\otimes$ 是逐元素（entry-wise）相乘。

另一方面，全局随机游走通过使用 Lévy 飞行来实现 [21]：

 

其中

 
 
 

这里 $\alpha \gt 0$ 是步长缩放因子，它应该与感兴趣问题的尺度有关。

与 GA 和 SA 等算法相比，CS 有两个明显的优势：有效的随机行走和平衡的混合。由于 Lévy 飞行通常比任何其他基于随机行走的随机化技术更高效，因此 CS 在全局搜索中可以非常有效。事实上，最近的研究表明 CS 可以保证全局收敛 [27]。此外，蛋之间的相似性可以产生更好的新解，其本质是具有良好混合能力的适应度比例生成。换句话说，CS 具有由 Lévy 飞行实现的变异，基于相似性的新解的适应度比例生成提供了一种微妙的交叉形式。另外，通过使用 $p_a$ 来进行选择，其中好的解被传递给下一代，而不是那么好的解被新的解取代。此外，仿真还表明，CS 可以具有自动缩放功能，新的解可以自动放大到可能是全局最优所在的区域。

此外，式 (20) 实质上是马尔可夫链框架中的广义模拟退火。在式 (19) 中，如果 $p_a = 1, \alpha s \in [0, 1]$，则 CS 可以退化为差分进化的变体。此外，如果用当前最优解 $g^* $ 代替 $x_j^t$，则式 (19) 可以进一步退化为加速粒子群优化（APSO）[37]。这意味着 SA、DE 和 APSO 是 CS 的特例，这也是 CS 高效的原因之一。

本质上，CS 在局部和全局范围内都具有较强的变异性，而使用解相似性进行良好的混合，也起到等价交叉的作用。选择是由精英主义完成的，也就是说，解的好的部分将会传递到下一代。没有明确的使用 $g^* $，我们也可以克服在粒子群算法中观察到的过早收敛的缺点。

蝙蝠算法
蝙蝠算法（bat algorithm，BA）是 Xin-She Yang 于 2010 年开发的元启发式算法 [34]。它受启发于微型蝙蝠的回声定位行为。它是第一个使用频率调节的算法。在 d 维搜索或解空间中，每个蝙蝠在迭代 t 处与速度 $v_i^t$ 和位置 $x_i^t$ 相关联。在所有的蝙蝠中，存在目前最佳的解 $x_* $。因此，前面的三条规则可以被转换成位置和速度的更新方程：

 

 

 

其中 $\beta \in [0, 1]$ 是服从均匀分布的随机向量。

响度和脉冲发射率由下式调整：

 

和

 

其中 $0 \lt \alpha \lt 1, \gamma \gt 0$ 是常数。本质上，这里的 $\alpha$ 与模拟退火中的冷却时间表的冷却因子相似。

BA 已经被 Yang 推广到多目标蝙蝠算法（multiobjective bat algorithm，MOBA）[36, 38]，初步结果表明它是非常有效的。

在 BA 中，频率调节基本上起变异作用，而选择压力通过使用迄今为止发现的当前最佳解 $x_* $ 而相对恒定。没有明显的交叉。然而，由于响度和脉冲发射的变化，变异是变化的。另外，响度和脉冲发射率的变化也提供了自动缩放能力，因此，当搜索接近全局最优时，开发变得密集。

和声搜索
和声搜索（Harmony search，HS）是由 Zong Woo Geem 等人在 2001 年开发的音乐启发式算法 [13]。它不是基于群智能的，但它是一种元启发式算法 [31]。在标准 HS 中，解用一组和声来表示，使用以下三种选择或规则（音乐家演奏一首音乐）：

从记忆中演奏任何著名音乐片段
演奏类似于已知作品的东西（音高微调）
创作新音符或随机音符
HS 主要使用变异和选择，没有明确使用交叉。 第一条规则对应于选择或精英主义，第二条和第三条规则是变异。

在 HS 中，变异可以是局部或全局的。例如，音高调整（第二条规则）使用以下等式：

 

其中 $b_w$ 是音高调整的带宽，而 $\epsilon$ 是从 [-1, 1] 中随机选取的数字。这是一个局部随机游走，随机游走的距离由带宽控制。这一部分可以被认为是具有 0.1 至 0.3 的等效变异率的局部变异作用。

第三个规则本质上是更大规模的变异，基本上等同于随机游走。选择算子由和声记忆选择和声的概率来控制。与遗传算法类似，这种从种群中选择和声的概率很高，典型值为 0.9，这使系统能够在子空间收敛。但是，这可能是以降低在一些高度非线性问题中发现全局最优的概率为代价。

花算法
花朵授粉算法（flower pollination algorithm，FPA）由 Xin-She Yang 于 2012 年开发 [42]，该算法受开花植物的花朵授粉过程启发。它已经扩展到多目标优化问题，并且被发现非常有效 [43]。为了简单起见，我们使用以下四条规则：

生物传粉和异花授粉可以被认为是全局授粉过程，授粉媒介的移动遵循 Lévy 飞行（规则 1）
对于局部授粉，使用非生物授粉和自花授粉（规则 2）
昆虫等传粉媒介可以形成花朵的恒定性，相当于繁殖概率与所涉及的两朵花的相似程度成正比（规则 3）
局部授粉和全局授粉的交互或切换可以通过切换概率 $p \in [0, 1]$ 来控制，轻微偏向局部授粉（规则 4）
为了形成更新公式，我们必须将这些规则转换成更新公式。例如，在全局授粉步骤中，花粉配子是由昆虫等多种传粉媒介携带的，而花粉可以长距离传播，因为昆虫通常可以在更远的距离飞行和移动。因此，规则 1 和花朵常数可以表示为：

 

其中 $x_i^t$ 是迭代 t 时的花粉 i 或解向量 $x_i$，$g_* $ 是当前最优解。这里 $\gamma$ 是控制步长的缩放因子。

这里 $L(\lambda)$ 是对应于授粉强度的参数，本质上也是一个步长。由于昆虫可能通过不同的距离步长移动，所以我们可以使用 Lévy 飞行来有效地模拟这个特征。也即，我们从 Lévy 分布中取 $L \gt 0$

 
 
 

这里 $\Gamma(\lambda)$ 是标准伽玛函数，这个分布对于大的步长 s > 0 是有效的。这个步骤本质上是一个全局变异步骤，这使得我们能够更有效地探索这些空间。

对于局部授粉，规则 2 和规则 3 可以表示为

 

其中 $x_j^t, x_k^t$ 是来自相同植物不同花朵的花粉。这基本上模仿了有限邻域内的花朵的恒定性。在数学上，如果 $x_i^t$ 和 $x_k^t$ 来自相同的物种或从相同的种群中选择，这等效地变成局部随机游走（如果 $\epsilon$ 服从 [0, 1] 范围内的均匀分布）。本质上，这是一个局部变异和混合步骤，可以帮助在子空间中收敛。

原则上，花朵授粉活动可以发生在所有尺度上，既有局部也有全局的。但实际上，邻近的花朵或不远处的花朵更容易被当成局部授粉。为了模拟这个特征，我们可以有效地使用切换概率（规则 4）或者邻近概率 p 来在公共的全局授粉和密集的局部授粉之间切换。首先，我们可以使用初值 p = 0.5。初步参数表明，对于大多数应用，p = 0.8 可能更好。

选择算子是通过选择最好的解并将它们传递给下一代来实现的。它也明确地使用 $g_*$ 来找到最佳的解。和许多其他算法如粒子群优化和和声搜索一样，没有显式地交叉。

其他算法
文献中已经出现了很多其他的算法。 Fister Jr. 等人提供了一个简要的综述 [9]，可能这需要更广泛的分析和比较。但是，由于这不是本文的重点，所以我们不会更详细地讨论这些算法。

通过分析这些算法，我们可以注意到的是大多数算法总是使用变异和选择，而没有使用交叉。我们可能会对交叉的确切作用产生疑惑，这需要进一步分析。如前所述，交叉在子空间中提供了良好的混合和收敛增强，但是如果交叉率过高，可能导致过早收敛。另一方面，过多的变异探索可能会减慢收敛速度。许多算法中缺乏显式的交叉算子，可以解释为观察到或者事实上很多算法确实能够提供更好的全局最优的保证，但与使用遗传算法和差分进化算法相比，迭代次数没有明显减少。唯一的例外是鹰策略和协同进化算法。

因此，迫切需要进一步研究两阶段（two-stage）鹰策略和协同进化如何更好地工作。此外，系统地调整算法中的参数以及仔细地控制这些算法相关参数对于理解这些算法的行为以及如何在实践中改进它们可能是非常有用的。

参数调优和参数控制
所有的自然启发算法都有算法相关的参数。这些参数的设置可以在很大程度上影响算法的行为和性能。如何最好地调优和控制这些算法仍然是一个非常具有挑战性的问题 [7] 。

参数调优
为了调优 $A(\Phi, p)$（对于具有一组参数 $p$ 的给定问题 $\Phi$ 和算法 $A$），为了实现其最佳性能，需要参数调整工具，即调节器（tuner）。与调整高精度机械一样，复杂的工具是必要的。对于算法中的参数调优，我们可以使用什么工具？一种方法是使用更好的现有工具（比如算法 B）来调优算法 A。现在问题可能变成：你怎么知道 B 更好？ B 是调节好了的吗？如果是的话，你是如何调优 B 的？如果我们使用另一种工具（比如算法 C）调优 B。现在又问题变成了算法 C 如何被调优？这可以一直持续下去，直到算法 Q。最后，我们需要一些工具/算法来调整 Q，这又回到了原来的问题：我们如何调优一个算法 A 使得它的性能更好？

值得指出的是，即使我们有很好的工具来调整算法，最佳参数设置和性能都取决于在调整中使用的性能度量。理想情况下，参数应该足够健壮，以处理小的参数变化、随机种子，甚至问题实例 [7]。然而，在实践中，它们可能无法实现。根据 Eiben [7]，参数调优可分为迭代和非迭代调节器、单级和多级调节器。这些术语的含义是不言自明的。在实际的调优方法方面，现有的调优方法包括抽样法、筛选法、基于模型的调优方法和元启发式调优方法。这些方法的成功和有效性可能会有所不同，因此没有一种行之有效的通用参数调优方法。

超优化
从我们之前的观察和讨论中，可以清楚地看到参数调优是优化算法的优化过程。因此，这是一个超优化（hyperoptimization）问题。从本质上讲，调节器是调优算法的元优化工具。

对于一个标准的无约束优化问题，目标是在 d 维空间中找到函数 f(x) 的全局最小值 $f_* $。就是说，

 

一旦我们选择一个算法 A 来解决这个优化问题，算法将找到一个接近真正的全局最小值 $f_* $ 的最小解 $f_{min}$。对于给定的 tolerance $\delta$，这可能需要 $t_{\delta}$ 次迭代来实现 $|f_{min} - f_* | \le \delta$。显然，实际的 $t_{\delta}$ 在很大程度上取决于问题目标 $f(x)$ 和所用算法的参数 $p$。

算法调优的主要目的是找到最佳参数设置 $p_* $，使得计算代价或迭代次数 $t_{\delta}$ 最小。因此，参数调优问题作为超优化问题可以写成

 

其最优为 $p_* $。

理想情况下，参数向量 $p_* $ 应该足够健壮。对于不同类型的问题，$p_* $ 的任何微小的变化都不应该对 A 的性能产生太大的影响，这意味着 $p_*$ 应该处在一个平坦的范围内，而不是在一个尖锐的峰值处。

多目标观点
如果我们从不同的角度出发看一下算法调整过程，有可能把它构造成一个具有两个目标的多目标优化问题：一个目标是问题 $\Phi$ 的函数 $f(x)$；另一个目标是算法的 $t_{\delta}$。也就是，

 

其中 $t_{\delta}$ 是达到给定 tolerance $\delta$ 所需的（平均）迭代次数，即找到足够接近全局最优 $f_* $ 最小 $f_{min}$，以满足 $|f_{min} - f_* | \le \delta$。

这意味着对于给定的 tolerance $\delta$，将存在一组具有最小 $t_{\delta}$ 的最佳参数设置。因此，双目标将形成帕累托前沿（Pareto front）。原则上，双目标优化问题 (33) 可以用任何适用于多目标优化的方法来解决。但是由于 $\delta$ 通常是给定的，所以解决这个问题的一个自然的方法是使用所谓的 $\epsilon$ 约束或 $\delta$ 约束法。命名取决于使用的符号，这里我们使用 $\delta$ 约束。

对于给定的 $\delta \ge 0$，我们将其中一个目标（如，$f(x)$）变为约束，那么，前面的问题 (33) 就变成一个有约束的单目标优化问题。也就是，

 
 
 

尽管在这个框架中思想变得更加清晰，但我们仍然需要选择一个好的工具来解这个多目标问题。最近，Xin-She Yang 等人提出了一个自我调优算法的方法，这会在后续章节进行详细介绍。简而言之，这个双目标优化问题可以通过迭代地使用算法 A 本身来解，这基本上同时实现参数调优和问题求解。

参数控制
与参数调优相关的问题还有参数控制。参数调优后的参数值通常在迭代期间是固定的，而为了达到参数控制的目的，参数在迭代期间应该变化。参数控制的思想是改变参数，使得感兴趣的算法能够提供最佳收敛速度，从而可以获得最佳性能。参数控制是另一个需要解决的难题。在蝙蝠算法（BA）中，已经尝试了一些基本形式的参数控制，并且发现它是非常有效的 [34]。通过控制响度和脉冲发射速率，当可能接近全局最优时，BA 可以自动地从探索切换到以有希望区域为重点的局部开发上。类似地，模拟退火中的冷却时间表可以被认为是基本参数控制的一种形式。

另一方面，鹰策略（ES）是一种采用迭代开关的两阶段迭代策略 [35]。ES 从探索模式中的一群代理（agent）开始，然后切换到开发阶段进行局部密集搜索。然后又开始了另一系列的探索活动，进入了一个新的开发阶段。这种迭代重启策略被认为非常有效。参数调优和参数控制都在积极研究之中。为此，迫切需要更有效的方法。

讨论
许多优化算法都是基于所谓的群体智能（swarm intelligence）并使用基于种群（population-based）的方法。大多数使用某种三键演化（进化）算子：交叉、变异和选择。然而，几乎所有的算法都使用变异和选择，而交叉在某些算法中可能会以一些微妙的方式出现。交叉在开发中是有效的，通常可以在局部子空间提供良好的收敛性。如果这个子空间是全局最优所在，那么采用精英主义的交叉几乎可以保证全局最优性的实现。然而，如果交叉子空间不在全局最优的区域，则存在过早收敛的危险。

变异和选择的广泛使用通常使得随机算法具有较高的探索能力。由于开发量相对较低，与 Newton-Raphson 等传统方法相比，收敛速度通常较低。因此，大多数启发式算法通常可以很好地处理非线性问题，包括相对较困难的优化。然而，函数评估的次数可能非常高。

交叉和变异在探索中的作用相当微妙，而选择作为一种开发机制可能是简单而有效的。但是交叉、变异、选择的组合如何直接关系到探索和开发的平衡，目前还不清楚。事实上，这仍然是一个悬而未决的问题。例如，在遗传算法中，交叉的概率可以高达 0.95，而变异通常可以很低，在 0.01 到 0.05 的范围内。相比与其他算法，探索似乎很低，但遗传算法已被证明是非常有效的。另一方面，变异相关的 Lévy 飞行在布谷鸟搜索可以具有较高的探索能力，但布谷鸟搜索可以很快收敛。同时，在标准萤火虫算法的探索中搜索的百分比还不清楚，但已经表明，萤火虫算法在处理多模态、高度非线性问题时非常高效。

即使在标准粒子群算法中，并不清楚搜索迭代在探索中的百分比。当前全局最佳的使用也是一把双刃剑。当前全军最佳可能有助于加速收敛速度，但是如果当前全局最佳的情况是从局部最优（而非全局最优）所在子空间抽取的一组有偏差的样本得到的话，也可能导致错误的最优性。所有这些观点都表明，如何通过调整演化算子的​​组合来实现探索和开发的最佳平衡是未知的。

实际上，在不调整参数的情况下，将所有演化算子组合在一起是无法实现的。根据经验，我们知道任何算法相关参数的设置或值都会显著地影响算法的性能。为了获得好的性能，我们需要为参数找到正确的值。换句话说，参数需要进行微调，以使算法达到最好的程度。参数调优仍然是一个活跃的研究领域 [7]。

尽管这些问题十分重要，但进展甚微。相对而言，目前文献中对重要问题的研究也存在分歧。自然界已经演化出数以百万计的具有各种特征的不同物种，但这并不意味着研究人员应该开发数以百万计的不同算法，如草算法、叶子算法、甲壳虫算法、天空算法、宇宙算法或流氓算法。重点应放在解决重要问题上。

然而，这并不意味着不应该开发新的算法。研究界应该鼓励真正新颖高效的算法（如，更好的演化（进化）算子、更好地平衡探索和开发）。


