Timestamp: 2025-09-03T08:55:00.842753
Title: Rust 投入生产环境一年的经历 BV1mysDeGEph
URL: https://b23.tv/vnQDC0Q
Status: success
Duration: 14:07

Description:
**核心要点：** 尽管Rust在编译时间长和部分工具生态不成熟方面存在挑战，但其卓越的类型安全、编译时错误捕获和运行时稳定性，使其成为构建大型、高可靠后端系统的优秀选择，作者对其在生产环境中的表现感到非常满意。

**总体框架：** Rust在生产环境中的优缺点分析与个人经验分享。

---

### 详细总结

**一、引言**
*   作者Dmitry Cool Drive分享了Rust在生产环境应用一年的经验。
*   起因：一个简单的支付系统切换项目演变为复杂的后端重构，需用Rust实现作业处理队列和小微型会计系统，促使Rust在生产环境大规模应用。

**二、Rust的显著优点**
1.  **编译成功，运行无忧：**
    *   **类型安全与编译特性：** Rust编译器能捕捉大多数错误（如类型不匹配、访问不存在字段），避免运行时问题，强制开发者在编译阶段修复代码。
    *   **与动态语言对比：** 杜绝了像JavaScript或PHP那样代码有错却能运行的情况，保证了生产环境代码的极高稳定性。
    *   **效果：** 除了少量动态配置问题，代码几乎完美运行。
2.  **强大的类型安全支持：**
    *   **SQLx (类型安全的SQL封装库)：** 在编译时检查SQL语句的正确性，防止因SQL拼写错误或参数类型不匹配导致的运行时数据库错误。
        *   **价值：** 极大减少了对单元测试、高度抽象ORM或数据库模式代码生成的依赖。
    *   **类型安全模板引擎 (如Svelte, Maud)：** 尽管项目中未使用，但认可其能消除模板代码中的常见错误。
    *   **局限：** 第三方API接口的类型安全仍然是一个挑战。
3.  **极高的运行时稳定性：**
    *   **无进程崩溃：** 作者表示从未遇到Rust进程崩溃的情况，而Node.js进程则偶有崩溃。
    *   **显式错误处理：** Rust通过`Result`枚举、`?`操作符和`match`语句强制开发者显式处理所有可能的错误，提升了代码的健壮性。
    *   **`unwrap()`的谨慎使用：** 仅在初始化配置或环境依赖等“立即失败”场景下使用，通常更倾向于记录警告并返回合理默认值，确保应用持续运行。
4.  **优秀的构建系统和工具链：**
    *   **Cargo：** 极大地简化了项目创建、依赖管理和多项目工作区配置。
    *   **Clippy：** 提供强大的代码风格检查和优化建议。
    *   **对比JS/TS生态：** Rust的工具链更为稳定，避免了JavaScript/TypeScript生态中频繁变化的工具和大量样板代码的问题，降低了开发疲劳。

**三、Rust的挑战与痛点**
1.  **编译时间长：**
    *   **主要痛点：** 项目规模扩大、第三方依赖增多（尤其是使用宏的库如SQLx、Maud）时，编译时间会显著增加（作者项目中从6分钟增至20分钟）。
    *   **优化：** 虽可通过缓存、多核并行等方式优化，但需投入大量精力，目前作者更关注业务开发。
    *   **开发模式受影响：** 长编译时间打破了像JavaScript热重载那样“修改-即时测试”的快速迭代模式，Rust开发更倾向于“编写大量代码-编译-调试”的循环。
2.  **工具生态尚不完全成熟：**
    *   **部分领域优秀：** 后端框架（如Axum）提供了构建API所需的大部分组件。
    *   **集成挑战：** 在与外部系统（尤其是前端框架）集成时，往往需要自行摸索，因为缺少官方维护的集成组件。
    *   **文档与示例稀缺：** 某些边缘或小众的第三方库缺乏完善的文档和示例，开发者常需通过阅读源码来解决问题。
3.  **不适合所有应用场景：**
    *   **快速迭代型应用不适用：** 对于需要快速迭代的前端开发，每次修改后都需重新编译，导致开发效率低下，作者仍倾向于使用TypeScript和JavaScript。
    *   **其他类型应用：** 某些游戏开发等场景，快速反馈和迭代也是关键。

**四、总结与展望**
*   尽管面临编译时间长和工具生态不成熟等挑战，作者对一年前选择Rust感到非常高兴。
*   Rust不仅帮助他获得了心仪的主业工作，还让他能够构建出更优质、更可靠的软件。
*   作者期待在接下来的一年继续使用Rust进行开发。

---

<Mermaid_Diagram>
graph LR
    A["Rust在生产环境的体验：一年回顾"]:::main_node

    subgraph "优点：生产力与稳定性提升"
        B["编译即运行，运行无忧"]:::positive_category
        C["强大的类型安全"]:::positive_category
        D["极高的运行时稳定性"]:::positive_category
        E["优秀的构建系统与工具链"]:::positive_category
    end

    subgraph "挑战：开发体验与生态成熟度"
        F["编译时间长"]:::negative_category
        G["工具生态尚不完善"]:::negative_category
        H["不适合所有应用场景"]:::negative_category
    end

    I["总体结论：尽管有挑战，但非常满意，将继续使用"]:::conclusion_node

    A --> B
    A --> C
    A --> D
    A --> E
    A --> F
    A --> G
    A --> H

    B --> B1["类型安全与编译特性捕获错误"]:::detail_node
    B --> B2["与动态语言对比：强制修复"]:::detail_node
    B1 --> B3["结果：代码几乎完美运行"]:::detail_node

    C --> C1["SQLx：编译时检查SQL，杜绝运行时错"]:::detail_node
    C1 --> C2["价值：减少ORM/单元测试依赖"]:::detail_node
    C --> C3["类型安全模板引擎（如Svelte，Maud）"]:::detail_node
    C --> C4["局限：第三方API接口类型安全仍是挑战"]:::caution_node

    D --> D1["极少进程崩溃（对比Node.js）"]:::detail_node
    D --> D2["显式错误处理：Result, ?, match"]:::detail_node
    D2 --> D3["效果：代码健壮性高"]:::detail_node
    D --> D4["Unwrap()谨慎使用，倾向警告+默认值"]:::detail_node

    E --> E1["Cargo：简化项目创建与依赖管理"]:::detail_node
    E --> E2["Clippy：代码风格检查与优化"]:::detail_node
    E --> E3["对比JS/TS：工具链稳定，减少样板代码"]:::detail_node

    F --> F1["痛点：项目大，依赖多，编译时间增"]:::detail_node
    F1 --> F2["影响：打破“修改-即时测试”模式"]:::detail_node
    F2 --> F3["开发模式：更像“写-编译-调试”"]:::detail_node
    F --> F4["优化可能但需投入精力"]:::caution_node

    G --> G1["集成挑战：需自行摸索"]:::detail_node
    G --> G2["小众库缺乏文档与示例，需读源码"]:::detail_node
    G --> G3["第三方API接口类型安全不足"]:::caution_node

    H --> H1["不适合前端等快速迭代应用"]:::detail_node
    H1 --> H2["每次编译耗时，迭代慢"]:::detail_node
    H1 --> H3["作者仍偏好TS/JS用于前端"]:::detail_node

    B3 --> I
    C2 --> I
    D3 --> I
    E3 --> I
    F3 --> I
    G3 --> I
    H3 --> I

    style A fill:#DCE9F2,stroke:#333,stroke-width:2px,color:#333;
    style B fill:#E6F7F0,stroke:#2ECC71,stroke-width:1px,color:#333;
    style C fill:#E6F7F0,stroke:#2ECC71,stroke-width:1px,color:#333;
    style D fill:#E6F7F0,stroke:#2ECC71,stroke-width:1px,color:#333;
    style E fill:#E6F7F0,stroke:#2ECC71,stroke-width:1px,color:#333;

    style F fill:#FEE7EC,stroke:#E74C3C,stroke-width:1px,color:#333;
    style G fill:#FEE7EC,stroke:#E74C3C,stroke-width:1px,color:#333;
    style H fill:#FEE7EC,stroke:#E74C3C,stroke-width:1px,color:#333;

    style I fill:#DFF0D8,stroke:#006400,stroke-width:2px,color:#333;

    classDef positive_category fill:#E6F7F0,stroke:#2ECC71,stroke-width:1px,color:#333;
    classDef negative_category fill:#FEE7EC,stroke:#E74C3C,stroke-width:1px,color:#333;
    classDef detail_node fill:#F5F5F5,stroke:#CCC,stroke-width:1px,color:#333;
    classDef caution_node fill:#FFF9E0,stroke:#DAA520,stroke-width:1px,color:#333;
    classDef main_node fill:#DCE9F2,stroke:#333,stroke-width:2px,color:#333;
    classDef conclusion_node fill:#DFF0D8,stroke:#006400,stroke-width:2px,color:#333;
</Mermaid_Diagram>

Content:
我们来看一篇比较有意思的文章就是有一个作者是叫Dimetry Cool Drive有点像是看这个名字有点像是俄罗斯或者周边的一个国家的人它的名字叫Rustle投入生产环境一年的经历推文文章是在9月22号写的时间非常的近这是它的原文念节有请你可以看到原文我们来看它的详细内容过去一个月我几乎把所有的困惦时间都花在了我的副眼加速的facts上面一切从把支付系统从Namens Squeeze 前一段stripe上面开始为什么呢?他说订阅他的伯克可以看到他之前详细解释为什么的原因啊但中路每次重够或者重写一样项目远比我预期的要复杂的多一个简单的支付付提供上切换结果要求我家10个月上面实现一个作业处理对列还得做一个小型的快几系统但这一切都是用Rustle的实现的这就导致了我说提交优势以来最大的一次合并请求它的合并请求很大260个圈就算了然后就是合并请求比较大这个合并请求正好赶上我启动加速的facts大于一周年于是通常我在主业中也是用Rustle的开发商品因此我决定告诉一下在生产行程中是用Rustle的感受第一小把讲的是编译成功运行无邮这一边你能编译通过就能跑我之前在撰写Rustle外部医院出体验室医院的出体验室提到过这一点现在我想再次强调这一点就说你编译通过肯定会能跑肯定会能跑了通常我不会在每次修改后都运行但除非是进行发出的cs较整这个有的意思点就是它说讲的是Rustle在外部医院上面的一个体验就是生产行程它跟游戏之间还是有不同的点我们来看大多数情况下我会完成一个交达的充够然后交达的充够或者困难实现的话然后再一起运行测试而且在Rustle的当中如果带码不能够编译通过的话你就没办法运行它这跟gs不一样如果带码有错你就必须修复它两个这两个跑于是我就陷入了一个长时间的充够当中这期间带码重位处于可以编一条状态直到所有事情都完成的最后一颗但所有系统组织都配置好并发出第一个本地的请求的时候我本来很担心但我今天是一切正产运行虽然我知道自己是一个不错的开发者但我不会天真的认为自己能写出完全没有错误的代码除了少量的动态代码问题比如错误的训练化、发泄化化格式代码几乎是完美运行的这种成功的第一个原因是是什么呢是Rustle的内型安全和编译特性就让编细不会让你错误的把一个i64负质给UID也不允许你像在界时中那样访问不存在了什么结构理智团不会有这样的尽管有些人生存自己存在没有给了过无法访问威丁一的附属性之类的软太密措当我和同事的经历并不一样我们在主业中使用Rustle的原因之一是什么了原本使用动态、语言、编辑的后段变得难以为后了就是太大的难为后了对于一个小英雄你可能可以在这个脑海中记住一下他的三下稳但是随着系统变大记住受的细节就变得不可能了我和记得以前做PHP的时候有时候我来知道书主在哪里书主里面有哪些剑有哪些剑就不得不把书主内容直接打印出来因为有些剑是Slayer模式的有些剑是Northome模式这种剑的面面方式模式格式不一样格式不一样第二层或者说是第一层的延伸也就是Rustle对内型安全的指责这种指责就出生了像Squeal差点的根据这个很有意思它加少了Squeal差这个根据一个编细的内型安全的Squeal分装库它会在真正的数据库上运行你的差距如果差距发错或者是你尝试将一个I-SAR插入到一个文本列的这种里面而且没有显示转弯的话带满混弊办法通过编议我以前对Squeal存满的位置因为它是每个应用的核心部分出错就很容易在生产房间的如果拼错了差距或者搞错了差数你就麻烦了很多人会为了Squeal的差距编写这个单元测试一个人试用这个ROM或者是根据数据库模式的生存代码但是有了Squeal差我就再也不用担心这个问题了我可以充分享受Squeal的强大功能不需要依赖高度出现了ROM或者进行数据库模式的代码生存当然这也有一些缺点或者后面的不够能不能提到这一点另一个属于这一类的这个根据是内型安全的模板引擎比如说SKama或者Mod虽然我在项目都没有运动它们但他们确实消除了代码都能另一种不缺的性有时候我说到I-HELLOUZNAME开头的电动预件的时候会怎么不出效这种错误如果来自这种无名的就是很不聪明的复材好如果来自这种引行就比较尴尬了而有了内型安全的编议时候这个模板这种错误就不会存在就是这个能说没有一些引行它这个系统就不是静态写的所以会可能存在这种情况我唯一环境的身体型安全的第三方API接口就是就是若是它没有这个地方它是它那边环境的地方就是算你可以从Open API swag规范生存的可我段当然要数字于第三方API的地方上即便它们提供了规范也不一定以为它会争议成这个规范或者是保证他们的API不会争大对于自己的话我认为还没有缺缺发就是安全的第他API这次比较难的还有一个就是当它允许的时候说非常稳定的非常稳定的我从来没有遇到过RUSH的进程崩溃的情况倒数遇到过Node进程崩溃就是GS上面Node进程可能会崩溃除非你在弹码中到处使用Unwrap就是Unwrap就是基本上因为如果结果是错误就崩溃基本上是这样的否则你有进程可能运运不过崩溃我的弹码中确实有一些Unwrap主要是它出自化的时候所以说如果配置文件确实或者环境编辆没有定义除了让进程崩溃外我也没有什么别的选择这个其实在错误处理上面错误模型上面就叫立即错误对吧 放弃形错必须把它扔掉扔掉后面没法跑但中厅来说的话RUSH要求你显示的处理错误任何反回RUSH三分Around的弹码都会去你通过问号处处处向上传理错误或者是使用Match举进处理在大多数情况下做得非常合理而在某些情况下是有点烦比如说当你知道I-64专会I-S-R没问题的时候你还得运TryFrom它反回一个RUSH即便在这些让人比较烦就往下我通常也不会去用RAP而是记录一个告警编反回一个合理的默认识编程中的触摆位置因此至少我的存用可以继续运行编记录一下我可能犯错的地方根据非常强大就是说RUSH在根据上面加上Factor不仅仍是用RUSH写的它和内部系统使用Type-Squip和其他的伎丝框架而且我每次创建一个新的Type-Squip下面说总会有些东西会改变要么是某个根据的配置文件变了要么是Type-Squip的新的样板文件USP2是后来不再流行的大家用Fastify了接着USP2又变得流行了又跨又变倒过来TESNO的被淘汰改变TES差某个模块只支持USM另一个模块又是CGSType-Squip总是在变化你变些代码啊另一代码再存的季 S和Type-Squip总使用这个 Workspace的方式都在变但是RUSH写不太好只要卡在那里就能够生成一个新项目想要 Workspace没问题完美运行念头根据Clippy已经有完美的Clippy来给你搞定了RUSH写的几乎没有这种样板代码也减少了单精神皮牢对吧并一时间仍然是痛点并一时间仍然是坑RUSH的确点好我用的就是并一时间特别是当你使用一辆红的困局这个我们在之前的视频中看的过对于解红它是非常好时间的红展开是非常好时间的比如说Squip差或者是Mode无论是KFB、SB和编辑都会开始吃力所以说项目的扩大了我记得了越来越多的第三方依赖尽管我试图通过讲多个报道公共依赖发入根部路的卡钩塔蒙文件中但积极选择数据的依赖困难优化这个便宜当我仍然在便宜时间上非常地增长我提到过最初在CLC的一种编议需要大概6分钟而现在已经需要20分钟了根据网上的各种伯克确实可以通过这个缓存依赖和使用多节量的刀和容器优化便宜时间但这需要非常精准的传统我现在没时间做这个事需要更多的专注与业务层面不过以后我会处理的在苹果的M2上面的本地编议还算可以接受特别是侦量便宜一下但代价是占用了大量的重重分件我是不是都愿意开个个订请你调几十级约的缓存而即使有了这个侦量便宜它依然远没有借还是是一种即使热重载快所以回到最初的观点这个后面讲的就很有意思了就那种改一下代码利益测试的开发情况被打破了就不是这种方式了你没有办法像这个戒业的时候或者是Type-Squeep的那样就是或者即使非常即使的反馈这也是加上发酵的一些内部和外部工具一样使用Type-Squeep的冰淇淋Rast更像是在引导你你写大量的代码冰淇淋然后浅差你写很多然后再去冰淇淋对啊而不像是像路的Joucequeep的那样一旦好像改代码切换的对象器测一下看一下我大多数情况下可以接受这个纠称因为我得到了那些安全的好处我相信CI-PAP-NINE可以解决这个问题但是我需要更多的时间来优化它工具生态还没有完全完善就是它认为的生产还能有一个问题有些领域Rast的表现得非常好比如说从后段像Xium这样的宽佳提供了购件APP夫妻所需的大部分逐渐并且大多数流行的外白PAP都有这个Rast的扣段虽然这些扣段通常不是有这个购件APP的工作维护的但至少我们可以使用它们但是完成了大多数的一直拼Buffer-Buffer-Rast因此你需要自己摸索怎么集成各种APP在Rast的开放过程中这些有反复出现的问题至少在外部开发方面我不能够评论其他类型的应用我经常会查看原谈码或者是给他们找一下我遇到的问题类似的讨论大模型就很多的这些大模型很少能够提供合适的觉法因为大模型这些都能够办不上马因为大多数包都是一种很小种类的一个可能它的训练书记里没这个东西所以Rast的事去对包的包的文档和势力非常的重视非常好但最终你会遇到一些边缘的这种不是那种就是大众的就是很小种边缘的那种案例它既没有文档也没有例子你只能通过运动原谈码的解决问题那有些运动的存用并不适合Rast尤其是对于那些人来这些快速运行开发其实像这个游戏开发就是那种模式了对吧我仍然更喜欢TX和STRA或者是SWAMG来写钱段Rast这方面的开发体验并不好每次这个编辆编划后都需要存心编辆就使得钱段开发的快速跌代就编得比较慢最后我很高兴一年前选择了Rast它不仅搬住我活得了我非常喜欢的主业的这种工作主要业务的这种工作还让我能够购捐更好的软件我期待就在接下来的一年继续使用Rast的开发所以这边文章也很有意思基本上讲到的问题跟之前的一些人的感受是比较齐合的大家的感受应该是类似的这就是在Wap开发上面它有很多的优点尤其是在比较大一点的这种项目上面它是很有优点的就是它会对你的用为起到一个非常好的改变之前的试评人们也有讲到过这个问题但这边文章独角也有意思
