Timestamp: 2025-09-22T03:10:35.628206
Title: 我是如何使用 Claude Code 和 Codex 的 BV18bJdzzEvn
URL: https://b23.tv/U6xU8El
Status: success
Duration: 34:32

Description:
**核心要点总结：**
未来的编程范式将从传统的“优雅代码编写”转变为“智能体化编程（Agentic Coding）”，即通过熟练运用AI工具如Cloud Code，实现开发流程的全面自动化、高质量代码生成和持续验证，从而放大开发者的能力，使他们从代码的具体实现者转变为AI的架构师和控制器。

**纲要总结：**

**一、Cloud Code 核心功能与操作**
1.  **启动与模式：**
    *   通过 `cloud` 命令启动进入命令行模式。
    *   可集成至 VS Code Codex 插件。
2.  **项目记忆与指令 (Cloud.md)：**
    *   `Init` 命令：初次运行在项目根目录生成 `Cloud.md` 文件，总结项目架构、语言、运行方式等核心信息（约 1KB）。
    *   **记忆作用：** `Cloud.md` 文件内容会在每轮对话中自动作为上下文传入，指导AI遵守特定指令和项目规范（例如：优先使用 PNPM）。
    *   **编辑与更新：** 可手动编辑 `Cloud.md`，或使用 `update Cloud MD` 命令让AI自动更新。
3.  **权限控制 (Permissions)：**
    *   预设允许 (`Allow`) 或禁止 (`Deny`) AI执行的系统指令（如 Bash 脚本、AWS CLI、`rm` 命令）。
    *   配置在 `Cloud.md` 下的 `Settings` 部分。
    *   `Allow *` 赋予全部权限（但实际仍可能需要确认）。
4.  **上下文管理 (Context)：**
    *   最大上下文长度为 200K Tokens。
    *   显示当前对话中上下文Token的使用情况（`Cloud.md`、系统提示词、工具使用等）。
    *   **优化策略：**
        *   `Clear`：清除当前对话上下文，开启新对话以避免无关信息污染和Token占用。
        *   `Compact`：压缩上下文，保留相关信息，适用于功能迭代。
        *   达到上限时自动压缩。
5.  **AI 模型选择 (Models)：**
    *   提供多种模型选项，如 50% 流量使用 GPT-4.1LB 最强模型，剩余流量使用 Sonnet 4；或全部使用 Opus/Sonnet。
    *   根据项目复杂度选择：简单任务 Sonnet 表现良好，复杂后端交互项目 Opus 更优。
6.  **自定义命令 (Commands)：**
    *   在 `Cloud.md` 的 `Commands` 部分定义一系列可快速执行的自动化脚本。
    *   **案例：** `E2E Test` (端到端测试)、`Review Go code` (代码审查)。
    *   **自动化：** 实现从构建、测试、验证到部署的整个流程自动化。
7.  **智能体 (Agents)：**
    *   定义具有特定职责的智能体（如 Devops Agent, Rust Specialist）。
    *   可在对话中自动触发，完成特定任务后将结果反馈给主智能体，不占用主智能体上下文。
    *   实现复杂任务的拆解与并行处理。
8.  **钩子 (Hooks)：**
    *   定义在特定事件（如 `Finish E2E Test`, `Commit and push to open PR`）前后自动触发的脚本。
    *   **案例：** `Pre-commit` 钩子在代码提交前自动运行 CI 检查，确保代码质量。

**二、Cloud Code 与 Codex 的对比**
1.  **Cloud Code：**
    *   **多智能体工作流：** 每个动作都可视为一个子智能体，独立执行任务，不占用主智能体上下文。
    *   **全流程自动化：** 擅长集成 CI/CD，覆盖整个开发生命周期（从文档、代码、测试到部署）。
    *   **持续验证：** 适合复杂的、需要不断迭代和验证的项目。
2.  **Codex：**
    *   **一次性问题解决：** 更擅长解决单个、复杂的编程问题，或生成初始代码框架。
    *   **交互方式：** 提供包装好的界面，但自动化能力不如 Cloud Code。
    *   **模型：** 提供了专门针对编程优化的模型（如 GPT-5 High），思考过程较长，输出结果更准确。

**三、智能体化编程 (Agentic Coding) 与开发流程**
1.  **文档先行：**
    *   项目启动初期，优先编写详细的文档（`Cloud.md`, `README.md`），定义架构、功能、技术栈、交互方向。
    *   AI 可辅助文档的生成与完善，通过网络搜索最佳实践来优化初始想法。
2.  **迭代与验证：**
    *   **AI 辅助修改：** AI 可根据代码库的变化自动更新文档或代码。
    *   **跨AI验证：** 让一个AI生成方案后，再让另一个AI进行评估和双重验证，提高正确率。
    *   **人工参与：** 对于不确定的部分，结合人工思考和决策。
3.  **自动化测试与部署：**
    *   **E2E Test：** 运行端到端自动化测试，验证新功能对现有工作流的影响。
    *   **CI/CD 集成：** 利用 Hooks 和 Commands 实现构建、测试、部署的自动化。
4.  **程序员角色的转变：**
    *   从编写具体代码转变为“AI控制器”：理解AI如何工作、如何有效利用AI编写高质量、无错误、高效率的代码。
    *   **重要性：** 编写文档、理解架构、控制AI的能力远大于传统的LeetCode式编程。
    *   **趋势：** 初级程序员可能被AI替代，但能驾驭AI的开发者将发挥更大价值，实现“一人抵十人”的效率。

**Overarching Framework (总体框架):**
智能体化编程 (Agentic Coding)：通过AI工具实现软件开发全生命周期自动化，将开发者角色转变为AI架构师和控制器。

<Mermaid_Diagram>
graph LR
    subgraph "核心理念：Agentic Coding"
        A["智能体化编程 (Agentic Coding)"]
        B["开发流程全面自动化"]
        C["开发者角色：AI控制器与架构师"]
    end

    subgraph "AI编程工具与平台"
        D["Cloud Code: 完整开发工作流"]
        E["Codex: 单点问题解决/代码生成"]
    end

    subgraph "Cloud Code 功能模块"
        F["Cloud.md: 项目记忆与指令"]
        G["Context: 上下文管理与优化"]
        H["Permissions: 系统指令权限控制"]
        I["Models: 多AI模型智能选择"]
        J["Commands: 自定义自动化脚本"]
        K["Agents: 专用智能体 (如DevOps, Rust Specialist)"]
        L["Hooks: 自动化触发点 (如Pre-commit, E2E Test Post-run)"]
    end

    subgraph "自动化开发工作流"
        M["1. 文档先行与AI辅助生成/优化"]
        N["2. 代码生成与迭代"]
        O["3. E2E测试与CI/CD集成"]
        P["4. 跨AI/人工验证与反馈"]
    end

    subgraph "价值与未来影响"
        Q["提升开发效率与代码质量"]
        R["降低重复性工作"]
        S["赋能开发者，实现能力放大"]
    end

    A --> B
    A --> C
    B --> D
    D --> F
    D --> G
    D --> H
    D --> I
    D --> J
    D --> K
    D --> L

    F --> M
    M --> N
    N --> O
    O --> P
    P --> N %% Iterative refinement
    J --> O %% Commands drive automation
    K --> N %% Agents assist in code/task execution
    L --> O %% Hooks integrate into testing/deployment

    D --> Q
    D --> R
    D --> S
    C --> S
    E --> N %% Codex also contributes to code generation

    style A fill:#D4EDDA,stroke:#28A745,stroke-width:2px,color:#28A745;
    style B fill:#D4EDDA,stroke:#28A745,stroke-width:2px,color:#28A745;
    style C fill:#D4EDDA,stroke:#28A745,stroke-width:2px,color:#28A745;

    style D fill:#E0E7FF,stroke:#007BFF,stroke-width:2px,color:#007BFF;
    style E fill:#FFF3CD,stroke:#FFC107,stroke-width:2px,color:#FFC107;

    style F fill:#F8F9FA,stroke:#6C757D,stroke-width:1px,color:#6C757D;
    style G fill:#F8F9FA,stroke:#6C757D,stroke-width:1px,color:#6C757D;
    style H fill:#F8F9FA,stroke:#6C757D,stroke-width:1px,color:#6C757D;
    style I fill:#F8F9FA,stroke:#6C757D,stroke-width:1px,color:#6C757D;
    style J fill:#F8F9FA,stroke:#6C757D,stroke-width:1px,color:#6C757D;
    style K fill:#F8F9FA,stroke:#6C757D,stroke-width:1px,color:#6C757D;
    style L fill:#F8F9FA,stroke:#6C757D,stroke-width:1px,color:#6C757D;

    style M fill:#E2F0CB,stroke:#5CB85C,stroke-width:1px,color:#5CB85C;
    style N fill:#E2F0CB,stroke:#5CB85C,stroke-width:1px,color:#5CB85C;
    style O fill:#E2F0CB,stroke:#5CB85C,stroke-width:1px,color:#5CB85C;
    style P fill:#E2F0CB,stroke:#5CB85C,stroke-width:1px,color:#5CB85C;

    style Q fill:#D1ECF1,stroke:#17A2B8,stroke-width:2px,color:#17A2B8;
    style R fill:#D1ECF1,stroke:#17A2B8,stroke-width:2px,color:#17A2B8;
    style S fill:#D1ECF1,stroke:#17A2B8,stroke-width:2px,color:#17A2B8;
</Mermaid_Diagram>

Content:
好 今天我们来分析一下Cloud Code和Codex这样的这种AI边成工具用法那我们前两天我开源的这个相农整体平台就100%都是用Cloud Code来做的所以今天我们来简单快速分享一下也没有什么准备就是首先进入咱们的这个项目路对吧然后呢 你启动的话就是Cloud这样来讲启动就进入它这个命令好的模式那差一句其实之前大家用的比较多的是这个Codex我们有个这个右面打开那它的表方便地方就是它有把很多的东西给你包进来然后能快速地看到其实用Cloud Codex是一样的Cloud Code本身呢 也可以在这个里面去用我记得好像有一个Cloud Code的地方我看看 就这个这个CodexCloud Code也能它在这边打给一个CRI也是一样的但我必须喜欢用外部的这个CRI一会你就知道为什么会这样了那么废话说 Cloud Codex你刚进来的时候呢有一个命令叫Init这个Init就是在当前的我们这个项目的目楼下 就是这个目楼下会生成一个Cloud.md这个文件第一次进来的时候它运行它以后它就会读你的整个这个项目路把这个关键的东西抽出来然后总结一下放在这个文件里面大部分大概就是什么呢就是那个项目的架构 用哪些语言然后是前端的话 怎么样去运行是后端的话 怎么样启动这一些指令它都会在大概不到一K左右的这样的一个大小文字左右就给你写了这样的一个东西这个东西也叫做什么呢也叫做所谓的这个Codex的积议你也可以按这个信号这个警号 按警号进来就是一样也是在编辑这个文件你可以往里面不断加息的记忆比如说你用了一段时间以后你愿意你说不要用那个PMPDo not use NPMBut rather use PNPM大大大这些那么它以后就会记住然后每次帮你运行的时候它就会运行PNPM来代表那这个什么意思呢就是说这个文件 靠点NPM的这个文件大概是一K多它会在你每一次对话的时候每一次 每一轮对话都会给你塞自动塞进去这个上下文里所以它在执行你的对话的任务的时候会怎么样就是系统会遵守你这个记忆里面所谓的指令非常简单一个东西就是文件 形式的记忆那我们台湾的其他的名领我们从向往上简单看个比较重要的这些大家可以自己去研究这个Security Review就是你按摊了之后它就给你把当前这个项目幕楼下给你做个安全检查然后Resume这个就是你不小心退出这个对话你可以按一下Resume回去你赶快这是我以前的会话你按一个你就回到之前这个对话上去了还有一些其他比较重要的看一下Promisions这个可以有意思这个就是说在Cloud Code运行的过程当中它会运行一些系统指令那哪些是你允许的哪些是你不能许的你可以在预写在里面设定比如说一些Bash script你有一些让它运行有些不让它运行了AWS的一些指令了这个东西你都可以给它写在里面和Dinying就是你不让它运行的指令比如说RM Remove 这些不让它运行那这些指令存在哪呢其实存在Cloud的文件在下面的Settings Logo 这次存在这里面这个有很多不同的指令现在有一个比较简单的用法就是如果你希望它全部不用问你你给它全部的全线的话就用一个星Allow 后面一个星它就不问你了但实际上实色当中还是有些东西都会问你的但是大部分就不用你可以把后面的这些东西都代替了就不用了这些东西那说到刚才这个Cloud MD这个问题它是所谓的记忆其实你也可以直接修改这个MD问题不让它给你改比如说上面就是我在加的一些东西什么东西它就是你输出的你的目的是什么然后你要解放你的角色是什么你的性格是什么你输出的方式是什么然后你应该Focus在什么地方上以及我的这个项目里面经常用的一些指令那么就不用每次去指到它这个用错了 你要用别的它也不会每次全部搜一遍整个的代码库去找到相应的指令那么常用的指令都在这个里面都写在里面了所以用起来就比较快实际上这个东西说张浪是写这东西多长时间多慢第一次写是比较慢但实际上之后在写的时候就可以让怎么样的样这个Cloud Cloud帮你去写比如说update Cloud MD因为你修改了很多新的东西那有些新的不同的指令和新的指令三进去你就让它自动赶紧你带码的变化去更新这个这个Cloud MD文件就可以之后我还有什么比较重要的这个permission之后模型模型上就是有几种模型上的一个是第一种就是50%的流量用4.1LB最强的然后上下的流量用sony 4或者是第二个全部用opus这样的话消耗偷感就比较快或者是全部用sony这样的几个不同的选择根据你的项目复达度如果是比较简单的就是当各文件这种修改或者是两三个这种交叉逻辑不是复达的话其实sony做得很好但是如果是比较复达的后段交互的项目需要有csd带wops这些东西的话那就是用opus更好一些大概就是这样的一些东西后面看一看也没有其他的这个mamber就是刚才编辑那个文件你可以直接打开那个文件编辑然后当然你可以设计一些mcp这个我没有去我只设计个最简单的我们就不过了其他的就没有什么了context上下文这个很好这个就是当前每一轮对话当中最大的上下文长度是200k个偷感嘛你看我现在已经一万齐了已经扎了99%了什么都没开始聊其实偷感哪来呢就是我刚才这颗到mb和他系统自带的提示词就是cultcult自带提示词3.9k然后system tools就是用工具11.5k在5.8%就是这些都会在里面那你随着用的过程当中你去看到你每次掉这个指令你就会看到他越来越多越来越接近最后那是不是一定要接近最后越好呢其实也不是针对你的任务难一度来粉丝如果你一个任务不太复杂你已经做完了就是这个一轮对话解决了比如指用到这那你就怎么样你就可以停结束就是clear把当前的这个对话删掉然后重新试试放上下文再开启一个新的对话再做一个新的功能这样有什么好处呢就是说你新的功能不会被你过去的这些无关的记忆或者说上下文所污染或者叫做占用你的投诡数量因为本质来说我们跟我学过大语和模型基础理论就知道你这个上下文长度比如说你是180k实际上你在问一个问题的时候你是在把之前的180k将是你个问题的几K一起丢给大模型去做一次180k的相似度计算那这个时候你的投根越多你的平均这个softmarts之后的重要的投根的占比有可能越小那如果模型产用一些投不K或者是温度不同调的话很可能你最佳的那个投根就没出来所以呢就是所谓的上下文太长了它会不会污染嘛但是不管那你无关的你会去掉就是重新开启一个当然如果说是有关的比如说你下面这个功能是依赖于上面某一步的这种中间过程那你就延续下来当然如果你觉得太多的话你就做这个compact就是自动压缩上的文比如说你已经到这了然后你觉得差不多你又开始写新过的但是有一点点东西跟之前相关的你就压缩一下它它会把这个压缩重置压缩到大概这么多然后你再重置开始写新过的就是一些小的方式当然如果你已经用到接近两百可以以后它会自动之行这个压缩过程给你启动一轮吸的对话那样的吸的对话开启的时候就不是这个百分之九了已经开启的时候可能就是20%可能已经到这了就是这样的一个原理所以也没有太多可以说的大家可能看到我这里还有一些你们看不到的这种制定这个是什么呢就是个性化的制定比如说E2E test就是我的端刀端测试先讲一下这个什么东西相当这个相当这个多制的你相谋它用三个不同的语言有构做制能体的边排然后拍送做跟M&M之间交互的总比如说掉了APL 掉了MCP工具然后RUST是做的Agent的核心它做了很多因为它这个内缩省内存也安全的杀线环境所以基本上每一个运行环境都是RUST那这三个不同的架构时候是三个不同的容器他们之间又通过GRBC来去沟通的交互不是RUST APS是GRBC他们之间沟通的交互需要做测试需要做Divops这些东西从我一个样本的快锐进来到最终出去我到经历至少这三块中的跟它每一块都要经历那我怎么做测试呢如果传统做测试的话你得一个一个自己手动测试对吧 还打个EUI或者打开什么现在写一个E2E test自动报测试了这个是从我的contentant bill的开始到重启然后到单元测试到一个query到最终的结果的验证比如是验证我的换存验证我的PostQuery SQL数据库验证中间的这些压缩状态验证我的所有的规则我的Policy对不对要验证Budget就是Token的预算等等很多然后不同的Workflow有React,ChannelSault有Superwise Workflow和SynproWorkflow它都会做一个完整的验证有什么用呢比如说我们在新开发了一个新的功能的时候你肯定会改到之中的某个某块你非常怕影响之前的已经工作好的功能再次你就一个新功能之后就运行一下E2E TestAntonant Test去看一下有没有影响到你之前的工作流这个过程你就自动化了比你人工去一次一次的测试快很多我就放在这让它去跑一下大家可以看到这个过程你看它自动会直行脚本然后问了一个问题然后自动刚才能刷的比较快它去这个插换存然后查这个过程自动运行一个Hook对吧Antonant E2S Test然后检查这个结果是不是每一步都是正确的是我们在在马中定义好重的情况而没有Fail或者Error这样的情况你看它去GRPCoreGRGURL去搜索我们的DRPC05002是我们的Goal Castrator然后去查一下Task Status Completed就是已经完成了所以这个简单的E2E Antonant Test就已经完成了所以它下面是一个比较复杂一些长一些的Test这个在我们的UID也是可以看到的就是刷一下这是刚才已经完成了这是所有的状态系统推的这些Stream那你还可以把详细的内容都标出来就是中间的思考过程我们简单过一下这个是工作流开始然后Goal Castrator我们的边拍器开始了然后两秒钟就是EmmiD就是直信一个Task然后我们去寻找一下Covic每一步的过程其实这个叫做什么呢这个Deterministic就是我们可以重播就是每一个简单所有的AZN工作流我们可以的重播一点这个在企业级多是能体力吗是非常重要的现在大部分的框架是没有这个功能的因为你要省机嘛你要DBug所以每一步它干嘛的拆解任务都超秒两秒钟然后CheckTokenBuget就是我们会给每一个任务或者每一个T没用户会设置一个TokenBuget有时候你不希望今天一下花了这个一万美金对完今天就算可能1000美金所以你要在每一个工作流程当中去检查一下这个Buget然后其中一个Synpultaskworkflow简单的任务处理然后DadaDadaDada一堆那么最终就是这个是问题然后思考过程然后带上了多个智能体打打打打这个结果而出来我们就不仔细看了这个也可以在哪里呢也可以在这里做个测试比如说我们可以问一下Who is the pricement of us我们要UseWeb SearchTo这个工具集成了然后Unsure in Chinese用中文回答我们看一下这个尖绵也很酷那么现在边拍机开始然后启动了一个字的智能体它是在SOW那个Web Search应该是成功了非常快那这个我们就去一只看一下这个就是刚才的个问题没有用中文回答但是它是用远远回答我挡住了这个Bug最后面这个思考过程这个不对拜登应该是特朗普来一件这个是调用的一个小冒险一个甜甜的比较后期这个就是一个演示我们看看E2E Test你看这个时候还是不会问我要我自动让我按一下不是全自动的有些需要脚本它并不是完全自动讲这个东西的目的是什么就是现在科学库的并不是单单帮你写台码而是帮你整个自动化CACD很完整的多多单测试流程这个东西怎么做的关键是在这这个Doclaw的下面我们有Commence你可以把你要做的Commence的写在里面就可以了比如E2E Test就是这个刚才我运行的那么我已经把一些从头到尾的该做的事情你要怎么buildDocquerContinue要用什么 URLand这个接口端口去测试等等自动化流那么就走里边自动化流就是这样的意思我可以做很多其他的这种快速命令比如这个命令就是帮我 review一下构的我们的边拍器看看最新的大伙的问题这个可以再丰富一下一些那就是说当时我这些东西怎么写我不会写太多了其实这个东西也可以让模型把你写比如说我们现在不运行这个了比如说你可以这样就是把这个文件靠毕一个它的路级了你可以这么说还有你Intense或者是update假如你改了很多东西你希望把这个这个文件改一下就是刚才过去把这个任务查到这个中间来刚才还有一堆任务没指请完他就说我帮你赶一下这个倒进去一会儿你就会看到他这里面做了一些修改他还在做刚才的任务这个时候我们看KaLao Code和CoDex对比什么呢KaLao Code其实它是一个最好的多智能体工作流它每一个动作其实是一个自智能体比如说它在做一个ABA请求然后请求回来不少东西嘛这个在后面所以能回来很多东西其实这些东西是一个自智能体的上下来它只是把最终的结果丢回给我们当前的主制能体所以它并不占用我们当前主制能体的上下门穿口这个是它非常好的地方所以它每一步的自任务比如说去做一个测试或者调用老国结口做一些网络请求或者交叉业证的时候它并不影响我们当前主任务的上下门它只是让了一个另外一个进程然后把过程数据一对Log然后看问题总结一个结果把这个结果再丢回我们现在的上下门然后再去匹配做下一步的任务你也可以在它直行过程当中随时往里面加东西它会比较智能的加在里面你看它就给我丰富了我们看看它改什么了刚才这个门界就改得非常多而且在智能在哪呢就是它读了我的代码库帮我修改的这个门界你有时间的时候就可以仔细去看一看有一些不必要的你可以删掉必要的就给了留下大部分还是比较必要的因为它训练的预料都是一些最佳时间在里面所以这就改得非常好我下次再运行这个钩就是这个时候它就在直行这个门界的时候的东西所以从一个Comperience to the Review都是一个板整的你看这个插关了很多任务帮我检查我的够代码所以你在改了你的够代码之后你可以运行这个指令去炒到一些前来的问题我们先不运行它了这里面还有一些其他的我预设的一些指令就不多讲了还有什么比较重要的呢就是这个Agent 指智能体你可以创建一个指智能体这个东西是什么这个东西非常简单这个东西就是Agent就是一堆的这个像马克上文件一样它最近改成YM文件了指智能体和这个Comperience差不多它都是干一些事情但是指智能体可以在对话中自动触发比如说我这个叫Devops 指能体然后我这个叫Rust SpecialistTemperor Specialist这个什么意思呢比如说我在一个对话当中你改的一对东西比如说帮我修改某某某某功能然后完成之后使用你可以爱得一下它这个指能体叫做比如说第8个第5个所以是我的第8个眼睁那这样的是个什么意思就是它先会帮你拆分任务改你的需求功能改完之后会自动掉用这个Agent然后去执行这个Agent内容那这个Agent什么内容呢这个Agent就是带码的第8个然后在里面写了很多第8个的逻辑然后就能自动运行所以你就可以跑到旁边去干点别的然后全部运行完再回来你可以交叉很多个不同的智能体放在这里面让它去运行看你的思想是不是丰富了我这里面预设了一些我的工作流程遇到了智能体还有一个就是Hooks这个Hooks也很有意思比如说什么是Hooks就是也是在这个聊台过程当中你可以去触发的一些功能比如说叫做FinishD2E Test然后你修改了很多的功能修改完之后你让它做一个完整的端端检查然后Commit and push to open PR就是Commit之后然后 push到其他不上再其中一个PR好了这个东西我就这么去回车之后它会怎么就在测试完之后Commit之前会自动掉入我的CiCheck就是做一遍所有的Ci检查代码检查比如说Unitice等等自动的Build CargoRust Cargo等等这不认会自动之行如果有错误的话它就不会自动继续的Commit或 push所以你可以做一个PrecommitPrecouch这样两个Hook它会自动的在里面去触发的并知性这个工作流入自动化了你不用等到Push到Gita不上之后发现问题在本地发现问题改好了你在晚上 push是ClockCode的用法我觉得ClockCode差不多命令就是这么多实际在用的过程当中人家坚持的坚持了在启动新项目的时候在做我们山农的项目的时候写文囊的时间站到一半甚至以上从零起的用项目中最关键的是写文囊就是你希望项目什么样的架构每个架构实现什么样的功能用什么样的技术甚至于它们这些交互的这种方向的定义尽量仔细的定义好你就会说这个确定的像写作文一样确实像写本小说一样但这个过程也可以自动化你有个最初的想法之后你可以怎么样你可以让写在这里面最初的想法写完以后其实最佳的方案是你保存一个ReadyMe这样的一个文件或者说一个Marker文件保存在这然后你把你自己想你可能想不到太多你可能只想得了10号你就用你10号的语言把你大概要做什么描述清楚比如说我要用NextJS做一个前段的项目并且有后端的NoJS做A.P.A.接口然后我要实现个什么什么东西用大概什么样的这个技术站你写完以后呢表示这个文件你就把这个文件的路件靠毕一下然后你就到这个里面来我可厉害一下你说这个帮我把我这个文件根据当前最佳的这种时间封复一下这个是一个很有意思的我因为来说就是UseWebSearchFetch的SodaInventation and CorrectI'm going to put my intation in the end好了这个就是你的这个目录杀的文件你要和读这个文件并且什么呢去网上搜索Soda就是StateOfTheArt最佳的实现方式来比较我的这个东西去更改我的这个文件就是您中位可以你要这样去改它它第一轮就会改的比较封复当然有时候你会觉得要改太多的不好那你就再看一看然后你就再看一看然后哪一段时候你需要改的你给它改掉然后还是同样靠屁过来然后改一下你说我要改的一些地方请你再继续更新改模型模型模型模型的地方这样你改个十来四这个文件可能有多个版本你可能存多个版本但是你可以两个不同的版本再交叉A起让它MIRT黏合然后我们再去看看这个时间非常重要因为你求厌证它我们在做的其实并不是真正的所谓的VipCodingVipCoding是不懂代码的人在做现在这个词应该叫什么呢我认为应该叫Agentic这个是Android5所谓的AgenticCoding也就是AgenticCoding也就是叫智能体化编程那么我们用智能体特别大的优势因为它在海量的这种代码语调上已经做完学习 预训练了和强化学习了它写Litcoding也好或者写任何的时间方式都比我们要写得好这个毫无疑问比如说最近Linux 跟大佬Tarvis一直在说VipCoding不好那是为什么呢我觉得这个可能多多少数处级到以前的工作方式2030年了一直是以代码优雅和这个逻续来为写的现在变成了AI来写了那么个人的这种能力就被缩小了对吧就不会写代码写那么好的人通过AI一个把自己能力放大了所以这是用心里落场那你更不上时代你再是大佬也不好使现在这个时代未来一定会是初级的程序员会被AI所替代但是不论你的编程或者说逻续写代码的方式逻续方式逻续好还是不好我觉得都没有什么重要的都没有你去控AI重要就是你了解AI怎么去用你能用好AI去帮你写出更好的代码完整的代码没有错的代码效率比较高的代码这个是更重要的所以说写文党懂架构会去控AI这个是远远大余你现在去写几个Litcode这个编程不如说那个不好只不过是效率的级别不同就像你虽然是一台非常好的手工打制的瑞士名表但是现在有智能手表了它的功能就是比你多所以接收度也高那么哪个卖得更好呢当然智能手表是一样道理所以AgenticCoding也是未来的一个方向一脚就脚骗了忘记脚哪去了所以这个Coding刚才讲就是写出写文党比较重要根据文党不断的改需求当你改了一个非常完整的文党之后你再去让它开始写代码就非常简单了你就跟它说就是使用到它那个文党开始一步步不断先让它不断一下或者一步步进化先变成立即显然它给你输出一个级它给输出一个比较长的一个土度的意思然后每一块大概有几个例子你可以初步看一下如果你觉得比较长的话你就得靠比下来再存成一个马克上然后细节定位你给它改如果是比较短的话你就直接在聊天场里说毛级处理需要修改其他没有问题你就开始变成这样就可以了就是不断的循环这样的过程这对比较简单的项目呢都是这样的一个过程那么都是熟悉的一个进程除了code之外最近codeX比较活嘛codeX用起来更简单主要的几个都给你消耗了一个毛的模型现在有1234567个模型前面这三个呢在codeX后面都是普通的GBD5用起来的话当然是这个后面带high的这两个是最好的那区别就是这个是针对变成的我感觉就是去掉了一些非变成的SFT的微调任务而增加了一些集中一些蛋码任务在里头那这个就是纯粹的啥都有所有的这个强化就是用了很长的这个TestTime Compute的这个强化学习去长似思考那么也包括了很强的蛋码能力测下来的话呢我觉得这个这个感觉这个效果更好尤其对于一些非常复杂的交叉验证的需要就像山龙这个项目不同的模块依赖关系层级比较复杂的项目GBD5效果更好和codeSownit相比或者是opens相比的话呢难的问题肯定是GBD5high解决得更好那边层速度来说它很慢它是这种大概4考过这个几分钟生的10来分钟去完成一个任务的过程中也不怎么说话它后面它也不给你展示很多东西但后面呢是在很长很长的一个4考这个Token输出的过程之前我们也分析过为什么长时间的4考就能结果更准确呢是因为你灌的Token越多虽然上下来没越长了你灌的Token越多只要相关的Token数量越多不是乱罐不是你写的是魔性人在输出的越多那么相似的这个匹配的级率越大也就是说可能重要的信息越多越能走出那个正确的路线有可能中间有些路线是不对的因为前方就一直看开始和结局不看中间的路线但是因为大量阳本结局对了可能中间的某些路线就给你走对了我实测下来不是100%能做对的大概也就70%吧针对山东这个项目来说这个CLOBCODE是一样它还达不到70%的正确度所以这个时候你怎么去弄呢那么就是交叉验证比如说在这边完成了一个功能我们可以做一个演示比如说我可以认识一下我看了做个什么演示就是说那个UI是比较好去的时候想一下一时还想不出来特别复杂了它简单的话没有这个意义它UI来说比较直观行因为后多的项目可能不那么直观就拿这个UI来说这个幕露比如说我们就拿这个幕露来说我们要改一个东西这个Events对我们让它这样吧默认做一个不用点它我点了以后会这个Time line一万出来不用点它就出Time line这样的一个感觉我们现在是在Clunk后里面In the dashboard最好是给它一个录性我们这个Tasks这个录性UI的话就形容一下它在哪个上面Tasks DetailsIn the Tasks Details section我们有个按钮Button to trigger点这个按钮Build Time line这个Button Trigger Time lineButton Trigger Time lineHow to make it default就是Time line配置了我就是说我想把这个改成不按钮就直接把这个蓝色的这些Time line自动显出来这个逻辑什么呢我们有人脑的思考的话其实就是当颜面加载的时候就自动直行一下我按这个电影按钮然后它就在这边然后它就在这边然后它就在这边然后它就在这边然后它就在这边然后它就在这边然后它就在这边开炸我按这个电影按钮后他直接那个quayrate就行了就是一面加载的时候就自动直行quayr然后把我们的面在这些每一个T2给它populate在一起就这样一个逻辑那让它去思考并没有让它去编成让他去思考看她怎么去思考一个过程结果它直接把我改了就是你要点这的话那它就以后一直不用问你就改点上面的话每一次改刺那点node的话就不让它改读NOW被扣的 only pro plan只是输出你的计划不要先不要改带马然后要演示一下如何用Color code和 codex来交叉验证这样功能这是个非常简单的功能但是如果是到我们的后台这个比较复杂的框架里面去这个时候有很多相互责任的旗幽感要做交叉验证这个时候呢一两次往往是不会成功的好了这个是它的不烂一般呢我们就会看一下对吧你用中文的话就是中文的不烂你会看到懂假如说真正的外部扣你或者你没有时间的话那或者你不去它对不对怎么办呢你把这个东西靠不下来然后呢到这扣在这去你就这么问I have a task就是刚才那个就是刚才我们那个任务最好给它行动一遍然后呢第二点 agent靠谈就另外一个Agent做了如下的不烂来自 double check就是你一样另外一个AI去评估另外一个AI就两个AI来回去评估如果他们俩答成一致了以后那么写这个代码我看是99%的概率正确的所以他就根据刚才这个Agent的输出其实相当于什么相当于你的当脑里面的一个想法作为你的提示词然后让模型去验证里是一样道理只不过这个提示词不是你想的是你个比较强大的AI给你提示的但你也不确定是不是100%正确让他去修改一下我经常这么去交叉验证因为这个时候省很多当脑细胞有这东西确实也不懂那么他大部分同意的事情是对的有一两个不同意的他也不硬完全正确你可以再拿后来去验证一下他如果你愿意动脑的话那你自己动脑的脑子所以这个过程当中是有的时候需要动脑子有的时候两个完全自动化最佳的理想状态是两三个未来全部交叉验证自动化之后达成一致那么去写代码写代码再review一下另外一个AZN去试review一下这个代码同时像我刚才说的做一步的全流程的端端端测试都怕死了以后这个都OK了如果哪个没怕死没有怕死的部分再交给另外一个AZN去验证循环将去验证那么这个理论上来说是可以做到一个完全自动化的非常状态人最后需要干嘛呢我们就去这个这个UI段去点一点验证一下对不对就行了只要你的整个流程写的证据最没问题所以他出来的上当是nosedly true绝大部分是对的但是不完全对的部分是什么然后不对的部分是什么这两个是不对的部分对吧这样不对部分我们可以再反过来问他问他来 stop check 都 make 吃简单来说那你在简单一边在简单一边看到对不对如果他 agree 了基本上就是行了但是这里面还有就是说我们在问一个问题的时候有的人说claw code 前两条不降致了吗实际上他并怎么说呢这个他有三个这关键词你可以正常的问问题肯定就是继续那他就是简单的这种不思考或者说简简的思考然后你要说给这个sync的话他就是简化的思考你要sync的话他是中等的思考你要是给他这个肯定r 传sync他就是长时间思考让他GPD5一样他就思考的过程会显出来他就是这个完成任务实验比较长当然也更非claw code 他自己的偷感因为我们这是暴跃的嘛所以就看到这里面无限的这种输出过程然后去交叉寻还验证另外claw code 最好的地方是我觉得clawex他适合解决一次性的难的问题然后帮你把代码写出来或者给你一个框架但他并不适合去做divox这种这种写完以后自己去验证这种没有claw code的好clawclaw的才是完全可以全流成自动化只要你把相关的工具你的hooks你的clawman你的指令给他修好的话整个流程是完全可以自动化的这个是一定程度上我觉得是能让一个人变成十个人的最佳时间好了他不多这个结果是另外一个一种gpt50对的那么行所以他俩达成一致了我们就可以跟这些人说什么来let's go aheadand implement你也可以加一个outro sync那他就是在一路无思考或者sync heart都行这样的话一步步就完全出来赶完之后的文件你会看到这里面比如说有颜色的这就是改动过的对吧看一个比如说这个有颜色的那么这部分就是在新加的我们加了几个环境编辖在这里面好今天没有什么准备那么跟人分享的主要的这些细节的一些东西就需要靠在自己的摩扫体验重要的是学习的常试而不是直接拿来受人语而不是受人语希望爱学习同学们和对m感性同学们能在理论和时间的两条路上越走越远拜拜
