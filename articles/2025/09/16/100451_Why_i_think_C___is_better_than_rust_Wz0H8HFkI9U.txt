Timestamp: 2025-09-16T10:04:51.296013
Title: Why i think C++ is better than rust Wz0H8HFkI9U
URL: https://youtube.com/watch?v=Wz0H8HFkI9U&si=g94Kj0Ff_zutL48_
Status: success
Duration: 32:47

Description:
以下是对文本内容的总结：

**总结要求：**

1.  **大纲式结构总结**
    *   **I. 引言与背景**
        *   文章探讨了C++相较于Rust在编码平台上的吸引力，特别是在低延迟交易（LTT）的特定背景下。
        *   核心论点：尽管Rust被视为更现代且安全，但在某些关键领域C++仍具优势。
    *   **II. 语言底层与优化机制**
        *   **LLVM基础：** C++和Rust均编译至LLVM中间表示（IR），大部分优化在此阶段进行。
        *   **Rust的额外IR层：** Rust增加了HLIR、THIR和MIR等层，主要用于类型检查和安全机制（如借用检查器）。
        *   **Rust特定优化：** 存在关于MIR级别Rust特定优化的主张，但其性能影响尚未得到确凿证明。
        *   **智能指针：**
            *   C++的`unique_ptr`被认为开销极低，接近“免费”；`shared_ptr`因原子计数器而有明确开销。
            *   Rust通过编译时处理内存安全，简化了某些内存管理问题。
            *   Rust的迭代器被视为“零成本抽象”，能有效避免额外分配和闭包开销。
    *   **III. 性能：C++的未定义行为与Rust的严格性**
        *   **Rust的严格性与检查：** Rust的严格性体现在数组边界检查（除非使用`unsafe`模式）和整数溢出检查（仅在调试模式下），这些运行时检查会带来显著的性能开销。
        *   **C++的未定义行为（UB）作为优化手段：** C++通过将如带符号整数溢出等视为未定义行为，允许编译器进行更激进的优化（例如，`(val * 2) / 2`直接优化为`val`），从而减少指令数，提高执行速度。
        *   **Rust的明确行为：** Rust中的溢出行为是明确定义的（如补码），这阻止了C++中利用UB进行的激进优化，导致生成更多指令。
    *   **IV. 内存访问与缓存局部性**
        *   **C++的优势：** C++提供对内存的完全自由访问，便于实现内存密集型算法和数据结构，从而更好地利用缓存局部性。指针的抽象层次使其易于编写底层代码。
        *   **Rust的挑战：** Rust刻意使直接内存访问变得困难和耗时（如在不使用`unsafe`的情况下实现双向链表），旨在让开发者专注于业务逻辑而非底层位操作，但这可能阻碍精通缓存优化的开发者。
    *   **V. 编译器与开发生态**
        *   **编译器选择：** Rust强制使用`rustc`（基于LLVM），而C++拥有众多高质量编译器（GCC, Clang, MSVC），提供更多选择和特定平台的优化优势。
        *   **开发者资源：** C++拥有远比Rust庞大的工程师群体，尤其是在专业级开发者方面。尽管Rust社区充满热情，吸引力强，但短期内C++的人才储备更具优势。
    *   **VI. 安全性之争：背景决定需求**
        *   **作者的经验：** 在多年的C++编码中，作者极少遇到堆栈溢出或段错误。
        *   **应用场景差异：** 对于非公共、内部隔离的数据中心机器（如LTT），黑客攻击的内存安全风险并非主要关注点，甚至会关闭安全缓解措施以求极致性能。这与操作系统等面向公众的系统（如微软70%安全漏洞源于内存安全）形成对比。
        *   **崩溃处理：** 任何语言都可能崩溃。C++的段错误可以通过信号捕获处理，但程序状态可能已损坏；Rust/Go的“错误即值”模式在推理程序状态和错误处理上通常更清晰。
    *   **VII. 结论与个人看法**
        *   **文章作者的结论：** 对于其低延迟交易的特定需求，Rust的性能优势不明确甚至可能为负，而安全性并非首要顾虑。因此，Rust的陡峭学习曲线目前不值得投入。
        *   **评论者的看法：** 评论者个人偏好Rust的现代特性（如Cargo、错误处理），并认可Rust迭代器的零成本抽象。但他同意文章作者的结论在“特定应用场景”下是合理的，即C++在追求极致微秒级性能的领域仍有其不可替代的优势。

2.  **核心观点：**
    鉴于Rust在性能上的潜在劣势及安全性优势对特定低延迟应用场景并非核心关注，文章作者认为目前迁移至Rust的陡峭学习曲线不具吸引力。

3.  ** overarching framework:**
    在低延迟交易背景下，对比C++和Rust在性能、安全性、内存管理及开发生态方面的技术与成本权衡分析。

<Mermaid_Diagram>
graph LR
    subgraph "核心语境"
        C["低延迟交易场景"]
    end

    subgraph "评估维度"
        D["性能"]
        E["安全性"]
        F["开发体验与生态"]
    end

    subgraph "C++特性"
        A["C++"]
        A_D1["未定义行为优化"]
        A_D2["直接内存访问"]
        A_E1["内存安全风险"]
        A_F1["编译器多样性"]
        A_F2["庞大开发者群体"]
    end

    subgraph "Rust特性"
        B["Rust"]
        B_D1["运行时检查开销"]
        B_D2["明确的溢出行为"]
        B_D3["零成本迭代器"]
        B_E1["借用检查器"]
        B_E2["数组边界检查"]
        B_F1["Rustc单一编译器"]
        B_F2["陡峭学习曲线"]
        B_F3["Cargo现代工具链"]
        B_F4["高开发者热情"]
    end

    C --> D
    C --> E
    C --> F

    A --> A_D1
    A --> A_D2
    A --> A_E1
    A --> A_F1
    A --> A_F2

    B --> B_D1
    B --> B_D2
    B --> B_D3
    B --> B_E1
    B --> B_E2
    B --> B_F1
    B --> B_F2
    B --> B_F3
    B --> B_F4

    A_D1 -- "显著性能提升" --> D
    A_D2 -- "精细控制与缓存优化" --> D
    A_E1 -- "对特定场景安全影响有限" --> E
    A_F1 -- "更多优化和平台选择" --> F
    A_F2 -- "人才储备优势" --> F

    B_D1 -- "引入性能开销" --> D
    B_D2 -- "阻止激进优化" --> D
    B_D3 -- "潜在性能优势" --> D
    B_E1 -- "编译时内存安全保障" --> E
    B_E2 -- "运行时安全开销" --> E
    B_F1 -- "工具链统一性" --> F
    B_F2 -- "高入门门槛" --> F
    B_F3 -- "提升开发效率" --> F
    B_F4 -- "未来潜力与社区吸引力" --> F

    A -- "作者最终选择" --> C
    B -- "当前不适合" --> C

    style C fill:#FFF3E0,stroke:#FF9800,stroke-width:2px,color:#333;
    style D fill:#E0F2F7,stroke:#2196F3,stroke-width:2px,color:#333;
    style E fill:#E8F5E9,stroke:#4CAF50,stroke-width:2px,color:#333;
    style F fill:#FFFDE7,stroke:#FFEB3B,stroke-width:2px,color:#333;

    style A fill:#CFD8DC,stroke:#607D8B,stroke-width:2px,color:#333;
    style A_D1 fill:#B9F6CA,stroke:#00C853,stroke-width:1px,color:#333;
    style A_D2 fill:#B9F6CA,stroke:#00C853,stroke-width:1px,color:#333;
    style A_E1 fill:#FFCDD2,stroke:#F44336,stroke-width:1px,color:#333;
    style A_F1 fill:#E3F2FD,stroke:#90CAF9,stroke-width:1px,color:#333;
    style A_F2 fill:#E3F2FD,stroke:#90CAF9,stroke-width:1px,color:#333;

    style B fill:#F0F4C3,stroke:#CDDC39,stroke-width:2px,color:#333;
    style B_D1 fill:#FFCDD2,stroke:#F44336,stroke-width:1px,color:#333;
    style B_D2 fill:#FFCDD2,stroke:#F44336,stroke-width:1px,color:#333;
    style B_D3 fill:#B9F6CA,stroke:#00C853,stroke-width:1px,color:#333;
    style B_E1 fill:#DCEDC8,stroke:#8BC34A,stroke-width:1px,color:#333;
    style B_E2 fill:#FFF176,stroke:#FFD600,stroke-width:1px,color:#333;
    style B_F1 fill:#CFD8DC,stroke:#90A4AE,stroke-width:1px,color:#333;
    style B_F2 fill:#FFECB3,stroke:#FFC107,stroke-width:1px,color:#333;
    style B_F3 fill:#E1F5FE,stroke:#03

Content:
 Why I think C++ is still a desirable coding platform compared to Rust, okay? Okay. I mean, this is a bold take because, I mean, you don't even get a build tool with C++. Just so you know. Not communist for starters. Don't, you're trying to bait me again. We're not getting baited. Not getting baited? When a question is made comparing compiled languages like C++ and Rust, the typical generic answer comes both our compiled languages with no slash minimal runtime that lets you write whatever the machine can do. So performance will depend on your writing and not your chosen language. Interesting. Okay. I think I see where this take is going. I think I see where this take is going. It's very interesting. While this is largely true, there is lots of important details left that are important to be highlighted. Not without controversy. Of course, here, I will try to dive into some of those insights. Okay. So this actually seems like it's going to be a really good article because I've been wanting to see someone voice a good defense of why C++ is still good. My general take is that it's very easy to still do. Well, I mean, easy is definitely a skill issue when I say this. It's still very easy to do shared mutable memory in C++ comparatively fair, fair take, I think. Okay, I think, but you also get, I'm just going to continue reading, but you also get the with with with C++, if you choose to use unique pointers or shared pointers, you you have a runtime slowdown that effectively rust solves at compile time. It's just easier to work with, right? It's just much, much easier to work with. So that's kind of like in my head, how I kind of think about the C++ versus unique pointers are free, man, are they free? Are they fully free? Shared pointers are not free, right? They have an atomic counter, correct? I didn't say, okay, we're going conflicting answers. I didn't think unique pointers are free. I know shared pointers definitely cost something. Shared on, okay, okay, people are generally saying, I mean, I could see why unique pointers should be free because ultimately at the end of the day, long as you are semantically corrected and compiled, you should be able to just get rid of the unique pointer. I mean, I think that's pretty fair. So hopefully, unique is just a destructor thing and is deleted a move copy constructors. Okay, so it's still non, it's still something, just not as much. It's, it's low, low overhead. All right, because you know, it's cheaper than non move copy constructors and all that? No, none, none's always more free than something, even if the overhead super small, it's still cheaper than nothing. Okay, it sounds like we're getting kind of, I would have to look it up. I don't know the exact outcome of a unique pointer. So I just know they exist. They're great. They make life really, really easy. They give you a lot of those safety features that you've always wanted. They're fairly easy to use and bottom being bottom, boom, your code's significantly safer and C++ and more managed and easier to work with the team with a unique pointer shared pointers also are pretty neat. But I know that they come at a cost. That's like, that's my working mental model. I don't know exactly what a unique pointer does in comparison to a shared pointer other than that shared pointer has the atomic counter and unique pointer doesn't have it. But what does it do and how does it does it manage it does the compiler completely just take out all constructs of a unique pointer and just turns it into the thing just hides it completely. I have no idea below. I took a picture from an article on research gate above. Sorry, in principle, both Rust and C++ are compiled languages that use 95% of the LLVM compiler infrastructure. Rust and C++ are translated into IR intermediate representation where most arguably all optimizations are made below. I took a picture from an article on research gate about loop optimizations. Notice that in the first clang box, no optimization is being done. Only pre processing macros, etc. And de sugaring, e.g. lambdas, all optimizations are done in the second box where C++ no longer exists as a language. All right, there's all this good stuff. Here's all the canonical, canonicalization passes, loop optimizations passes, poly loop vector as a vectorized late, mid, end passes, classic late, mid, end passes, you know what I mean? Classic. It's the classic late, mid, and it's a beautiful, it's a beautiful thing. Okay, the translation layer exists between, I actually have no idea what LLVM actually does. So this all just sounds magical. I've never really studied into optimizations. I know they're quite magical. They're quite fantastic. And it's one of the few times in life where computational theory and the real world meet. And you actually can do some pretty cool stuff. I've always wanted, it's one of those like, I've always wanted to learn X for me that was in that realm, right? It's always in the always one of the learn. This translation layer exists between C++ and its respective AST abstract syntax tree, as long as as a logic container, are not conducive to feed optimization algorithms. Most optimization logic needs to be portable information rich and quasi assembly representation, where all the side effects are resolved. That is why C++ and all other languages get converted to IR intermediate representation before optimizations are performed. Okay, perfect. The same logic applies to languages like Hulia, Scala, and Rust. Rust adds three extra IR layers, HLIR, THIR, and MIR. Ooh, the trilogy. Most trilogy suck in successive lowering steps. Still, these extra layers are related to type checking and safety mechanisms, e.g. the well known Rust borrow checker. Okay, cool. Cool. The parenthesis here, Rust claims that there are Rust specific optimizations done at the MIR level that will in the future impact performance significantly. I have found a list of such transformations, but I could not assess nor prove that the performance impact is real or just rhetorical. My post on Reddit asking for comments on the subject has also not produced any conclusive proof either way. So even the experts are on the fence on this one. I feel it was more wishful thinking on the part of the documentation writer at the time. Very interesting. One thing that I will say that I really do like about Rust and what it can do is you do these iterators are zero cost abstractions. When you look at like the compiled stuff when it comes to an iterator, it's pretty neat to be able to see that your filter map, whatever, can all just run in line. To me, that is a really nice experience in my book. I really enjoy that because typically, like if you're from a JavaScript language, you forget that the closures created, the functions created, the new array is created, whereas you just get less stuff created in it. Zero cost for those type of things, which I think is super cool. Iterations are a huge rust W exactly. I really do love that about Rust and I feel that that is like a super under championed feature of why Rust is really cool and it's easy ish to write well performing code. But this is where the similarities end. I need to recall that this publication is about low latency trading and as our trade offs, when deciding if something is worth it will always lean towards the item that leads to performance increases. Okay, so this is super cool. Low latency trading requires you to be making decisions as soon as possible. So nanoseconds matter here, which I think is pretty exciting. I love this idea. If we were a company that produces web servers or web browsers, then the conclusions below would probably be different be a different nature. Okay, very exciting. Performance is not only instruction by instruction execution time stamping. Before one gets to the actual instructions, an entire pipeline of human and machine interactions come into play. Some of these factors will be discussed below, beginning with the safety tool. Assuming for a second that both C++ and Rust are compiled within the LLVM framework, is any of the two language languages able to produce IR that leads to faster execution in all situations. Okay, good question here. I like I like what this is going. I actually really enjoy like this, this line of article. Rust tends to be more strict than C++. It's it's raison d'etre. And that means more real time checks, although integer underflows and overflows are only checked into bug mode. Memory accesses in arrays are constantly checked for bounds unless you're in unsafe mode. Oh, I did not know that. No, that makes perfect sense. That makes perfect sense. Of course it has to, right? Is that true during production too? Okay. Okay. Okay. Okay. Okay, which defeats the purpose. Those checks alone take significant toll. They slow down the process compared to the retrospective naturally unchecked C++ code. Yeah, but you can get unsafe. Okay. So, so the argument is that yes, if you if you want speed to that level, we're including the bounce check on an array is a significant toll, right? Significant toll. Therefore, unsafe would be the the answer to this question. Okay. But is that an apples to apples comparison? Well, yes, if you're going to list the safety of Russ compared to C++ as a pro, then it's just as fair to list the performance hit of such safety in regards to execution speed. Agreed. Great. Great take right there. You can't list it as a positive on one side without listing the negative on the other side. I think that that's a great that's a fair, a fair ass take. You can't talk about safety, safety, safety. Oh, you can't say that. That's unfair because that's not apples to apples. I could use, I could use, I pick you just made my brain WTF with that ass take. Okay. I said fair, fair ass. Okay. Fair dash ass. The ass was not dashed on the take. Okay. Okay, buddy. Get me. All right. Undefined behavior C++ relies extensively on undefined behavior. I mean, this statement isn't the greatest to say out loud in your head or to write down on paper. Okay. I don't think that that's like a great thing you want to really do as an optimization enabler. Oh, really? UB can make a brutal difference in many cases. Really? Okay. Okay. I got to hear this. Russ, on the other hand, it does not and cannot leave knots untied because it focuses on security. Okay. How? Show me. For, for example, the simple C++ snippet shows how C++ is UB can make a huge difference in the routine, knob, which we return the results of the division of a number multiplied by two by two. It seems obvious that this should result in the original number and the assembly code just moving the input argument in the EDI register into the output register, EAX cooperates that. Okay. So it's able to optimize. Look at that beauty. Look at that nice beauty right there. It optimized it. Okay. Cool. When was this article written? That's a great question because yeah, it was written yesterday. Yes, turn a. All right. All right. I want to see this. However, when you consider the edge cases, things are not so clear. What happens if you multiply two up by 30 by two and then divide by two? What do you get? Point zero? Oh, negative. Yeah. Oh, yeah. That's right. 31, you get the whole negative thing. These are signed in. Oh, yeah. They're signed in. Divide by two. It is this big old negative. Then that that's a big difference. Yes. It is a big difference. So why C++ ignored that possible edge case? Because signed overflow in C++ is undefined behavior. And as far as the compiler is concerned, it will never happen. Oh, I think I see. I think I totally understand what's going on here. What is the what that? Okay. So this is actually a super interesting case right here. With the edge case reasoned away by the language, the compiler is free to implement that optimization. If you compile a similar function in Rust, you'll see that Rust will be unable to optimize that expression away because both signed and unsigned overflows in Rust are well defined in the language as to's complement. This result in assembly below where the first line, Leal, the result of the multiplication by two is computed. In fact, it computes the value plus value instead of a value times two. Smart. I mean, that's smart right there. That's a smart one right there. And then the result is halved by shifting right. SAR. Okay. Okay. We can see what happens here. It moves this into EAX. Okay. And this one does a few operations here, a little Leal, a little Sorrow, and then a little Red Q. Okay. Okay. Again, pundits will state that you could have called one of the arithmetic wrapping functions, which forced the compiler to do this optimization. Well, you can do many things, but but here we are measuring the effect of the compiler over two similar code blocks. Okay, fair. I think the statement and what he's saying, I think to re say what he's trying to say is that you have to do more things to get the same outcome in Rust. Is that a fair statement? All right, cache locality. Just write better code. I mean, you have to do a whole extra thing to make sure that these optimizations are happening. But do you really need to take optimizations before measuring? So the reason why these things happen is again, he's saying exactly why he's doing this, which is real time trading, where like, if you're trying to do 4x arbitrage, you got to be able to respond within like, you know, 500 nanoseconds might means you don't get the arbitrage. So how fast you need to respond is really, really, really important. So when you have extra instructions, it's not good. And these people do do FPGAs. This is how they also lose $400 million in a few minutes, right? So it's bugs are really expensive in this department. We have that whole article $400 million lost in like 40 minutes, because of a single because of power peg. The greatest named function of all time power peg gets power pegged. It was so beautiful. Cache locality C++ has full unfettered access to memory by design. See, it's ancestor. It's an anti sesser. Is that what I don't know this term? I don't know what an anti sesser is. Well, that's not helpful. I'm getting what you called me boy. I'm confused at what's happening here. Did I just get dumped on somehow? I don't even know what's going on here. What the hell is happening? All right. It's it seems like ancestor supposed to be the word, but we're using some other term here. Brazil mentioned did we just get a present? Can we get a confirmation confirmation Brazil mentioned died died by Homo erectus. My Homo erectus lasted longer than four hours. I am now dead. Was created with the use case of it being a low level language, just a tad a bit above assembly. Huh? What? That's probably this is probably the video that gets me canceled, like out of all videos to get canceled. This might be the one. Okay, this might be the one that actually makes it happen. C++ inherit that which makes it arguably the easiest language to code memory intensive algorithms and data structures like hash maps, B trees, vectors, and lists. C's pointers have a simple and intuitive meaning. This is so good. This is like my I've never copy and pasta copy and paste. Put it over here. Everyone's logical jump they have to make. Oh, I put cues. Wait, what? How did I put a cue there? There we go. Said one guy ever. This is that that has never been the case. I that is probably that one of the most frequent questions I've ever had is how to how do pointers work? I know it's simple. Like once you know how pointers work, you're like, ah, that's stupid. Of course, that makes perfect sense. But until you know them, they feel hard. Almost forgot to rebrim it up. Well, thank you, Ryan Winchester. Flashbacks to my university. Is this an onion article? This is shockingly not an onion article. It's actually a really good it. This is a well, this is a well asked done article for you pick, allowing even junior developers to grasp and even write statements that would be extremely hard to understand an assembly. Okay, that's actually a really fair take. That's a great take right there is that it's not. It's not that pointers are easy. It's that their counterpart in assembly is really hard. And so the simple abstraction that see makes on top of assembly makes it really makes it great to work. Okay, I understand that. While rust does not allow the same, it makes it very difficult to get away with it. This is true. We've read articles. We've seen examples. unsafe rust is hard. Again, this is by design. Russ creators do not want you to be bit twiddling, but focus on business logic first. So they made so they made is such that accessing memory directly is painful and time consuming. Yes, we've seen this unsafe rust, not not simple. This means that good developers who know how to take advantage of cash slash locality will have a good time implementing such algorithms and data structures with C++ and will likely will very likely struggle with rust for the same task. I still am not sure if I can make a doubly linked list in rust. Okay, I'm just saying I could make a doubly linked list in JavaScript in like a minute and a half. C++, C++ probably like 10 minutes just because I have to remember. I have to go look up. And then in rust, it's like, I don't think I could. I don't think I could today. It might take a little while for me to do that. You know what I mean? It might take a little bit. You just DQ in the rust list. You suck. Yeah, scale issues. No, it's C++. I did do that. It's a scale issue. It is totally a scale issue. You have to use weak pointers in C++ still. Do you? Yeah, thank you for this one. Yes, I've seen I've read the book too many damn lists. Anyways, we'll look at that at some point. All right, rust mandates the use of its own compiler, Rust C. Oh, hold on. Okay, let's see. Compiler choice. Rust is an offspring of the LLVM project. And so is Hulia, Kotlin and Scala without LLVM. Rust would not have existed. Rust mandates the use of its own compiler, Rust C, which is a top driver for the of the LLVM stack. Pretty much as clang is for C++. C++ on the other hand has dozens of good quality compilers available in many platforms. Okay, bold, bold to take. Borland, anybody? Can I get a Borland? Can we get a Borland? I guess for me, this doesn't make a lot of sense, but that's probably due to the environment that I work on. So maybe this isn't like a huge W for me, but maybe it's like a huge W for something else, right? There are platforms that I don't work on. Maybe that is a lot easier, right? So I don't want to say, hey, it's terrible, but maybe there's something to that that makes more sense. I don't know. GCC, for example, is the most ubiquitous C++ compiler today. It exists by default. Think app install build essentials in every Linux distribution. GCC has a much better optimizations and specific cases like function calls we analyzed in this previous article. Oh, super cool. On Windows, it's hard to beat Microsoft's tooling and better tooling does influence in the way you get performance optimizations done. Fair fair take. Not surprising that game development is almost exclusively a Windows operation, right? Fair. No one's going to argue that one resource available resources available, although the scenario is changing rapidly, the pool of engineers with C++ background is much larger than the pool of Rust developers. Also still fair to say for now, let's put it this way. I think what I think would be better to be said in this state is the pool of expert C++ developers is much larger than the pool of expert Rust developers. Like I would consider myself an average Rust developer, right? I can do things. I can get things done. I can do some lifetimes. I can work out some decently performance stuff, but I wouldn't like I'm a tinker. I would put myself in the tinker, the tinker, you know, category. But as far as like expert goes, I would most certainly say I am not even close to that. And then you got to consider like the entirety of the game industry, right? Like the entirety of the game industry are pretty damn good at C++, right? They are they are they are pretty damn good. And so I have never met a game developer that I'm not pretty decently impressed by except for TJ calling himself a game developer while writing a engine in OCaml. Yeah, right. Not not real. You know what I mean? Not real. Yeah, right. Anyways, so if I want to bet safe in the development of a new system, I have to go with C++. I think I think one thing that you're one thing that this article super discounting is what I call the hype factor. And if I were to post a job today saying C++ position available at some prestigious company, the response would be pretty good. I'd probably get a lot of I'd probably get a decent amount of applications. But if I flip that and said the same thing except Rust, I bet you my application rate would double if not quadruple. So I do think that there is an eagerness for people to use Rust that is not present in the C++ world, right? Why leave your current job likely doing some C++ or whatever to go do C++ elsewhere, whereas most people aren't working in Rust, again proven by the fact that there's only 20 professionals currently working in Rust, and they are totally willing to jump over to do Rust, right? They're excited about it. They're excited. They're ready. They're they're lubed up. You know what I mean? Yeah, if you're building Chrome with C++, why leave exactly? You have to have a real reason to leave. The dubious benefits of safety. When Rust is brought up in a meeting, the first pro pro factor is language safety, but safety against what? In many years of coding C++, very rarely I experienced a stack overflow or segmentation fault. It is literally not an issue in every code base I have worked with. Okay. We are talking about safety against hackers. The large majority of C++ applications are non-public facing. So much that the data center machines run with mitigations turned off since there's absolutely no possibility of contact with those machines with bad actors. So hacker safety is not a concern that I, in particular, would care unless I'm coding a web server. Oh, yeah. This is actually, I could say this. There's definitely some potential. I can understand this argument. I think I'm understanding this argument right here, right? I still am kind of doubting the whole thing, but still anecdotal evidence, but you know, data is just the plurality of anecdotal, right? For the most part, that is that is a huge portion of data that you read. Is this true? Like, I don't know. I have no idea, but I can appreciate the perspective. Sample size one, likely not data. Are we talk, or are we talking about protection against crashes? Well, don't get me started on this one. First, crashes can happen in any languages with the same frequency. I often point to this article about Princeton's unmanned vehicle team competing in 2000 sun DARPA challenge as an example of how even a heavily protected garbage collected language that's a C sharp can crash and burn, leaving your process unusable. It's pretty funny. It's pretty funny when you're crashing and burning and doing that. I do think that C++ is really hard to I think it's harder to get right. So just saying the dubious benefits of safety. Maybe there is some truth to that in the sense that once you get good enough at C++, the likelihood of you introducing a bug goes down. I can buy that. But the guarantee that there's no bug is non present, right? You just have no idea. Right, Valgrind is great. Valgrind gives you a lot of information. 70% of all security bugs at MSR are memory safety ones. Again, but this is an operating system in which everyone can access and try to take advantage of. That is a much different situation than a server in which is running some process in which no online process is attached to, right? I get that. These are these are different problems trying to solve different things. Right. Sanitizers are cool too. Yeah. Yeah. Yes. Close loop versus open loop systems. Exactly. I do think that there's a whole, there's a lot to be said for that. What percentage of bugs are security bugs? That's another great question. 70% of security bugs are due to memory type issues. What percent of bugs are due to security? Right. It's too hard. I mean, try coding a B-tree. Well, first off, coding a B-tree in general is a little bit tricky. So adding a, adding an extra layer of rust is always makes it harder. You know what I mean? It is in the standard lib. You can just do B-tree. This is true. All right. Let's see. Exceptions can throw a Java process back to the main and helpless on how to proceed. The process will puke in an undecipherable excuse of and bail out. Oh, but C++ segmentation falls is much worse. Say the haters. However, a sag faults can be caught with a wrapped signal trap and handled cleanly like any Java C-sharp exception. Okay. It still leaves the same problem, which is that you don't know the state of your program and at the point in which the, I mean, it's the same reason why I don't like throw, right? I don't like throw as a construct in general. So I think that that's a plus one in rust always, which is that exceptions are not handled by throwing. They're handled by returning. This is also a go, a go thing as well, right? Uh, errors as values just typically lead to easier reasoning about your program. Because at every step, you have to handle what could happen if there was an exception there. So your ability to return whatever state you were in to a reasonable state is just, it's just simply easier. Make sense? Yeah. Yeah, the sag faults mean your data is corrupt and the best choice is to cancel the process. Pretty fair. I'd say that's fair. Zig Zig again. Very nice. I like that. Uh, conclusion, given that the performance benefits are either in, uh, in conclusive, non-existent or more likely negative, the safety benefits are not really that pressing for most applications is that really worth moving to a completely new language with its infamous long and hard learning curve as rust. That's good to think about. I mean, I think the one problem I think we inevitably have is, uh, perception issues, right? We have anchoring bias, um, which means that you've heard your whole life that C++ sucks. And so when you read an article like this, it's hard, to take in what this person is trying to say. Because you just, what you, you're trying to fit it into this view that C++ sucks. Rust is awesome. Right. And so I like rust. I would rather use, uh, I'd rather use rust than C++ hands down. All the reasons he said are just not reasons for me. And so I wouldn't have arrived to the same conclusion. I'm not concerned over, uh, whatever this, this, case is right here, right? Like I'm not measuring performance on an instruction base. So it's not really something for me. I like cargo. I like the fact that I can stall what I need via cargo. I don't like the fact that every single project requires hundreds of little dependencies kind of giving me this node, node modules feel, right? Um, I can understand this, which is there is a, there's several learning curves when it comes to rust. But there's also a general learning curve when it comes to C++, right? And the curve is not as fast, but does it end in the same absolute position? I am not sure. I don't know. Like I honestly don't know if it ends in the same, the same position. Uh, if I had been writing C++ full time for 30 years, I'd probably just keep using that. Yeah, that's a very fair take. Right. This is kind of what you have to do. Telling makes a big difference. Also the community is more welcoming in C++ probably got him. Yeah. For new devs, what should you start learning? Uh, probably probably rust is my general take. I think C++ will give you a better understanding of memory to begin with and actually gives you a better love for what rust does. But then I think it's harder to understand memory and layout and things when starting with rust, right? You can learn C. You can learn C in that. You get the same experience. It's just something to think about. You know, I do not know the general answer, but for me, for now, it is not worth it yet. I like rust a lot. It is much more modern language than C++. No, modern C++ is not modern. It's just lipsticks on a cute pig. That's a very nice compliment to C++ you just gave there. And I truly would like to move to it eventually. However, it did not cross that threshold where I would tell a client to definitely jump on a boat. Okay. I mean, I actually don't disagree with his conclusion. I think his conclusion is actually really good. Like when I take the perspective of what he's attempting to accomplish with the language he is choosing, it just seems like a better decision. You know what I mean? It just seems like a better decision. I get why he's doing what he's doing. Will it forever be like that? I don't know. Oh, no, I like this. I like this talk. I like this thinking. I think this was really, really great. I think a lot of people don't think probably as deeply as this this Henrik individual is on this. Happy about it. I mean, PhD. Okay, we got a PhD over here. I know I don't got a PhD. Nuts at all. So just something to think about. Just a reminder. Oh, nice. Let's go Netflix. Let's go Netflix. Oh, Netflix. No, come on. Let's go. Come on. Keep going north. Keep going north. Keep going north. The name. I still prefer a rustogen. I prefer a rustogen.
