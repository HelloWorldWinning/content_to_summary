Timestamp: 2025-09-21T22:20:17.792078
Title: 刚刚Java25炸裂发布！让Java再次伟大 gGjZzgWSIiI
URL: https://www.youtube.com/watch?v=gGjZzgWSIiI
Status: success
Duration: 11:00

Description:
以下是对Java 25新特性的总结：

**核心要点：**
Java 25在开发者体验、性能优化和并发编程方面带来了显著改进，使其更加现代化和具有竞争力，但对于现有项目而言，升级并非必需，了解新特性以备未来和面试更有价值。

**总体框架：**
Java的演进：在平衡向后兼容性的同时，实现现代化、提升开发者体验与优化性能。

---

**一、总结大纲与结构**

1.  **引言**
    *   Java 25作为长期支持版本，带来了“颠覆认知”的特性。
    *   旨在提升开发者体验、优化性能、增强并发能力。

2.  **正式特性 (Formal Features)**
    *   **作用域值 (Scoped Values)**
        *   **解决问题:** `ThreadLocal`在虚拟线程下效率低、易忘记清理、值可被随意修改的问题。
        *   **方案:** 提供线程内及子线程间高效、安全共享不可变数据的方式，自动清理，不可修改，适配虚拟线程。
        *   **注意:** 不完全替代`ThreadLocal`（mutable数据仍需`ThreadLocal`）。
    *   **紧凑源文件与实例主方法 (Compact Source Files & Instance Main Methods)**
        *   **解决问题:** 传统Java `main`方法的繁琐样板代码。
        *   **方案:** 极大简化“Hello World”等程序的编写（如三行代码），通过`java.io.Console`和自动导入常用包实现。
        *   **影响:** 对初学者更友好，利于开发小型工具和脚本，有助于Java保持竞争力。
    *   **灵活的构造函数体 (Flexible Constructor Bodies)**
        *   **解决问题:** `super()`或`this()`调用必须是构造函数第一条语句的限制。
        *   **方案:** 允许在调用`super()`或`this()`之前执行参数校验、字段初始化等逻辑。
        *   **优势:** 提高构造函数的灵活性和安全性，防止调用未初始化的子类方法。
    *   **分代ZGC (Generational ZGC)**
        *   **解决问题:** 传统垃圾回收可能导致长时间的应用停顿。
        *   **方案:** ZGC的分代模式转正，通过区分年轻代和老年代，更频繁、高效地清理短生命周期对象，减少对长生命周期对象的扫描，降低GC停顿。
    *   **紧凑对象头 (Compact Object Headers)**
        *   **解决问题:** 小对象头部占用内存过大（16字节）的问题。
        *   **方案:** 将对象头从16字节压缩到8字节，减少内存开销。
        *   **注意:** 非默认开启，需手动指定，可能存在兼容性问题。
    *   **模块导入声明 (Module Import Declarations)**
        *   **解决问题:** 导入大量包时需编写冗长`import`语句。
        *   **方案:** 一行代码导入整个模块，使大量包可用。
        *   **争议:** 简洁性带来可读性差、潜在命名冲突和依赖不明确的风险。
    *   **新的密钥派生函数 (New Key Derivation Functions)**
        *   **作用:** 引入新的加密原语和算法。

3.  **预览及其他重要特性 (Preview & Other Notable Features)**
    *   **结构化并发 (Structured Concurrency)** (预览特性)
        *   **解决问题:** 传统并发模型中线程泄露和资源管理混乱问题。
        *   **方案:** 通过作用域管理并发任务，确保所有子任务在作用域结束时自动清理，支持多种执行策略。与虚拟线程结合可高效处理大量并发。
    *   **可延迟初始化不变值 (Deferred Initialization Immutable Values)**
        *   **解决问题:** `final`字段必须在构造时初始化，可能导致高昂的启动成本或不必要的资源浪费。
        *   **方案:** 允许延迟初始化不可变的字段，同时保证不可变性，底层利用JVM `@Stable`注解进行优化。
        *   **用途:** 适用于创建成本高昂但并非所有实例都会使用特定字段的场景。
    *   **基本类型支持模式匹配 (Pattern Matching for Primitive Types)** (未来方向)
        *   **目标:** 将模式匹配扩展到基本类型，简化类型检查和转换。
    *   **其他改进**
        *   Java 15起不再支持32位系统。
        *   Java内置性能监控工具优化。
        *   Vector API (向量计算方法)。

4.  **总结与建议**
    *   Java 25虽有全面进步，但对于新项目，Java 21已足够。
    *   对于老项目，Java 8仍可继续使用，无必要急于升级到Java 25。
    *   **建议:** 学习和了解Java 8及之后的新特性，以提升技术视野和应对面试。

---

**二、<Mermaid_Diagram>**
graph TD
    A["Java 25 新特性：全面进化与平衡"] --> B1("提升开发者体验")
    A --> B2("优化系统性能")
    A --> B3("增强并发编程")
    A --> C("升级与采纳建议")

    subgraph "正式特性 (Formal Features)"
        B1 --> F1("作用域值")
        B1 --> F2("紧凑源文件与实例主方法")
        B1 --> F3("灵活的构造函数体")
        B1 --> F4("模块导入声明")
        B2 --> F5("分代ZGC")
        B2 --> F6("紧凑对象头")
        B1 --> F7("新密钥派生函数")
    end

    subgraph "预览及其他特性 (Preview & Other Features)"
        B3 --> P1("结构化并发 (预览)")
        B1 --> P2("基本类型模式匹配 (预览)")
        B2 --> P3("可延迟初始化不变值")
        B2 --> P4("Vector API")
        B2 --> P5("JVM内部优化")
        B2 --> P6("弃用32位系统支持")
    end

    F1 --> I1("高效安全共享数据 (解决ThreadLocal痛点)")
    F2 --> I2("简化入门代码 (Hello World)")
    F3 --> I3("构造函数更灵活 (参数校验前置)")
    F4 --> I4("模块化代码组织 (争议：可读性/冲突)")
    F5 --> I5("降低GC停顿 (低延迟垃圾回收)")
    F6 --> I6("减少小对象内存开销 (需手动开启，有兼容风险)")
    F7 --> I7("支持最新加密算法")
    P1 --> I8("解决线程泄露与资源管理")
    P2 --> I9("简化类型检查与转换")
    P3 --> I10("延迟初始化不可变字段 (高性能场景)")
    P4 --> I11("向量计算能力")
    P5 --> I12("内部性能增强")
    P6 --> I13("聚焦现代架构")

    I1 --> B3
    I2 --> B1
    I3 --> B1
    I4 --> B1
    I5 --> B2
    I6 --> B2
    I7 --> B1
    I8 --> B3
    I9 --> B1
    I10 --> B2
    I11 --> B2
    I12 --> B2
    I13 --> B2

    C --> S1("新项目: Java 21 足矣")
    C --> S2("老项目: Java 8 仍可用，不急于升级")
    C --> S3("建议: 了解Java 8+ 新特性")

    style A fill:#4CAF50,stroke:#333,stroke-width:2px,color:#FFF;
    style B1 fill:#8BC34A,stroke:#333,stroke-width:1px,color:#FFF;
    style B2 fill:#FF9800,stroke:#333,stroke-width:1px,color:#FFF;
    style B3 fill:#2196F3,stroke:#333,stroke-width:1px,color:#FFF;
    style C fill:#607D8B,stroke:#333,stroke-width:2px,color:#FFF;

    linkStyle 0 stroke:#4CAF50,stroke-width:2px;
    linkStyle 1 stroke:#FF9800,stroke-width:2px;
    linkStyle 2 stroke:#2196F3,stroke-width:2px;
    linkStyle 3 stroke:#607D8B,stroke-width:2px;

    style F1 fill:#FFC107,stroke:#333,stroke-width:1px,color:#333;
    style F2 fill:#FFC107,stroke:#333,stroke-width:1px,color:#333;
    style F3 fill:#FFC107,stroke:#333,stroke-width:1px,color:#333;
    style F4 fill:#FFC107,stroke:#333,stroke-width:1px,color:#333;
    style F5 fill:#FFC107,stroke:#333,stroke-width:1px,color:#333;
    style F6 fill:#FFC107,stroke:#333,stroke-width:1px,color:#333;
    style F7 fill:#FFC107,stroke:#333,stroke-width:1px,color:#333;

    style P1 fill:#BBDEFB,stroke:#333,stroke-width:1px,color:#333;
    style P2 fill:#BBDEFB,stroke:#333,stroke-width:1px,color:#333;
    style P3 fill:#BBDEFB,stroke:#333,stroke-width:1px,color:#333;
    style P4 fill:#BBDEFB,stroke:#333,stroke-width:1px,color:#333;
    style P5 fill:#BBDEFB,stroke:#333,stroke-width:1px,color:#333;
    style P6 fill:#BBDEFB,stroke:#333,stroke-width:1px,color:#333;

    style I1 fill:#E8F5E9,stroke:#333,stroke-width:1px,color:#333;
    style I2 fill:#E8F5E9,stroke:#333,stroke-width:1px,color:#333;
    style I3 fill:#E8F5E9,stroke:#333,stroke-width:1px,color:#333;
    style I4 fill:#FBE9E7,stroke:#333,stroke-width:1px,color:#333;
    style I5 fill:#E8F5E9,stroke:#333,stroke-width:1px,color:#333;
    style I6 fill:#E8F5E9,stroke:#333,stroke-width:1px,color:#333;
    style I7 fill:#E8F5E9,stroke:#333,stroke-width:1px,color:#333;
    style I8 fill:#E8F5E9,stroke:#333,stroke-width:1px,color:#333;
    style I9 fill:#E8F5E9,stroke:#333,stroke-width:1px,color:#333;
    style I10 fill:#E8F5E9,stroke:#333,stroke-width:1px,color:#333;
    style I11 fill:#E8F5E9,stroke:#333,stroke-width:1px,color:#333;
    style I12 fill:#E8F5E9,stroke:#333,stroke-width:1px,color:#333;
    style I13 fill:#E8F5E9,stroke:#333,stroke-width:1px,color:#333;

    style S1 fill:#CFD8DC,stroke:#333,stroke-width:1px,color:#333;
    style S2 fill:#CFD8DC,stroke:#333,stroke-width:1px,color:#333;
    style S3 fill:#CFD8DC,stroke:#333,stroke-width:1px,color:#333;
<Mermaid_Diagram>

Content:
当张加娃25正式发布这是计加娃21之后又一段长期支持版本也是加娃开发者们最期待的版本之一其中有的特性可以说是颠覆了我对加娃的认知让加娃再次为大那么加娃25都发布了那些新特性有没有必要升级呢点个收藏让我们开始吧好 先来讲一下加娃的正式特性第一段呢 是比较实用的Govd Wireless作用预执再讲这种特性前我们先来思考一个问题怎么在同一证现成内共享数据我估计大家的答案是Streadlotal但是有没有想过Streadlotal会存在什么问题比如这是一段很典型的使用Streadlotal的场景在同一证求内或许用户的信息先保存在独取这段代码其实暗藏玄机可以看出Streadlotal的痛点第一个问题是Streadlotal必须要手动清理资源很容易忘记第二个问题是其他代码可以随意修改已经保存的值有可能导致预期之外的结果所以如果你想让此现成也共享负现成的数据那你的每个子现成都要去负质一份数据那如果你用了加瓦21的虚拟现成特性1000的虚拟现成就要负质1000次现成就比较差所以加瓦25的Streadlotal特性就是为了解决这些问题的它允许方法在现成内以及子现成间高效安全的共享部转变的数据我们看一下它的写法其实是Streadlotal很像首先创建一种新的实力然后这行代码是关键我们通过Wayer往作用率绑定了一些值然后通过Round能够在值得作用率内直行任务在任务中的代码就可以获取到我们写入作用率的变量只要出了这的作用率值力就被清理掉了不需要手动一处而且作用率一旦绑定它的值是不能修宅的这样就正安全防止意外的状态变争如果配合虚拟现成使用所有的虚拟现成会共享同一份数据内层占用也会正少再分享更多专业它的使用方法比如支持协代反回值支持欠套作用率可以在同一这雕用中绑定多者作用率值还有一种更高级的操作就是和加娃的节度化并发特性打着配合此现成可以自动继承负现成的作用率值但是节度化并发制的特性过了这么多版本还没有转正等它转正之后我觉得加娃并发编程的模式可能会发生一些改变注意虽然作用率值听起来比StreadLotal更高级但它不能百分百替代StreadLotal如果你要在现成中中中想不可变数据尤其是用了虚拟现成的场景建议使用作用预值但如果你的现成中共想的数据可能是这变量需要更新那还是使用StreadLotal第二个正式特性是模块倒入声明我们在加娃久的时候其实就已经提到落模块系统的概念了学前那种同学应该不陌生了模块系统允许我们把代码组织成一着着的模块每种模块有明确的依赖关系以及你要倒出体重给其他模块什么样的接口这样一来我们整个大型应用的架构就变得非常的清晰可以为护而模块倒入声明是在这的基础上建议部简化了开发体验比如以前我们开发家经常需要编写大量的倒入语句但现在你只需要用一行代码倒入整个模块只需要一次倒入就可以使用大量的包感觉对于刷散法的同学来说好像有一点帮助但是我感觉这个特性会比较有争议虽然代码简洁但是它的折独性很差而且可能存在一些秘密冲突的风险依赖也不中明确比如像这的例子如果倒入多种模块时遇到了同名类来解决所以我个人可能不太会使用这种特性下一种特性锦凑原文件和实力主方法这是我最喜欢的特性直接打破了外界对加娃的特版印象之前不是很多同学觉得加娃入门比拍摄难吗我一直简单的哈罗尔的我要去理解什么Publica斯大剃着外的妹还有斯珠隐Kohel-Aps但如果你用Piesa或者JS直接写一行代码就完成了在加娃25周这种问题终于优化了哈罗尔的程序可以直接减解为这三行代码这么一看是不是觉得和好多编程一元都有点像安能变我是加娃但是你知道是三行代码的含金量吗你知道加娃为了把代码减写成这三行付出了多少努力吗首先是在加娃25的浪包中新增了IOLA体重了正简单的控制台Io操作比如打印呀从控制台中堵起自播穿案等等还有在锦凑原文件中所有的加娃基础模块倒出的包都会自动倒入就像是有这样一行代码也就是说你可以直接使用这种这样加娃的常用类这样一来加娃对初学者会更加友好而且也能快速地用加娃开发一些小的工具和脚本我觉得这的特性也是让加娃再次伟大的关键为什么呢因为一直以来加娃的核心竞争优势在于他成熟完善的生态系统但是余法不中简洁而现在加娃只需要持续借件其他新星编程语言的优秀设计和余法特性同时得开发者体重平滑的技术升级路径就肯定还是会有很多的开发者继续使用加娃就不会被别的语言取代了就让我们国内的一些巨头产品我觉得是一样的下一车特性是灵活的构造寒树体这车性其实是为了解决一种加娃天生的限制构造寒树中的Super或者Z色调用必须是第一条语句我估计很多同学对这的限制都没什么印象了这的限制虽然它保证了对象出使化单纯性但可能会影响到我们的编码比如大家看一下这段弹其实我的残数教验不符和要求我还要先调用负类装造寒树做一些不必要的出使化工作加娃25打破了这些限制引入了新的装造寒树执行模型等来说我们能在装造寒树调用之前添加一些语句比如说做一些参数教验出使化自断等等看到这里有没有感觉一直以来被的八股做的一些加娃基础的选择题供他了此外这的特性还能防止负类装造寒树调用子类没有出使化的方法但是要注意在续研阶段存在一些限制比如不能使用类似引用不能掉用实力方法只能对未出使化的资段进行复职总之这的特性让包造寒树变得正加灵活安全适合我们需要复杂出使化逻辑的场景还有正式特性了解一下就好了就是加娃说明时代的发展推出了新的密奥派生寒树你可以简单地把它理解为新出了一些加密中级类体重了一些新的算法下面这个特性我觉得是值得关注的就了解多加娃对象结束从选业来知道加娃对象除了存储数据本身外这会带来什么问题呢比如你要在程序中创建大量的小对象有可能对象头本身占用的空间比你实际要存储的数据都要多加娃25把紧凑对象头特性转正把对象头从16字节压作到了8字节减少了小对象的内存开销但是紧凑对象头并不是默认开启的需要手动指定毕竟你少存一些信息肯定要考虑到一些监融性比如下面这些情况就会有一些问题所以它准备是一把双任键下一车特性也是要了解一下的想加娃这种自动垃圾收集的语言我们经常会遇到这种问题垃圾回收一直行应用就卡顿了停顿的时间有可能多达几百毫秒甚至几秒这对程序的影响还是非常大的审单度作为加娃中严实最低的垃圾收集器在加娃25中它的分代模式转为了正式特性简单了解一下什么是分代垃圾回收大多数的对象都是招生稀死的所以把对内存化分为年轻代和老年代两的区域年轻代的垃圾收集可以更加平凡招效也可以动态的清理掉这些垃圾而老年代的收集频率相对效低就可以前少对长期存活对象的不必要的扫描不过建议大家还是证据实际情况按需配置这位M好正式特性讲完了其他的特性基本上大家了解一下就好了第一个就是我们刚才提到的节目化病发现在很多很多同学会使用H-Tutors-SWICE实现病发会写下面这种代码但这段代码存在的问题是如果你一个病发任务执行的方法失败了其他的病发任务还在后台运行成了就存在自源的浪费而且如果当前的现成被中断紫任务不会自动取消而节目化病发就是为了解决病发编程中现场泄露和自源管理问题的它的用法也很简单首先领域展开创建一阵节目化病发的作用域在这的作用域内我们就可以通过FOT的方法开启紫任务可以用中文方法等待所有紫任务完成或者失败在执行其他代码而且作用域结束后所有的紫任务都会自动清理不会泄露这样就解决了自动清理一场传播和自源管理的问题从来节目化病发还体重了多种执行策略比如说任何一座任务失败就取消还有任何一座任务执行成功就把其他任务取消节目化病发再搭配虚拟现成就是清松处理大量病发可以说是一种王炸祖盒下一车特性是基本类型支持模式匹配简单来说就是我传某座付类型的编量它会争取我的编量类型自动匹配到对应的紫类型然后复制得紫类型的编量便于我们快速进行类型的检查和转换但目前的模式匹配只能用于引用类型所以慢慢的它产品还会支持基本类型的而且基本类型的模式匹配它会检查转换是否安全比我们手动鞋范围检查方面多了最后一者要了解的特性是Dable Wireless 稳定值这对特性我觉得对大多数推发者来说没有什么用那我先问大家一个问题Final子段大家应该不陌生但是Final子段存在什么问题呢它必须要在构造时出实化对吧举个例子 这段代码中你的捞着日质对象必须立刻出实化但如果你创建这对象出实化的过程本身很耗实是不是所有的实力都要等待可能会影响起动性呢特别是在对象很多但不是每个都会用到某些自段的场景下这种强制出实化就很浪费但我又想保证不扯变性怎么办呢诶 稳定值特性来了它体重了延迟出实化的不扯变性看这段代码其实不就是包裔层嘛没什么是做一种封装解决不了的还有更简单的写法可以在声明时指定出实化逻辑这个写法是不是觉得有点眼熟大家在弹幕上告诉我你们使用哪些类估时也见诺这种写法此外呢它支持集合的延迟出实化大家还是要知道这段特性它的底层使用了这位M的Stable助解它就能够和Final子段享受一样的优化所以大家也不用担心它的性能这特性就很适合创建成本高的对象而且不是每个实力都会用到的子段你记想要延迟出实化又要保证不可变如果你需要追求极致的性能这的特性还是挺实用的最后就是一些有的没的的特性比如说加挖15不支持32位系统的使用了还有加挖内置的性能监控中剧做了很多的优化直接大家自己了解一下就好了最后还有Webster API可以让你在加挖中使用这种这样的相量计算方法以上就是加挖25的心特性不知道大家有什么感想可以在弹幕上打出来我的评价是虽然加挖25在开发体验性能优化和并发编程方面都有进步与路径战但是目前对于新项目选择加挖21就够了对于老项目还是可以继续用加挖8真没有必要升级到加挖25但是我还是建议大家把加挖8及之后的心特性都了解一下拖穿下支持面连试的时候也能对面试官多了几句我也把缅费加挖教程和加挖心特性大权都整理在编程岛上了如果本期内容对你有帮助记得点赞关注三连支持我们下期再见
