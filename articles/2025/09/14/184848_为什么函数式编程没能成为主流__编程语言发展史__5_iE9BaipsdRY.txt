Timestamp: 2025-09-14T18:48:48.955616
Title: 为什么函数式编程没能成为主流？｜编程语言发展史 #5 iE9BaipsdRY
URL: https://youtube.com/watch?v=iE9BaipsdRY&si=ntOBkGBhktALEhxF
Status: success
Duration: 9:01

Description:
以下是对文本内容的总结：

### **函数式编程的演进与非主流化之路**

**Overarching Framework:** 函数式编程从其深厚的理论基础出发，通过多门语言的探索与实践，在纯粹性、并发性和容错性上展现了独特优势，但因缺乏主流平台支持、商业投入和高学习门槛等原因，最终未能像面向对象编程那样成为主流。

---

**一、理论基石：Lambda 演算 (1930年代)**

*   **提出者：** 阿隆佐·秋奇。
*   **核心问题：** 回答“什么是可计算的”，与图灵机在计算能力上等价（秋奇-图灵论题）。
*   **基本规则：** 变量、函数抽象（`Lambda X.M`）、函数运用。
*   **核心概念：纯函数 (Pure Functions)**
    *   相同输入必然得到相同输出。
    *   无隐藏状态，不改变外部变量，无副作用。
    *   便于像数学公式一样推理程序结果。

**二、早期实践与演进**

1.  **Lisp (1958)**
    *   **里程碑：** 第一门真正将函数式思想落地的编程语言，由约翰·麦卡锡为人工智能研究设计。
    *   **核心特点：**
        *   S-表达式：代码和数据采用相同结构。
        *   函数是“头等公民”、递归、动态性。
        *   **宏 (Macros)：** 本质上是操作代码的函数，能改写和生成新代码，实现元编程和语言自我进化。
    *   **局限：** 高度灵活但也意味着缺乏约束。

2.  **ML (1970年代)**
    *   **背景：** 为RLCF定理证明系统设计，追求更严谨的方式。
    *   **核心特点：**
        *   **类型推导 (Type Inference)：** 编译器自动推断变量类型（如Hindley-Milner系统），提供静态安全。
        *   代数数据类型：简洁表达复杂关系。
        *   模式匹配：直接拆解数据，分支明确。
        *   编译执行：更稳定高效。
    *   **影响：** 为函数式编程建立了类型与安全的秩序，平衡了自由与工程可靠性，影响了Haskell、Scala、Rust、F#等语言。

**三、纯粹与实用的分支**

1.  **Haskell (1987)**
    *   **目标：** 委员会联合设计，汇聚学术成果，体现最纯粹的函数式编程形态。
    *   **核心特点：**
        *   **纯函数：** 所有函数都是确定性的，严格禁止副作用。
        *   惰性求值 (Lazy Evaluation)：表达式只在真正需要时才计算。
        *   类型类 (Type Classes)：更灵活的抽象机制。
        *   **Monad：** 一种设计模式，用于封装和显式化副作用（如I/O、状态），确保函数纯度不受污染。
    *   **应用：** 学术界广泛（如GHC编译器），工业界小众（金融、高可用工具链）。代表了函数式编程的学术理想。

2.  **Erlang (1980年代)**
    *   **背景：** 爱立信为电信行业设计，应对高并发、高容错、全天候运行和不停机升级需求。
    *   **核心特点：**
        *   **Actor 模型：** 基于进程（轻量级、隔离）和消息传递实现高并发。
        *   **容错机制 (Let It Crash)：** 进程出错时直接崩溃，由监督者（Supervisor）重启，实现系统自我修复。
        *   OTP 框架：通用抽象（GenServer、Supervisor等）帮助快速构建可靠系统。
        *   热更新：不停机更新代码。
        *   分布式透明性：内置分布式支持，轻松扩展和故障切换。
    *   **应用：** 电信系统、数据库、消息队列、分布式平台（如WhatsApp）。

3.  **Elixir (2011)**
    *   **发展：** 基于Erlang的BEAM虚拟机，保留Erlang的并发与容错能力。
    *   **创新：** 引入现代化语法和工具链，并通过Phoenix框架将函数式并发模型带入Web应用。

**四、函数式编程未能成为主流的原因**

1.  **缺乏杀手级应用：** 没有类似Java在企业级应用和安卓生态中的推动力。
2.  **未绑定主流平台：** 大多是独立生态，难以自然融入主流技术栈。
3.  **学习成本高：** 与传统的命令式语言差异过大，迁移和学习门槛高。
4.  **商业投入与市场推广不足：** 缺乏大型商业公司的推动，主要依赖社区发展，周期漫长。

---

**核心观点：**
尽管函数式编程在理论根基、语言创新及解决特定领域问题（如高并发、容错）方面展现了卓越价值，但由于缺乏“杀手级”应用、未能融入主流平台、高学习曲线以及商业推广不足等原因，使其至今未能像面向对象编程一样走向主流。

---
<Mermaid_Diagram>
graph TD
    A["函数式编程 (FP)"]

    subgraph "1. 理论基石 Theoretical Foundation"
        D["Lambda 演算 (1930s)"]
        E["纯函数"]
        D -- "核心概念" --> E
    end

    subgraph "2. 早期实践 Early Practices"
        G["Lisp (1958)"]
        H["宏 (Meta-programming)"]
        I["ML (1970s)"]
        J["类型推导 (Hindley-Milner)"]
        G -- "核心特点" --> H
        I -- "核心特点" --> J
    end

    subgraph "3. 纯粹与实用 Purity vs. Practicality"
        L["Haskell (1987)"]
        M["Monad (副作用封装)"]
        N["Erlang (1980s)"]
        O["Actor 模型"]
        P["容错机制 (Let It Crash)"]
        Q["Elixir (2011)"]
        L -- "核心特点" --> M
        N -- "核心特点" --> O
        N -- "核心特点" --> P
        N -- "基于BEAM VM发展" --> Q
    end

    subgraph "4. 未成主流的原因 Reasons for Not Mainstream"
        B["为何未成主流？"]
        R["缺乏杀手级应用"]
        S["未绑定主流平台"]
        T["学习成本高 (与命令式差异大)"]
        U["商业投入/推广不足"]
        B --> R
        B --> S
        B --> T
        B --> U
    end

    A -- "奠定理论基础" --> D
    D -- "首次落地实践" --> G
    D -- "追求严谨性" --> I
    G -- "高自由度，但缺约束促使" --> I
    I -- "推向极致纯粹" --> L
    I -- "启发了高可靠需求" --> N
    L -- "学术理想与工业界需求偏差" --> B
    N -- "工业实践虽成功但生态小众" --> B
    Q -- "现代化发展，但仍未改变格局" --> B

    E -- "严格要求" --> L
    O -- "是Erlang核心" --> N
    P -- "是Erlang核心" --> N


    style A fill:#D4EDDA,stroke:#333,stroke-width:2px,color:#333;
    style B fill:#F8D7DA,stroke:#333,stroke-width:2px,color:#333;

    style D fill:#FFF3CD,stroke:#333,stroke-width:1px,color:#333;
    style E fill:#FFF3CD,stroke:#333,stroke-width:1px,color:#333;

    style G fill:#D1ECF1,stroke:#333,stroke-width:1px,color:#333;
    style H fill:#E2F0CB,stroke:#333,stroke-width:1px,color:#333;
    style I fill:#D1ECF1,stroke:#333,stroke-width:1px,color:#333;
    style J fill:#E2F0CB,stroke:#333,stroke-width:1px,color:#333;

    style L fill:#CCE5FF,stroke:#333,stroke-width:1px,color:#333;
    style M fill:#D6DBF0,stroke:#333,stroke-width:1px,color:#333;
    style N fill:#FFE3D5,stroke:#333,stroke-width:1px,

Content:
在软件发展时上,面向对象变成长期战略主流他通过对象和状态的组织、卫复杂系统提供了一种直观的建模方式但与此同时另一条路线也在敲燃发展,韩宿市变成可为什么几十年过去了,面向对象大型起到而韩宿市变成确实中没有走向主流今天我们就来聊一聊韩宿市变成的发展时1930年代,苏佑佳阿隆佐秋奇提出了拉门的演算他并不是一种变成语言而是一个极简的数学体系用来回答一个核心问题,什么是可计算的在第一集从图灵机到Lisperly,我们也提到过这个问题图灵的460是造一台假想的机器,图灵机而秋奇则用符号系统来刻画计算从时间顺序上看,拉门的演算比图灵机还要找一些后来人们认识到,拉门的演算和图灵机在计算能力上是等价的这就是著名的秋奇图灵问题只要能计算的东西都能用拉门的演算或图灵机来表达拉门的演算只包含三条基本规则第一,变量就是符号,比如X第二,韩速抽象,写作Lamuda X.M意思是输入X得到表达是M比如Lamuda X.X加1就是一个加1的韩速第三,韩速运用就是把韩速作用在参数上向括号Lamuda X.X加1括号二,结果就是三虽然性是简单,却可以表示任意计算过程而在Lamuda演算里还有一个特别重要的概念,存韩速第一,很简单,相同的输入,必然得到相同的输出它没有隐藏状态,也不会去改变外部变量举个例子,存韩速,FX等于X加1同样的输入一定会得到同样的输出飞存韩速,Print,Hello它依赖外部环境还会产生复作用为什么存韩速重要?因为它让我们可以像推到数学公式一样推理程序的结果这就是后来程序是变成了核心思想当然,拉门的演算本身并没有直接进入工业界但它为韩速是变成电丁了理论基础即使年后,第一门真正继承这一次思想的语言诞生了那就是Lisper在第一集中我们已经提到过Lisper不过为了让这一集的内容更加完整这理论需要再聊一聊它的特点和影响力1958年在马上的一公尺院约翰、麦卡锡设计了Lisper它是第一门真正把韩速是思想落地的变成语言当时的主流语、Fox and Algo主要面向数字计算和工程应用而人工智能研究更需要处理符号和逻辑Lisper正是这样的背景下诞生的Lisper有五个核心特点S表示,蛋马和数据采用相同的结构表示比如1加2在Lisper中这几表示调用加法韩速同时也是一个可以被操作的数据结构韩速是一种公民地归掉用动态性Lisper的独特之处在于红它本质上是操作蛋马的韩速输入和输出都是蛋马能在程序运行前改写和生成新的蛋马如图示这个红定义了一个新的控制结构Onless意思是当X不等于0时执行Print在大多数语言中语法有编译去固定而在Lisper里用户可以用红直接扩展语言本身这带来了原编程的能力普通编程是写程序去处理数据而原编程是写程序去处理程序本身也正因为如此Lisper长辈成为一门能够自我进化的语言Lisper将Lamadai演算的思想真正带入编程世界但它的高度灵火也意味著缺乏约束到了1970年的人们开始寻找更严谨的方式于是MRO诞生了1970年代Iden堡大学的罗宾米尔纳团队为RLCF定理证明系统设计了一门新语MRO,Mathland文化目标很明确既要保留逻辑推理的灵火性也要在形式上保证成去的正确性MRO的核心特点可以归纳为4点第一类型推导不同于Lisper缺乏类型检查或RGO需要显示标注MRO让编译其自动推断如土所市编译得出Intel类型这一推于Henelina系统在不增加复旦的前提下提供静态安全和阻类型第二代数数据类型用简洁语法组合结构清晰表达复杂关系第三模式笔配直接拆解数据分支明确可都性高第四编译执行以编译为核心比解释更稳定高小MRO最初用于定理证明后来扩展到编译器和静态分析延伸出Standard MROO-commerce和F-sharp它的影响声援Husko的类型系统原置MROSkylar RustTopsCraft也继承了类型推导的思想MRO会含束是编成建立了类型与安全的秩序在Lisper的自由和工程可靠性之间找到平衡接著学术界将这种秩序推到极致创造出纯粹的韩书是语言Husko进入1980年代韩书是编成已经诞生了Lisper MRO等多种语言但它们理念各一缺乏统一标准1987年多首大学和研究机构学者联合成立委员会左手司机门新语言既要会具学术界成果又要提醒韩书是编成的最纯粹型态这门语言Bas HuskoHusko的核心特性可以盖过为4点第一纯韩书在Husko中所有的韩书都是确定性的相同的输入一定得到相同的输出隐私的副作用是不被允许的第二多性求职表达是只有在真正需要时才会计算即使是一个无限列表也可以安全取出前五个元素第三类型类在MRO类型系统的基础上Husko引入了更灵活的抽象机制第四Mona它是一种设计模式用来封装副作用像I-O状态异常这些都会通过Mona的来见摩这样可以缺宝副作用是显示的而不会污染韩书的纯度Husko在学术界运用广泛最著名的实验室即HC变一切而且它本身就是用Husko协成的在工业界Husko并不足留只在金融边缘工具链等少数高可用场景运用可以说Husko代表了韩书士编程的学术理想把纯韩书和抽象推向机制但在工业界工程师更关系的是病法与容错而不是完美的类型系统于是韩书士编程在实验中走向了另一个道路而廿1980年代电信行业对软件提出了进户科科的要求系统必须全延无休气盛R4老师运行能够同时处理成千上万的通话并且在出现故障时能迅速恢复而当时的编程语言和系统架构并没有专门为这种高病法高容错的场景设计在瑞典的Ily信实验室乔阿姆斯的朗带领团队开始探索一门新语言目标很明确支持海良病法保重进程隔离和自动容错并且能够在不停机的情况下进行升级代码这就是后来诞生的阿朗阿朗有几个核心特性第一病法模型阿朗基于Actam模型进程机器圈量可以同时创建上百万个这些进程比此隔离则通过消息传递通信从而避免了共享内存带来的复杂性第二容错机制阿朗的口号是Late East Corros与其在代码里处理所有抽屋不如让进程在出错时直接崩溃然后由监督者Ceber OS的这种重启这种机制让系统具备自我修复的能力第三OTP框架在语言至上阿朗提供了OTP他定义了诸如基因SEROCeber OS等通用抽象帮助开发者快速构建可靠系统许多领点其实和今天的KBS不模额合KBS有健康检查和重启策略而OTP的Ceber OS早在几十年前就能做到进程崩溃后自动重启KBS提供生命周期管理和滚动升级OTP的Appleicaxi和热更新早就已经写进语言和运行时第四热更新阿朗支持不停机加在新代码系统可以一边运行一边升级避免中断服务第五分布是透明性阿朗内建分布是支持不同机器上的进程可以像本地一样通性天然支持集群扩展和故障切换阿朗最初用于电信系统后来扩展到数据库消息堆略和分布是平台最著名的案例就是WATSApp在被设构之前一个只有几十名工程师的团队就凭假阿朗自称来全球数以用户的几十通性虽然阿朗功能强大单于法成就生态有限2011年巴西程序员核塞瓦林姆基于BAM续拟机创造了Elex他保留了阿朗的病发与容纯能力引入了现代化与法和工具链并借助Finix框架把韩宿士病发模型带入了外伯与互联网应用可以看到从Lisper到阿朗再到Elex韩宿士编程一直在不断演进而且确实展现了不少独特的价值可问题是为什么这么多优秀的思想和实践却始终没能让韩宿士编程成为主流呢原因主要有以下几点第一他缺乏足够大的杀手级应用不像加瓦有企业级应用和安卓来推动普及第二他没有保定在主流片台上谁今天有一个是加斯克蘑克的独战浏览器而韩宿士语言大多是独立生态很难自然人物的主流平台第三他和传统命令是语言差异过大从于语言很难平化迁移学习成本高第四缺少商业公司的投入和市场推广没有像上或微软那样的大公司来推动最后只能依靠社群慢慢积累发展周期被大大拉长那不是主流我们还要不要选呢知道我想起2016年的一篇帖子以League12会成为明日之星吗其中一个回复让我印象深刻好的东西是不是一定会流行不一定我喜欢的东西是不是就是好的也不一定那我会不会花时间去学一个不一定会流行但是我喜欢的东西会下期我们会聊到新时代的编程语言GO RUSTTAP SCRUFTCOTANY拍照也会讲原本想放在这一节但这集的主题是韩宿士编程放进来不太合适所以还是留到下一期我是Roy我们下期视频见
