Timestamp: 2026-01-10T10:08:36.666816
Title: 这个视频能让你对齐claude code的思维方式。 BV1RyeBziEFq
URL: https://b23.tv/Pz4rPjK
Status: success
Duration: 12:45

Description:
好的，这是根据您提供的文本内容提炼和总结的核心思想。

### **CoreCode 高效使用指南**

#### **I. 核心思想：思维转变 —— 从“编码者”到“指挥官”**

- **旧模式 (助手)**：AI 是辅助，人是编码主体，需要频繁审查和修改 AI 生成的代码。
- **新模式 (指挥官)**：AI 是编码主体，人是项目的引导者和决策者。人的核心工作是提供清晰指令、充足信息和关键反馈，而不是亲手写代码。接受“放手让AI去做”的理念，是发挥 CoreCode 全部潜能的关键。

#### **II. 核心实践：三大支柱**

1.  **精细化上下文管理 (Context is King)**
    - **原则**：上下文并非越多越好，而是要提供最精准、最核心的信息。
    - **三大上下文类型**：
        - **个人上下文**：定义个人偏好，如默认回复语言、代码注释语言、常用库、代码仓库位置等，实现跨项目复用。
        - **项目上下文 (`Code.md`)**：包含项目的核心架构、关键模块、重要流程等信息。此文件应提交到代码库，由团队共同维护，确保 AI 对项目有全局和持续的理解。
        - **中间文档 (The Most Critical Element)**：在执行任何任务前，与 AI 沟通、分析、规划所产生的文本记录。这些文档是指导 AI 精确执行任务的蓝图，也是后续迭代和维护的重要参考。用户的主要工作阵地从此前的代码编辑器转移到了这些规划文档上。

2.  **规划先于行动 (“先谋定，后而动”)**
    - **流程**：在编写任何代码前，先与 AI 充分沟通，让它理解现有流程和新需求。
    - **任务拆解**：将复杂任务分解为一系列清晰、具体的小任务。
    - **产出**：生成详细的执行计划和方案文档。用户通过修改和确认这些文档来指导 AI，而非直接修改代码。只要前期规划做得足够好，AI 的执行就很少会出错。

3.  **小步迭代与持续控制**
    - **原则**：避免让 AI 一次性生成大量代码。
    - **实践**：每次只让 AI 完成一个小的、明确的功能模块，然后提交一个小的 Pull Request (PR)。
    - **优势**：
        - **易于审查**：可以轻松地 review AI 的工作，及时发现潜在问题。
        - **便于维护**：代码变更清晰可控，降低了未来维护的复杂度。
        - **避免失控**：确保用户始终对项目有主导权，而不是被 AI 牵着走。

#### **III. 关键工具与技巧**

- **上下文窗口管理**：
    - `Compact`: 当一个阶段性功能完成后，使用此命令让 AI 总结之前的工作，压缩上下文长度。
    - `Clear`: 定期清空上下文，开启新的会话，然后通过加载中间文档，让 AI 快速恢复工作状态，保持上下文的“新鲜”和高效。
- **子代理 (Sub-agent)**：
    - 用于执行代码分析、Code Review、编写测试等独立任务。
    - 其上下文与主对话隔离，可以避免“污染”主线程的上下文，是管理复杂任务的利器。
- **规划模式 (Chat/Plan Mode)**：
    - 在此模式下，AI 不会修改文件，而是专注于与用户对话、分析需求、制定详细计划。

---

### **核心要点（一句话总结）**

精通CoreCode的关键在于彻底转变思维，从代码编写者转变为AI的引导者，通过精细的上下文管理和周密的预先规划，将编码工作完全交给AI。

---

### **总体框架**

该内容提出了一个以**“规划驱动”**为核心的AI编程新范式。其框架可以概括为 **“指挥官-执行者”模型**：用户作为**指挥官**，负责**①定义目标与偏好（上下文管理）** 和 **②制定作战计划（规划与拆解）**；AI作为**执行者**，负责**③根据计划进行编码实现（小步迭代）**。整个过程通过高质量的**中间文档**进行连接和驱动，最终实现对项目开发的高效控制和高质量交付。

---

### **概念关系图 (Mermaid)**

<Mermaid_Diagram>
graph TD
    subgraph "用户角色转变 (Mindset Shift)"
        U["用户 (User)"] -- "转变" --> D["指挥官/引导者 (Commander/Director)"];
    end

    subgraph "核心实践三大支柱 (Three Pillars of Practice)"
        P1["精细化上下文管理 (Context Management)"];
        P2["规划先于行动 (Planning First)"];
        P3["小步迭代开发 (Iterative Development)"];
    end

    D -- "输入指令" --> P1;
    D -- "制定策略" --> P2;
    D -- "控制节奏" --> P3;

    subgraph "上下文具体内容 (Context Details)"
        direction LR
        C1["个人上下文 (Personal)"];
        C2["项目上下文 (Project)"];
        C3["中间文档 (Intermediate Docs)"];
    end
    
    P1 -- "包含" --> C1;
    P1 -- "包含" --> C2;
    P1 -- "包含" --> C3;

    subgraph "核心工作流 (Core Workflow)"
        WF1["1. 规划与拆解 (Plan & Decompose)"] -- "生成" --> C3;
        C3 -- "作为蓝图" --> WF2["2. AI编码执行 (AI Executes)"];
        WF2 -- "产出" --> WF3["3. 小步PR (Small PR)"];
        WF3 -- "需要" --> WF4["4. 用户审查 (User Reviews)"];
        WF4 -- "反馈" --> WF1;
    end
    
    P2 -- "驱动" --> WF1;
    P3 -- "体现为" --> WF3;
    
    subgraph "关键工具 (Key Tools)"
        T1["子代理 (Sub-agents)"];
        T2["上下文清理 (Compact/Clear)"];
        T3["规划模式 (Plan Mode)"];
    end

    P1 -- "辅助工具" --> T2;
    WF1 -- "使用" --> T3;
    P2 -- "可使用" --> T1;

    WF4 -- "最终交付" --> Result["高质量、可控的代码产出 (High-Quality, Controlled Code Output)"];

    style U fill:#D2E9FF,stroke:#333,stroke-width:2px;
    style D fill:#A8D3FF,stroke:#0055A4,stroke-width:3px;
    style Result fill:#A8E6A0,stroke:#237D23,stroke-width:3px;
    style P1 fill:#FFFACD,stroke:#333,stroke-width:2px;
    style P2 fill:#FFFACD,stroke:#333,stroke-width:2px;
    style P3 fill:#FFFACD,stroke:#333,stroke-width:2px;
    style C1 fill:#f9f7d9,stroke:#333,stroke-width:1px;
    style C2 fill:#f9f7d9,stroke:#333,stroke-width:1px;
    style C3 fill:#FFDDC1,stroke:#E57373,stroke-width:2px;
    style T1 fill:#E1E1E1,stroke:#333,stroke-width:1px;
    style T2 fill:#E1E1E1,stroke:#333,stroke-width:1px;
    style T3 fill:#E1E1E1,stroke:#333,stroke-width:1px;
    
    linkStyle 0 stroke:#0055A4,stroke-width:2px,stroke-dasharray: 5 5;
    linkStyle 9 stroke:#E57373,stroke-width:2px;
    linkStyle 10 stroke:#007bff,stroke-width:2px,stroke-dasharray: 2 2;
    linkStyle 12 stroke:#007bff,stroke-width:2px,stroke-dasharray: 2 2;
</Mermaid_Diagram>

Content:
大家好 我是统妹最近一个多月我都是非常密集的在使用CoreCode我的感觉是非常震惊的因为CoreCode之前基本上已经统治了AI变成这个领域大家觉得CoreCode是最好用的但是没想到CoreCode出现就是已经彻底打破了这个原来的这种形式而且挑战了原来的霸主地位这期视频想跟大家分享的就是CoreCode这东西用起来最重要的一些药点如果你想问了这期视频里的方法的话相信你CoreCode已经可以退订了因为你要学会用CoreCode的话你会发现CoreCode是真的非常非常好用它的效果会比CoreCode还好很多那我们快开始吧首先就是用了CoreCode的时候你跟传统的这种像CorePilot的CoreCode它的这个寿语模式是完全不一样的因为你用原来的有时候CoreCode的话你的默认是就是AI是你的助手然后你会经常需要去改一下它写的代码然后经常需要去有很多的人工干预那像CoreCode这种它在命令行里面去跟它沟通的这种方式它一开始你会觉得可能有点不太方便但习惯了以后就发现它这个产品CoreCode它从一开始设计的时候它就有比较好的全局的意识它能够理解和操作整个项目你的作用主要是给它提供一很多的更多的信息给它一些反馈但是写代码这件事情上你是完全不需要参与的用了CoreCode以后你基本上代码是可以完全不用碰的你需要去给它更多的一些信息然后你要告诉它具体要做的是什么它的计划也有哪些偏差它的理解有哪些偏差然后当你给它提供足够多的信息足够好的信息的时候它放手让它去做就可以了这个是思维模式是完全不一样的用了CoreCode以后你基本上一行代码都不需要去写了只要你会用它的话它给你的效果一定是非常好的所以这是想跟大家聊的第一点就是这个思维方式已经完成了变化了如果你还是觉得就是说原来那种有个编辑器以UI的一个见面比较方便的话那其实CoreCode它有那个ID的一个plug in就是比如说你如果用intali这些或者你用VS code上面用CoreCode的那个插件它就可以帮你实现这种就是比如说你接不接受它的这个代码改动或者说你拒绝类似于这种原来Core色的一些功能一些UI什么功能它这个插件其实已经给你提供了的如果你觉得不方便的话你可以再继续用CoreCode的这个插件但是总的来说这个思维方式我们还是会需要改变因为你用这个命令行的这个工具的话它其实是可以更大程度上去释放AI的潜能的然后我们基本上是不需要去参与它的代码的写那我们需要做什么呢用CoreCode的话你最重要的一定是你要给它足够的上下文而这个上下文不是越多越好而是最重要的最对它最有用的这些信息你一定要提供给它这其中包括主要是这三个方面第一个方面就是你个人的一些上下文就是个人的偏好比如说我会在上面说你要给它你要永远给我回复是回中文但是你写代码包括写在代码里面的这些评论都必须是要用英文然后我平常开发的这些项目它基本上用的是什么库然后我最常用的一些代码贪库的位置什么之类的我都会放在这个个人的上下文这里又这样在我不管开发哪个项目的时候它都可以提取这些信息然后项目上下文的话它是关于这个项目的一些核心的一些价格关键的模块一些重要的一些信息这个东西它最关键的一点是必须要check in到代码贪库里面去也就是跟阻礼的所有同事一起共享的然后大家有什么更新的话也需要更新这个项目的上下文它这个项目上下文其实不仅仅是项目跟目入的它也可以是紫模块每个紫模块下面也可以放一个Code点MD就是把这个模块相关的上下文放的这上面这样子Code它不需要每次都去理解一遍你的这个仓库理解一下这所有的这些技术站这些关键的流程之类的你把这个项目最重要的一些信息放在这里面会非常的有用然后第三点其实是最为重要的一点就是我们让Code做任何的事情做任何的项目其实很多时候我们都需要让它去做一些计划然后先做一些分析之类的东西这些中间产物都需要把它记下来然后我们最后这部分可能这个文本我们直接就扔掉或者说我们把这些信息放到类似于GirraKonference这种项目管理的那些页面上面去可以放在那里面去让我自己的话我有一个专门的一个文档的一个倡库文档的倡库里面会存放我所有的一些工作的一些文档如果需要共产的时候我再会把它会放到公司的一些网站上面去如果不需要共产的话可能我就会放在我个人的一些文档的倡库这样我下次去做同一个项目或者对这个项目要做一些更改的时候我把这些文档再拿出来然后给AI让他去了解一下这项目的背景第三点其实是真的是特别重要而且是用你用Code的如果要用得好和用得不好它最主要的区别在于这个我们很多时候我现在已经是不会去改那个AI鞋代码了因为AI改的代码我基本上不会理我想要的有太大的偏差其中的关键就在于我会把Code的做的这些计划然后做的这些分析我会仔细地看一下然后如果有什么不对的话我会直接在上面修改所以基本上我跟AI主要的沟通就在于这些文档上面只要你对这个你要做的事情文档搞得特别好然后拆分的足够细这Code基本上不太会出错了所以如果你把前期的这个工作做好你是根本不需要去跟它去再沟通自己代码的问题的它的代码写出来基本上都是ok的有什么问题你再让它修改一下就行了根本不需要自己动手去改代码所以很多人说用了Code以后基本上百分之九十九代码都是AI鞋的这个是一点的不夸张因为我确实也是这样子的没有必要自己在动手写代码但是最后你会发现就是你作为一个程序人真正核心的竞争力还是你的一个思维方式解决问题的一些方法论可能还是在现在这个AI的社会还是有用的一些东西我们继续再讲上下文因为上下文这东西用口Code是特别特别重要的看到有些人提出来这个概念就说上下文就像要管理内存一样它是上下文春口是需要我们精心去设计的一些已经不怎么管用的东西你就要即时地去做这种压缩比如说你功能做的做到一定的这个阶段了就执行一下Compact让它对之前的工作做一个总结压缩一下这样子就不会Context这个上下文太长然后最更常见的就是说我们直接开启一个新会化就是把上下文清空这个时候你会发现你之前做的一些文档的东西是特别特别管用因为我会经常去把上下文清空然后再让AI重新去读这些中间的文档再继续从之前做到哪了继续开始做所以这个中间文档会特别特别管用然后因为上下文春口它是特别特别珍贵的所以就一定要省着点用然后每次我们做的时候都是把这个要做的任务把它拆成很小的一步一步然后把这些相关的信息都写到中间文档里面去然后每次都是提起一个小的文档提起一个小的任务再去做而这边还有一个技巧就是用那个紫代理因为夸扣的除了这个Sup agent的功能你可以对一些常见的任务比如说分析代码然后做那个Code Review然后写测试之类的一些单独的任务可以用Sup agent的Sup agent它最大的优势之在于它的这个上下文是隔离的就跟你平常跟夸扣的主要对话的那个主窗口的那个上下文是完全不一样的所以它有这个隔离它不会去侮然那个主程序的上下文所以Sup agent也是我特别经常用的然后之前其实我没讲到了这个规划也是用Code的最为重要的一个要点如果很多时候我们直接上来就让AI去做很多东西的话它做的效果其实也不好所以你觉得好像说这样做的快一点因为但是但实际上它的东西做的不好的话你还是要反攻还是要反复的去修改其实很麻烦你不如让它在写代码之前你先多花一些时间跟它聊来聊去让它去理解比如说现在的代码流程是什么样子的然后你要新做的功能是什么样子的你都通过对话跟它去聊清楚然后再把任务拆解再一点一点一个小任务一个小任务去做因为这种先做 plan的这种方式是更推荐的这个我在其他地方也看到就是叫先谋定而后动这个像孙子冰把的这个原理在用夸扣的上特别的使用就是我们一定要先做谋虑然后先去做很详细很详细的鬼话然后再去行动这样子的这个结果基本上不需要太多的反攻而且也能够帮助你自己也能够理解这个项目应该怎么做每一步以它实在做什么因为我们虽然在用 AI但是不能说真的是完全全部都交给 AI了因为你如果你自己都不理解没办法去语语的话那你这个工作就没有存在的任何价值所以我们自己也得搞懂 AI在做些什么事情AI搞的东西对不对好不好我们得有能力去判断所以也是需要去跟它去 AI去反复的去讨论我这个要做什么我应该怎么做之类的就是基本上在开始写代码之前你会跟它聊聊聊去聊这些具体的实现细节然后再开始做基本上工作模式都是这样然后这个 PPT讲的也是这个最佳实践就是每次做都是一个很小步的一个迭代像有的人工作它可能习惯就是每次它提一个 TR它可能就是不超过200行的一个改动这样子因为比较容易去 review尤其是在现在因为都是 AI时代了如果我们不去这样去小步迭代AI他一下子给你写几万行代码都是可以的他都能做的但是你一下子搞那么多根本没有办法去 review他的代码那可能有很多潜在的问题是难以发现的而且以后维护起来会特别的困难所以如果我们真的要做好肯定是每次都只做很小的一块然后提一个 PR 脑子然后再你再做第二个这样虽然麻烦一点但是这样子的话你对整个项目的控制是比较有力的不会让 AI去失控那我这边还准备了一些作业就是如果大家用Qaq的话可以先把这些最基础的一些东西设置好第一步先把自己个人的保扣的先搞起来然后把你最重要的一些编码的一些习惯一些风格放在那上面然后到每个项目你可以用这个引力的方法然后它可以把这个项目出使坏一下它会阅读整个项目的一些文件然后它去理解这个项目是干什么的核心的一些最重要的东西是什么它会自己去写的这个项目的那个跨点地上面去然后你可以试一下就是你要做什么东西之前先让跨的去解释一下你项目当中某一个业务流程是什么样子的然后你可以把这个过程记下来作为一个中间的文件将来你要做这相关的改动的时候你可以拿出来让AI读一下然后在做之前可以尝试一下这个计划模式就是用Ship tab而这样的话这个时候Core它不会去改东西它会一直去跟你去聊天然后它去分析然后去理解这个现在的代码然后新的需求之类的去帮你去做很强势的规划然后最后一个作业就是说这个compet跟Clear这两个命令要经常的使用所以我们可以多熟练一下这两个命令那本期视频讲的没有太多翻译的东西它是用CoreCore的要用好最基本的一些内供就是如果我们把我们的理解思维方式转过转化过来我们是就放手让AI全部去做那就是CoreCore的一个设计精髓然后我们再把这个上下文管理的非常好然后把规划做的非常好基本上你就掌握了CoreCore的内供了然后你经常使用的话你再用一些花哨的一些技巧比如说你再用自定义的一些命令自定义的这些在Bagent那肯定可以让CoreCore的发挥出更多的效益那咱们话不多说大家快适用起来吧你用了你就知道有多好用了欢迎你在评论区下方给我留言我们起来讨论你的点赞评论和转发对我的视频特别重要那我们下期再见吧拜拜
